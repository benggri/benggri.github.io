"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@floating-ui";
exports.ids = ["vendor-chunks/@floating-ui"];
exports.modules = {

/***/ "(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@floating-ui/core/dist/floating-ui.core.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   rectToClientRect: () => (/* reexport safe */ _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n    let { reference, floating } = _ref;\n    const sideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n    const alignmentAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n    const alignLength = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(alignmentAxis);\n    const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n    const isVertical = sideAxis === \"y\";\n    const commonX = reference.x + reference.width / 2 - floating.width / 2;\n    const commonY = reference.y + reference.height / 2 - floating.height / 2;\n    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n    let coords;\n    switch(side){\n        case \"top\":\n            coords = {\n                x: commonX,\n                y: reference.y - floating.height\n            };\n            break;\n        case \"bottom\":\n            coords = {\n                x: commonX,\n                y: reference.y + reference.height\n            };\n            break;\n        case \"right\":\n            coords = {\n                x: reference.x + reference.width,\n                y: commonY\n            };\n            break;\n        case \"left\":\n            coords = {\n                x: reference.x - floating.width,\n                y: commonY\n            };\n            break;\n        default:\n            coords = {\n                x: reference.x,\n                y: reference.y\n            };\n    }\n    switch((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement)){\n        case \"start\":\n            coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n        case \"end\":\n            coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n    }\n    return coords;\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */ const computePosition = async (reference, floating, config)=>{\n    const { placement = \"bottom\", strategy = \"absolute\", middleware = [], platform } = config;\n    const validMiddleware = middleware.filter(Boolean);\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n    let rects = await platform.getElementRects({\n        reference,\n        floating,\n        strategy\n    });\n    let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);\n    let statefulPlacement = placement;\n    let middlewareData = {};\n    let resetCount = 0;\n    for(let i = 0; i < validMiddleware.length; i++){\n        const { name, fn } = validMiddleware[i];\n        const { x: nextX, y: nextY, data, reset } = await fn({\n            x,\n            y,\n            initialPlacement: placement,\n            placement: statefulPlacement,\n            strategy,\n            middlewareData,\n            rects,\n            platform,\n            elements: {\n                reference,\n                floating\n            }\n        });\n        x = nextX != null ? nextX : x;\n        y = nextY != null ? nextY : y;\n        middlewareData = {\n            ...middlewareData,\n            [name]: {\n                ...middlewareData[name],\n                ...data\n            }\n        };\n        if (reset && resetCount <= 50) {\n            resetCount++;\n            if (typeof reset === \"object\") {\n                if (reset.placement) {\n                    statefulPlacement = reset.placement;\n                }\n                if (reset.rects) {\n                    rects = reset.rects === true ? await platform.getElementRects({\n                        reference,\n                        floating,\n                        strategy\n                    }) : reset.rects;\n                }\n                ({ x, y } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n            }\n            i = -1;\n            continue;\n        }\n    }\n    return {\n        x,\n        y,\n        placement: statefulPlacement,\n        strategy,\n        middlewareData\n    };\n};\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */ async function detectOverflow(state, options) {\n    var _await$platform$isEle;\n    if (options === void 0) {\n        options = {};\n    }\n    const { x, y, platform, rects, elements, strategy } = state;\n    const { boundary = \"clippingAncestors\", rootBoundary = \"viewport\", elementContext = \"floating\", altBoundary = false, padding = 0 } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n    const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n    const altContext = elementContext === \"floating\" ? \"reference\" : \"floating\";\n    const element = elements[altBoundary ? altContext : elementContext];\n    const clippingClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(await platform.getClippingRect({\n        element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)),\n        boundary,\n        rootBoundary,\n        strategy\n    }));\n    const rect = elementContext === \"floating\" ? {\n        ...rects.floating,\n        x,\n        y\n    } : rects.reference;\n    const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n    const offsetScale = await (platform.isElement == null ? void 0 : platform.isElement(offsetParent)) ? await (platform.getScale == null ? void 0 : platform.getScale(offsetParent)) || {\n        x: 1,\n        y: 1\n    } : {\n        x: 1,\n        y: 1\n    };\n    const elementClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect,\n        offsetParent,\n        strategy\n    }) : rect);\n    return {\n        top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n        bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n        left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n        right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n    };\n}\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = (options)=>({\n        name: \"arrow\",\n        options,\n        async fn (state) {\n            const { x, y, placement, rects, platform, elements, middlewareData } = state;\n            // Since `element` is required, we don't Partial<> the type.\n            const { element, padding = 0 } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state) || {};\n            if (element == null) {\n                return {};\n            }\n            const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n            const coords = {\n                x,\n                y\n            };\n            const axis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n            const length = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(axis);\n            const arrowDimensions = await platform.getDimensions(element);\n            const isYAxis = axis === \"y\";\n            const minProp = isYAxis ? \"top\" : \"left\";\n            const maxProp = isYAxis ? \"bottom\" : \"right\";\n            const clientProp = isYAxis ? \"clientHeight\" : \"clientWidth\";\n            const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n            const startDiff = coords[axis] - rects.reference[axis];\n            const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n            let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n            // DOM platform can return `window` as the `offsetParent`.\n            if (!clientSize || !await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent))) {\n                clientSize = elements.floating[clientProp] || rects.floating[length];\n            }\n            const centerToReference = endDiff / 2 - startDiff / 2;\n            // If the padding is large enough that it causes the arrow to no longer be\n            // centered, modify the padding so that it is centered.\n            const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n            const minPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[minProp], largestPossiblePadding);\n            const maxPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[maxProp], largestPossiblePadding);\n            // Make sure the arrow doesn't overflow the floating element if the center\n            // point is outside the floating element's bounds.\n            const min$1 = minPadding;\n            const max = clientSize - arrowDimensions[length] - maxPadding;\n            const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n            const offset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min$1, center, max);\n            // If the reference is small enough that the arrow's padding causes it to\n            // to point to nothing for an aligned placement, adjust the offset of the\n            // floating element itself. To ensure `shift()` continues to take action,\n            // a single reset is performed when this is true.\n            const shouldAddOffset = !middlewareData.arrow && (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n            const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n            return {\n                [axis]: coords[axis] + alignmentOffset,\n                data: {\n                    [axis]: offset,\n                    centerOffset: center - offset - alignmentOffset,\n                    ...shouldAddOffset && {\n                        alignmentOffset\n                    }\n                },\n                reset: shouldAddOffset\n            };\n        }\n    });\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n    const allowedPlacementsSortedByAlignment = alignment ? [\n        ...allowedPlacements.filter((placement)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment),\n        ...allowedPlacements.filter((placement)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) !== alignment)\n    ] : allowedPlacements.filter((placement)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === placement);\n    return allowedPlacementsSortedByAlignment.filter((placement)=>{\n        if (alignment) {\n            return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment || (autoAlignment ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAlignmentPlacement)(placement) !== placement : false);\n        }\n        return true;\n    });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */ const autoPlacement = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"autoPlacement\",\n        options,\n        async fn (state) {\n            var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n            const { rects, middlewareData, placement, platform, elements } = state;\n            const { crossAxis = false, alignment, allowedPlacements = _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements, autoAlignment = true, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const placements$1 = alignment !== undefined || allowedPlacements === _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n            const currentPlacement = placements$1[currentIndex];\n            if (currentPlacement == null) {\n                return {};\n            }\n            const alignmentSides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n            // Make `computeCoords` start from the right place.\n            if (placement !== currentPlacement) {\n                return {\n                    reset: {\n                        placement: placements$1[0]\n                    }\n                };\n            }\n            const currentOverflows = [\n                overflow[(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(currentPlacement)],\n                overflow[alignmentSides[0]],\n                overflow[alignmentSides[1]]\n            ];\n            const allOverflows = [\n                ...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [],\n                {\n                    placement: currentPlacement,\n                    overflows: currentOverflows\n                }\n            ];\n            const nextPlacement = placements$1[currentIndex + 1];\n            // There are more placements to check.\n            if (nextPlacement) {\n                return {\n                    data: {\n                        index: currentIndex + 1,\n                        overflows: allOverflows\n                    },\n                    reset: {\n                        placement: nextPlacement\n                    }\n                };\n            }\n            const placementsSortedByMostSpace = allOverflows.map((d)=>{\n                const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d.placement);\n                return [\n                    d.placement,\n                    alignment && crossAxis ? // Check along the mainAxis and main crossAxis side.\n                    d.overflows.slice(0, 2).reduce((acc, v)=>acc + v, 0) : // Check only the mainAxis.\n                    d.overflows[0],\n                    d.overflows\n                ];\n            }).sort((a, b)=>a[1] - b[1]);\n            const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d)=>d[2].slice(0, // Aligned placements should not check their opposite crossAxis\n                // side.\n                (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d[0]) ? 2 : 3).every((v)=>v <= 0));\n            const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n            if (resetPlacement !== placement) {\n                return {\n                    data: {\n                        index: currentIndex + 1,\n                        overflows: allOverflows\n                    },\n                    reset: {\n                        placement: resetPlacement\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */ const flip = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"flip\",\n        options,\n        async fn (state) {\n            var _middlewareData$arrow, _middlewareData$flip;\n            const { placement, middlewareData, rects, initialPlacement, platform, elements } = state;\n            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true, fallbackPlacements: specifiedFallbackPlacements, fallbackStrategy = \"bestFit\", fallbackAxisSideDirection = \"none\", flipAlignment = true, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            // If a reset by the arrow was caused due to an alignment offset being\n            // added, we should skip any logic now since `flip()` has already done its\n            // work.\n            // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n            if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n                return {};\n            }\n            const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n            const isBasePlacement = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(initialPlacement) === initialPlacement;\n            const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n            const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [\n                (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositePlacement)(initialPlacement)\n            ] : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getExpandedPlacements)(initialPlacement));\n            if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== \"none\") {\n                fallbackPlacements.push(...(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxisPlacements)(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n            }\n            const placements = [\n                initialPlacement,\n                ...fallbackPlacements\n            ];\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const overflows = [];\n            let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n            if (checkMainAxis) {\n                overflows.push(overflow[side]);\n            }\n            if (checkCrossAxis) {\n                const sides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(placement, rects, rtl);\n                overflows.push(overflow[sides[0]], overflow[sides[1]]);\n            }\n            overflowsData = [\n                ...overflowsData,\n                {\n                    placement,\n                    overflows\n                }\n            ];\n            // One or more sides is overflowing.\n            if (!overflows.every((side)=>side <= 0)) {\n                var _middlewareData$flip2, _overflowsData$filter;\n                const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n                const nextPlacement = placements[nextIndex];\n                if (nextPlacement) {\n                    // Try next placement and re-run the lifecycle.\n                    return {\n                        data: {\n                            index: nextIndex,\n                            overflows: overflowsData\n                        },\n                        reset: {\n                            placement: nextPlacement\n                        }\n                    };\n                }\n                // First, find the candidates that fit on the mainAxis side of overflow,\n                // then find the placement that fits the best on the main crossAxis side.\n                let resetPlacement = (_overflowsData$filter = overflowsData.filter((d)=>d.overflows[0] <= 0).sort((a, b)=>a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n                // Otherwise fallback.\n                if (!resetPlacement) {\n                    switch(fallbackStrategy){\n                        case \"bestFit\":\n                            {\n                                var _overflowsData$map$so;\n                                const placement = (_overflowsData$map$so = overflowsData.map((d)=>[\n                                        d.placement,\n                                        d.overflows.filter((overflow)=>overflow > 0).reduce((acc, overflow)=>acc + overflow, 0)\n                                    ]).sort((a, b)=>a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                                if (placement) {\n                                    resetPlacement = placement;\n                                }\n                                break;\n                            }\n                        case \"initialPlacement\":\n                            resetPlacement = initialPlacement;\n                            break;\n                    }\n                }\n                if (placement !== resetPlacement) {\n                    return {\n                        reset: {\n                            placement: resetPlacement\n                        }\n                    };\n                }\n            }\n            return {};\n        }\n    };\n};\nfunction getSideOffsets(overflow, rect) {\n    return {\n        top: overflow.top - rect.height,\n        right: overflow.right - rect.width,\n        bottom: overflow.bottom - rect.height,\n        left: overflow.left - rect.width\n    };\n}\nfunction isAnySideFullyClipped(overflow) {\n    return _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.sides.some((side)=>overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */ const hide = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"hide\",\n        options,\n        async fn (state) {\n            const { rects } = state;\n            const { strategy = \"referenceHidden\", ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            switch(strategy){\n                case \"referenceHidden\":\n                    {\n                        const overflow = await detectOverflow(state, {\n                            ...detectOverflowOptions,\n                            elementContext: \"reference\"\n                        });\n                        const offsets = getSideOffsets(overflow, rects.reference);\n                        return {\n                            data: {\n                                referenceHiddenOffsets: offsets,\n                                referenceHidden: isAnySideFullyClipped(offsets)\n                            }\n                        };\n                    }\n                case \"escaped\":\n                    {\n                        const overflow = await detectOverflow(state, {\n                            ...detectOverflowOptions,\n                            altBoundary: true\n                        });\n                        const offsets = getSideOffsets(overflow, rects.floating);\n                        return {\n                            data: {\n                                escapedOffsets: offsets,\n                                escaped: isAnySideFullyClipped(offsets)\n                            }\n                        };\n                    }\n                default:\n                    {\n                        return {};\n                    }\n            }\n        }\n    };\n};\nfunction getBoundingRect(rects) {\n    const minX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map((rect)=>rect.left));\n    const minY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map((rect)=>rect.top));\n    const maxX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map((rect)=>rect.right));\n    const maxY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map((rect)=>rect.bottom));\n    return {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY\n    };\n}\nfunction getRectsByLine(rects) {\n    const sortedRects = rects.slice().sort((a, b)=>a.y - b.y);\n    const groups = [];\n    let prevRect = null;\n    for(let i = 0; i < sortedRects.length; i++){\n        const rect = sortedRects[i];\n        if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n            groups.push([\n                rect\n            ]);\n        } else {\n            groups[groups.length - 1].push(rect);\n        }\n        prevRect = rect;\n    }\n    return groups.map((rect)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */ const inline = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"inline\",\n        options,\n        async fn (state) {\n            const { placement, elements, rects, platform, strategy } = state;\n            // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n            // ClientRect's bounds, despite the event listener being triggered. A\n            // padding of 2 seems to handle this issue.\n            const { padding = 2, x, y } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const nativeClientRects = Array.from(await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference)) || []);\n            const clientRects = getRectsByLine(nativeClientRects);\n            const fallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(nativeClientRects));\n            const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n            function getBoundingClientRect() {\n                // There are two rects and they are disjoined.\n                if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n                    // Find the first rect in which the point is fully inside.\n                    return clientRects.find((rect)=>x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n                }\n                // There are 2 or more connected rects.\n                if (clientRects.length >= 2) {\n                    if ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === \"y\") {\n                        const firstRect = clientRects[0];\n                        const lastRect = clientRects[clientRects.length - 1];\n                        const isTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === \"top\";\n                        const top = firstRect.top;\n                        const bottom = lastRect.bottom;\n                        const left = isTop ? firstRect.left : lastRect.left;\n                        const right = isTop ? firstRect.right : lastRect.right;\n                        const width = right - left;\n                        const height = bottom - top;\n                        return {\n                            top,\n                            bottom,\n                            left,\n                            right,\n                            width,\n                            height,\n                            x: left,\n                            y: top\n                        };\n                    }\n                    const isLeftSide = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === \"left\";\n                    const maxRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...clientRects.map((rect)=>rect.right));\n                    const minLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...clientRects.map((rect)=>rect.left));\n                    const measureRects = clientRects.filter((rect)=>isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n                    const top = measureRects[0].top;\n                    const bottom = measureRects[measureRects.length - 1].bottom;\n                    const left = minLeft;\n                    const right = maxRight;\n                    const width = right - left;\n                    const height = bottom - top;\n                    return {\n                        top,\n                        bottom,\n                        left,\n                        right,\n                        width,\n                        height,\n                        x: left,\n                        y: top\n                    };\n                }\n                return fallback;\n            }\n            const resetRects = await platform.getElementRects({\n                reference: {\n                    getBoundingClientRect\n                },\n                floating: elements.floating,\n                strategy\n            });\n            if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n                return {\n                    reset: {\n                        rects: resetRects\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\nasync function convertValueToCoords(state, options) {\n    const { placement, platform, elements } = state;\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n    const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n    const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n    const isVertical = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === \"y\";\n    const mainAxisMulti = [\n        \"left\",\n        \"top\"\n    ].includes(side) ? -1 : 1;\n    const crossAxisMulti = rtl && isVertical ? -1 : 1;\n    const rawValue = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n    // eslint-disable-next-line prefer-const\n    let { mainAxis, crossAxis, alignmentAxis } = typeof rawValue === \"number\" ? {\n        mainAxis: rawValue,\n        crossAxis: 0,\n        alignmentAxis: null\n    } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        alignmentAxis: null,\n        ...rawValue\n    };\n    if (alignment && typeof alignmentAxis === \"number\") {\n        crossAxis = alignment === \"end\" ? alignmentAxis * -1 : alignmentAxis;\n    }\n    return isVertical ? {\n        x: crossAxis * crossAxisMulti,\n        y: mainAxis * mainAxisMulti\n    } : {\n        x: mainAxis * mainAxisMulti,\n        y: crossAxis * crossAxisMulti\n    };\n}\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */ const offset = function(options) {\n    if (options === void 0) {\n        options = 0;\n    }\n    return {\n        name: \"offset\",\n        options,\n        async fn (state) {\n            var _middlewareData$offse, _middlewareData$arrow;\n            const { x, y, placement, middlewareData } = state;\n            const diffCoords = await convertValueToCoords(state, options);\n            // If the placement is the same and the arrow caused an alignment offset\n            // then we don't need to change the positioning coordinates.\n            if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n                return {};\n            }\n            return {\n                x: x + diffCoords.x,\n                y: y + diffCoords.y,\n                data: {\n                    ...diffCoords,\n                    placement\n                }\n            };\n        }\n    };\n};\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */ const shift = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"shift\",\n        options,\n        async fn (state) {\n            const { x, y, placement } = state;\n            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = false, limiter = {\n                fn: (_ref)=>{\n                    let { x, y } = _ref;\n                    return {\n                        x,\n                        y\n                    };\n                }\n            }, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const coords = {\n                x,\n                y\n            };\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n            const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n            let mainAxisCoord = coords[mainAxis];\n            let crossAxisCoord = coords[crossAxis];\n            if (checkMainAxis) {\n                const minSide = mainAxis === \"y\" ? \"top\" : \"left\";\n                const maxSide = mainAxis === \"y\" ? \"bottom\" : \"right\";\n                const min = mainAxisCoord + overflow[minSide];\n                const max = mainAxisCoord - overflow[maxSide];\n                mainAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, mainAxisCoord, max);\n            }\n            if (checkCrossAxis) {\n                const minSide = crossAxis === \"y\" ? \"top\" : \"left\";\n                const maxSide = crossAxis === \"y\" ? \"bottom\" : \"right\";\n                const min = crossAxisCoord + overflow[minSide];\n                const max = crossAxisCoord - overflow[maxSide];\n                crossAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, crossAxisCoord, max);\n            }\n            const limitedCoords = limiter.fn({\n                ...state,\n                [mainAxis]: mainAxisCoord,\n                [crossAxis]: crossAxisCoord\n            });\n            return {\n                ...limitedCoords,\n                data: {\n                    x: limitedCoords.x - x,\n                    y: limitedCoords.y - y\n                }\n            };\n        }\n    };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */ const limitShift = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        options,\n        fn (state) {\n            const { x, y, placement, rects, middlewareData } = state;\n            const { offset = 0, mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const coords = {\n                x,\n                y\n            };\n            const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n            const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n            let mainAxisCoord = coords[mainAxis];\n            let crossAxisCoord = coords[crossAxis];\n            const rawOffset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(offset, state);\n            const computedOffset = typeof rawOffset === \"number\" ? {\n                mainAxis: rawOffset,\n                crossAxis: 0\n            } : {\n                mainAxis: 0,\n                crossAxis: 0,\n                ...rawOffset\n            };\n            if (checkMainAxis) {\n                const len = mainAxis === \"y\" ? \"height\" : \"width\";\n                const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n                const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n                if (mainAxisCoord < limitMin) {\n                    mainAxisCoord = limitMin;\n                } else if (mainAxisCoord > limitMax) {\n                    mainAxisCoord = limitMax;\n                }\n            }\n            if (checkCrossAxis) {\n                var _middlewareData$offse, _middlewareData$offse2;\n                const len = mainAxis === \"y\" ? \"width\" : \"height\";\n                const isOriginSide = [\n                    \"top\",\n                    \"left\"\n                ].includes((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n                const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n                const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n                if (crossAxisCoord < limitMin) {\n                    crossAxisCoord = limitMin;\n                } else if (crossAxisCoord > limitMax) {\n                    crossAxisCoord = limitMax;\n                }\n            }\n            return {\n                [mainAxis]: mainAxisCoord,\n                [crossAxis]: crossAxisCoord\n            };\n        }\n    };\n};\n/**\n * Provides data that allows you to change the size of the floating element â€”\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */ const size = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"size\",\n        options,\n        async fn (state) {\n            const { placement, rects, platform, elements } = state;\n            const { apply = ()=>{}, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n            const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n            const isYAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === \"y\";\n            const { width, height } = rects.floating;\n            let heightSide;\n            let widthSide;\n            if (side === \"top\" || side === \"bottom\") {\n                heightSide = side;\n                widthSide = alignment === (await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)) ? \"start\" : \"end\") ? \"left\" : \"right\";\n            } else {\n                widthSide = side;\n                heightSide = alignment === \"end\" ? \"top\" : \"bottom\";\n            }\n            const overflowAvailableHeight = height - overflow[heightSide];\n            const overflowAvailableWidth = width - overflow[widthSide];\n            const noShift = !state.middlewareData.shift;\n            let availableHeight = overflowAvailableHeight;\n            let availableWidth = overflowAvailableWidth;\n            if (isYAxis) {\n                const maximumClippingWidth = width - overflow.left - overflow.right;\n                availableWidth = alignment || noShift ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n            } else {\n                const maximumClippingHeight = height - overflow.top - overflow.bottom;\n                availableHeight = alignment || noShift ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n            }\n            if (noShift && !alignment) {\n                const xMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, 0);\n                const xMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.right, 0);\n                const yMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, 0);\n                const yMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.bottom, 0);\n                if (isYAxis) {\n                    availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, overflow.right));\n                } else {\n                    availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, overflow.bottom));\n                }\n            }\n            await apply({\n                ...state,\n                availableWidth,\n                availableHeight\n            });\n            const nextDimensions = await platform.getDimensions(elements.floating);\n            if (width !== nextDimensions.width || height !== nextDimensions.height) {\n                return {\n                    reset: {\n                        rects: true\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXNVO0FBQ2hSO0FBRXRELFNBQVNtQiwyQkFBMkJDLElBQUksRUFBRUMsU0FBUyxFQUFFQyxHQUFHO0lBQ3RELElBQUksRUFDRkMsU0FBUyxFQUNUQyxRQUFRLEVBQ1QsR0FBR0o7SUFDSixNQUFNSyxXQUFXekIsK0RBQVdBLENBQUNxQjtJQUM3QixNQUFNSyxnQkFBZ0J6QixvRUFBZ0JBLENBQUNvQjtJQUN2QyxNQUFNTSxjQUFjekIsaUVBQWFBLENBQUN3QjtJQUNsQyxNQUFNRSxPQUFPekIsMkRBQU9BLENBQUNrQjtJQUNyQixNQUFNUSxhQUFhSixhQUFhO0lBQ2hDLE1BQU1LLFVBQVVQLFVBQVVRLENBQUMsR0FBR1IsVUFBVVMsS0FBSyxHQUFHLElBQUlSLFNBQVNRLEtBQUssR0FBRztJQUNyRSxNQUFNQyxVQUFVVixVQUFVVyxDQUFDLEdBQUdYLFVBQVVZLE1BQU0sR0FBRyxJQUFJWCxTQUFTVyxNQUFNLEdBQUc7SUFDdkUsTUFBTUMsY0FBY2IsU0FBUyxDQUFDSSxZQUFZLEdBQUcsSUFBSUgsUUFBUSxDQUFDRyxZQUFZLEdBQUc7SUFDekUsSUFBSVU7SUFDSixPQUFRVDtRQUNOLEtBQUs7WUFDSFMsU0FBUztnQkFDUE4sR0FBR0Q7Z0JBQ0hJLEdBQUdYLFVBQVVXLENBQUMsR0FBR1YsU0FBU1csTUFBTTtZQUNsQztZQUNBO1FBQ0YsS0FBSztZQUNIRSxTQUFTO2dCQUNQTixHQUFHRDtnQkFDSEksR0FBR1gsVUFBVVcsQ0FBQyxHQUFHWCxVQUFVWSxNQUFNO1lBQ25DO1lBQ0E7UUFDRixLQUFLO1lBQ0hFLFNBQVM7Z0JBQ1BOLEdBQUdSLFVBQVVRLENBQUMsR0FBR1IsVUFBVVMsS0FBSztnQkFDaENFLEdBQUdEO1lBQ0w7WUFDQTtRQUNGLEtBQUs7WUFDSEksU0FBUztnQkFDUE4sR0FBR1IsVUFBVVEsQ0FBQyxHQUFHUCxTQUFTUSxLQUFLO2dCQUMvQkUsR0FBR0Q7WUFDTDtZQUNBO1FBQ0Y7WUFDRUksU0FBUztnQkFDUE4sR0FBR1IsVUFBVVEsQ0FBQztnQkFDZEcsR0FBR1gsVUFBVVcsQ0FBQztZQUNoQjtJQUNKO0lBQ0EsT0FBUTlCLGdFQUFZQSxDQUFDaUI7UUFDbkIsS0FBSztZQUNIZ0IsTUFBTSxDQUFDWCxjQUFjLElBQUlVLGNBQWVkLENBQUFBLE9BQU9PLGFBQWEsQ0FBQyxJQUFJO1lBQ2pFO1FBQ0YsS0FBSztZQUNIUSxNQUFNLENBQUNYLGNBQWMsSUFBSVUsY0FBZWQsQ0FBQUEsT0FBT08sYUFBYSxDQUFDLElBQUk7WUFDakU7SUFDSjtJQUNBLE9BQU9RO0FBQ1Q7QUFFQTs7Ozs7O0NBTUMsR0FDRCxNQUFNQyxrQkFBa0IsT0FBT2YsV0FBV0MsVUFBVWU7SUFDbEQsTUFBTSxFQUNKbEIsWUFBWSxRQUFRLEVBQ3BCbUIsV0FBVyxVQUFVLEVBQ3JCQyxhQUFhLEVBQUUsRUFDZkMsUUFBUSxFQUNULEdBQUdIO0lBQ0osTUFBTUksa0JBQWtCRixXQUFXRyxNQUFNLENBQUNDO0lBQzFDLE1BQU12QixNQUFNLE1BQU9vQixDQUFBQSxTQUFTSSxLQUFLLElBQUksT0FBTyxLQUFLLElBQUlKLFNBQVNJLEtBQUssQ0FBQ3RCLFNBQVE7SUFDNUUsSUFBSXVCLFFBQVEsTUFBTUwsU0FBU00sZUFBZSxDQUFDO1FBQ3pDekI7UUFDQUM7UUFDQWdCO0lBQ0Y7SUFDQSxJQUFJLEVBQ0ZULENBQUMsRUFDREcsQ0FBQyxFQUNGLEdBQUdmLDJCQUEyQjRCLE9BQU8xQixXQUFXQztJQUNqRCxJQUFJMkIsb0JBQW9CNUI7SUFDeEIsSUFBSTZCLGlCQUFpQixDQUFDO0lBQ3RCLElBQUlDLGFBQWE7SUFDakIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlULGdCQUFnQlUsTUFBTSxFQUFFRCxJQUFLO1FBQy9DLE1BQU0sRUFDSkUsSUFBSSxFQUNKQyxFQUFFLEVBQ0gsR0FBR1osZUFBZSxDQUFDUyxFQUFFO1FBQ3RCLE1BQU0sRUFDSnJCLEdBQUd5QixLQUFLLEVBQ1J0QixHQUFHdUIsS0FBSyxFQUNSQyxJQUFJLEVBQ0pDLEtBQUssRUFDTixHQUFHLE1BQU1KLEdBQUc7WUFDWHhCO1lBQ0FHO1lBQ0EwQixrQkFBa0J2QztZQUNsQkEsV0FBVzRCO1lBQ1hUO1lBQ0FVO1lBQ0FIO1lBQ0FMO1lBQ0FtQixVQUFVO2dCQUNSdEM7Z0JBQ0FDO1lBQ0Y7UUFDRjtRQUNBTyxJQUFJeUIsU0FBUyxPQUFPQSxRQUFRekI7UUFDNUJHLElBQUl1QixTQUFTLE9BQU9BLFFBQVF2QjtRQUM1QmdCLGlCQUFpQjtZQUNmLEdBQUdBLGNBQWM7WUFDakIsQ0FBQ0ksS0FBSyxFQUFFO2dCQUNOLEdBQUdKLGNBQWMsQ0FBQ0ksS0FBSztnQkFDdkIsR0FBR0ksSUFBSTtZQUNUO1FBQ0Y7UUFDQSxJQUFJQyxTQUFTUixjQUFjLElBQUk7WUFDN0JBO1lBQ0EsSUFBSSxPQUFPUSxVQUFVLFVBQVU7Z0JBQzdCLElBQUlBLE1BQU10QyxTQUFTLEVBQUU7b0JBQ25CNEIsb0JBQW9CVSxNQUFNdEMsU0FBUztnQkFDckM7Z0JBQ0EsSUFBSXNDLE1BQU1aLEtBQUssRUFBRTtvQkFDZkEsUUFBUVksTUFBTVosS0FBSyxLQUFLLE9BQU8sTUFBTUwsU0FBU00sZUFBZSxDQUFDO3dCQUM1RHpCO3dCQUNBQzt3QkFDQWdCO29CQUNGLEtBQUttQixNQUFNWixLQUFLO2dCQUNsQjtnQkFDQyxHQUNDaEIsQ0FBQyxFQUNERyxDQUFDLEVBQ0YsR0FBR2YsMkJBQTJCNEIsT0FBT0UsbUJBQW1CM0IsSUFBRztZQUM5RDtZQUNBOEIsSUFBSSxDQUFDO1lBQ0w7UUFDRjtJQUNGO0lBQ0EsT0FBTztRQUNMckI7UUFDQUc7UUFDQWIsV0FBVzRCO1FBQ1hUO1FBQ0FVO0lBQ0Y7QUFDRjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxlQUFlWSxlQUFlQyxLQUFLLEVBQUVDLE9BQU87SUFDMUMsSUFBSUM7SUFDSixJQUFJRCxZQUFZLEtBQUssR0FBRztRQUN0QkEsVUFBVSxDQUFDO0lBQ2I7SUFDQSxNQUFNLEVBQ0pqQyxDQUFDLEVBQ0RHLENBQUMsRUFDRFEsUUFBUSxFQUNSSyxLQUFLLEVBQ0xjLFFBQVEsRUFDUnJCLFFBQVEsRUFDVCxHQUFHdUI7SUFDSixNQUFNLEVBQ0pHLFdBQVcsbUJBQW1CLEVBQzlCQyxlQUFlLFVBQVUsRUFDekJDLGlCQUFpQixVQUFVLEVBQzNCQyxjQUFjLEtBQUssRUFDbkJDLFVBQVUsQ0FBQyxFQUNaLEdBQUdqRSw0REFBUUEsQ0FBQzJELFNBQVNEO0lBQ3RCLE1BQU1RLGdCQUFnQmpFLG9FQUFnQkEsQ0FBQ2dFO0lBQ3ZDLE1BQU1FLGFBQWFKLG1CQUFtQixhQUFhLGNBQWM7SUFDakUsTUFBTUssVUFBVVosUUFBUSxDQUFDUSxjQUFjRyxhQUFhSixlQUFlO0lBQ25FLE1BQU1NLHFCQUFxQm5FLG9FQUFnQkEsQ0FBQyxNQUFNbUMsU0FBU2lDLGVBQWUsQ0FBQztRQUN6RUYsU0FBUyxDQUFDLENBQUNSLHdCQUF3QixNQUFPdkIsQ0FBQUEsU0FBU2tDLFNBQVMsSUFBSSxPQUFPLEtBQUssSUFBSWxDLFNBQVNrQyxTQUFTLENBQUNILFFBQU8sQ0FBQyxLQUFNLE9BQU9SLHdCQUF3QixJQUFHLElBQUtRLFVBQVVBLFFBQVFJLGNBQWMsSUFBSyxNQUFPbkMsQ0FBQUEsU0FBU29DLGtCQUFrQixJQUFJLE9BQU8sS0FBSyxJQUFJcEMsU0FBU29DLGtCQUFrQixDQUFDakIsU0FBU3JDLFFBQVE7UUFDaFMwQztRQUNBQztRQUNBM0I7SUFDRjtJQUNBLE1BQU11QyxPQUFPWCxtQkFBbUIsYUFBYTtRQUMzQyxHQUFHckIsTUFBTXZCLFFBQVE7UUFDakJPO1FBQ0FHO0lBQ0YsSUFBSWEsTUFBTXhCLFNBQVM7SUFDbkIsTUFBTXlELGVBQWUsTUFBT3RDLENBQUFBLFNBQVN1QyxlQUFlLElBQUksT0FBTyxLQUFLLElBQUl2QyxTQUFTdUMsZUFBZSxDQUFDcEIsU0FBU3JDLFFBQVE7SUFDbEgsTUFBTTBELGNBQWMsTUFBUXhDLENBQUFBLFNBQVNrQyxTQUFTLElBQUksT0FBTyxLQUFLLElBQUlsQyxTQUFTa0MsU0FBUyxDQUFDSSxhQUFZLElBQU0sTUFBUXRDLENBQUFBLFNBQVN5QyxRQUFRLElBQUksT0FBTyxLQUFLLElBQUl6QyxTQUFTeUMsUUFBUSxDQUFDSCxhQUFZLEtBQU87UUFDdkxqRCxHQUFHO1FBQ0hHLEdBQUc7SUFDTCxJQUFJO1FBQ0ZILEdBQUc7UUFDSEcsR0FBRztJQUNMO0lBQ0EsTUFBTWtELG9CQUFvQjdFLG9FQUFnQkEsQ0FBQ21DLFNBQVMyQyxxREFBcUQsR0FBRyxNQUFNM0MsU0FBUzJDLHFEQUFxRCxDQUFDO1FBQy9LTjtRQUNBQztRQUNBeEM7SUFDRixLQUFLdUM7SUFDTCxPQUFPO1FBQ0xPLEtBQUssQ0FBQ1osbUJBQW1CWSxHQUFHLEdBQUdGLGtCQUFrQkUsR0FBRyxHQUFHZixjQUFjZSxHQUFHLElBQUlKLFlBQVloRCxDQUFDO1FBQ3pGcUQsUUFBUSxDQUFDSCxrQkFBa0JHLE1BQU0sR0FBR2IsbUJBQW1CYSxNQUFNLEdBQUdoQixjQUFjZ0IsTUFBTSxJQUFJTCxZQUFZaEQsQ0FBQztRQUNyR3NELE1BQU0sQ0FBQ2QsbUJBQW1CYyxJQUFJLEdBQUdKLGtCQUFrQkksSUFBSSxHQUFHakIsY0FBY2lCLElBQUksSUFBSU4sWUFBWW5ELENBQUM7UUFDN0YwRCxPQUFPLENBQUNMLGtCQUFrQkssS0FBSyxHQUFHZixtQkFBbUJlLEtBQUssR0FBR2xCLGNBQWNrQixLQUFLLElBQUlQLFlBQVluRCxDQUFDO0lBQ25HO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTTJELFFBQVExQixDQUFBQSxVQUFZO1FBQ3hCVixNQUFNO1FBQ05VO1FBQ0EsTUFBTVQsSUFBR1EsS0FBSztZQUNaLE1BQU0sRUFDSmhDLENBQUMsRUFDREcsQ0FBQyxFQUNEYixTQUFTLEVBQ1QwQixLQUFLLEVBQ0xMLFFBQVEsRUFDUm1CLFFBQVEsRUFDUlgsY0FBYyxFQUNmLEdBQUdhO1lBQ0osNERBQTREO1lBQzVELE1BQU0sRUFDSlUsT0FBTyxFQUNQSCxVQUFVLENBQUMsRUFDWixHQUFHakUsNERBQVFBLENBQUMyRCxTQUFTRCxVQUFVLENBQUM7WUFDakMsSUFBSVUsV0FBVyxNQUFNO2dCQUNuQixPQUFPLENBQUM7WUFDVjtZQUNBLE1BQU1GLGdCQUFnQmpFLG9FQUFnQkEsQ0FBQ2dFO1lBQ3ZDLE1BQU1qQyxTQUFTO2dCQUNiTjtnQkFDQUc7WUFDRjtZQUNBLE1BQU15RCxPQUFPMUYsb0VBQWdCQSxDQUFDb0I7WUFDOUIsTUFBTWdDLFNBQVNuRCxpRUFBYUEsQ0FBQ3lGO1lBQzdCLE1BQU1DLGtCQUFrQixNQUFNbEQsU0FBU21ELGFBQWEsQ0FBQ3BCO1lBQ3JELE1BQU1xQixVQUFVSCxTQUFTO1lBQ3pCLE1BQU1JLFVBQVVELFVBQVUsUUFBUTtZQUNsQyxNQUFNRSxVQUFVRixVQUFVLFdBQVc7WUFDckMsTUFBTUcsYUFBYUgsVUFBVSxpQkFBaUI7WUFDOUMsTUFBTUksVUFBVW5ELE1BQU14QixTQUFTLENBQUM4QixPQUFPLEdBQUdOLE1BQU14QixTQUFTLENBQUNvRSxLQUFLLEdBQUd0RCxNQUFNLENBQUNzRCxLQUFLLEdBQUc1QyxNQUFNdkIsUUFBUSxDQUFDNkIsT0FBTztZQUN2RyxNQUFNOEMsWUFBWTlELE1BQU0sQ0FBQ3NELEtBQUssR0FBRzVDLE1BQU14QixTQUFTLENBQUNvRSxLQUFLO1lBQ3RELE1BQU1TLG9CQUFvQixNQUFPMUQsQ0FBQUEsU0FBU3VDLGVBQWUsSUFBSSxPQUFPLEtBQUssSUFBSXZDLFNBQVN1QyxlQUFlLENBQUNSLFFBQU87WUFDN0csSUFBSTRCLGFBQWFELG9CQUFvQkEsaUJBQWlCLENBQUNILFdBQVcsR0FBRztZQUVyRSwwREFBMEQ7WUFDMUQsSUFBSSxDQUFDSSxjQUFjLENBQUUsTUFBTzNELENBQUFBLFNBQVNrQyxTQUFTLElBQUksT0FBTyxLQUFLLElBQUlsQyxTQUFTa0MsU0FBUyxDQUFDd0Isa0JBQWlCLEdBQUs7Z0JBQ3pHQyxhQUFheEMsU0FBU3JDLFFBQVEsQ0FBQ3lFLFdBQVcsSUFBSWxELE1BQU12QixRQUFRLENBQUM2QixPQUFPO1lBQ3RFO1lBQ0EsTUFBTWlELG9CQUFvQkosVUFBVSxJQUFJQyxZQUFZO1lBRXBELDBFQUEwRTtZQUMxRSx1REFBdUQ7WUFDdkQsTUFBTUkseUJBQXlCRixhQUFhLElBQUlULGVBQWUsQ0FBQ3ZDLE9BQU8sR0FBRyxJQUFJO1lBQzlFLE1BQU1tRCxhQUFhaEcsdURBQUdBLENBQUMrRCxhQUFhLENBQUN3QixRQUFRLEVBQUVRO1lBQy9DLE1BQU1FLGFBQWFqRyx1REFBR0EsQ0FBQytELGFBQWEsQ0FBQ3lCLFFBQVEsRUFBRU87WUFFL0MsMEVBQTBFO1lBQzFFLGtEQUFrRDtZQUNsRCxNQUFNRyxRQUFRRjtZQUNkLE1BQU12RixNQUFNb0YsYUFBYVQsZUFBZSxDQUFDdkMsT0FBTyxHQUFHb0Q7WUFDbkQsTUFBTUUsU0FBU04sYUFBYSxJQUFJVCxlQUFlLENBQUN2QyxPQUFPLEdBQUcsSUFBSWlEO1lBQzlELE1BQU1NLFNBQVNuRyx5REFBS0EsQ0FBQ2lHLE9BQU9DLFFBQVExRjtZQUVwQyx5RUFBeUU7WUFDekUseUVBQXlFO1lBQ3pFLHlFQUF5RTtZQUN6RSxpREFBaUQ7WUFDakQsTUFBTTRGLGtCQUFrQixDQUFDM0QsZUFBZXdDLEtBQUssSUFBSXRGLGdFQUFZQSxDQUFDaUIsY0FBYyxRQUFRc0YsVUFBVUMsVUFBVTdELE1BQU14QixTQUFTLENBQUM4QixPQUFPLEdBQUcsSUFBS3NELENBQUFBLFNBQVNELFFBQVFGLGFBQWFDLFVBQVMsSUFBS2IsZUFBZSxDQUFDdkMsT0FBTyxHQUFHLElBQUk7WUFDak4sTUFBTXlELGtCQUFrQkQsa0JBQWtCRixTQUFTRCxRQUFRQyxTQUFTRCxRQUFRQyxTQUFTMUYsTUFBTTtZQUMzRixPQUFPO2dCQUNMLENBQUMwRSxLQUFLLEVBQUV0RCxNQUFNLENBQUNzRCxLQUFLLEdBQUdtQjtnQkFDdkJwRCxNQUFNO29CQUNKLENBQUNpQyxLQUFLLEVBQUVpQjtvQkFDUkcsY0FBY0osU0FBU0MsU0FBU0U7b0JBQ2hDLEdBQUlELG1CQUFtQjt3QkFDckJDO29CQUNGLENBQUM7Z0JBQ0g7Z0JBQ0FuRCxPQUFPa0Q7WUFDVDtRQUNGO0lBQ0Y7QUFFQSxTQUFTRyxpQkFBaUJDLFNBQVMsRUFBRUMsYUFBYSxFQUFFQyxpQkFBaUI7SUFDbkUsTUFBTUMscUNBQXFDSCxZQUFZO1dBQUlFLGtCQUFrQnZFLE1BQU0sQ0FBQ3ZCLENBQUFBLFlBQWFqQixnRUFBWUEsQ0FBQ2lCLGVBQWU0RjtXQUFlRSxrQkFBa0J2RSxNQUFNLENBQUN2QixDQUFBQSxZQUFhakIsZ0VBQVlBLENBQUNpQixlQUFlNEY7S0FBVyxHQUFHRSxrQkFBa0J2RSxNQUFNLENBQUN2QixDQUFBQSxZQUFhbEIsMkRBQU9BLENBQUNrQixlQUFlQTtJQUN6UixPQUFPK0YsbUNBQW1DeEUsTUFBTSxDQUFDdkIsQ0FBQUE7UUFDL0MsSUFBSTRGLFdBQVc7WUFDYixPQUFPN0csZ0VBQVlBLENBQUNpQixlQUFlNEYsYUFBY0MsQ0FBQUEsZ0JBQWdCdEcsaUZBQTZCQSxDQUFDUyxlQUFlQSxZQUFZLEtBQUk7UUFDaEk7UUFDQSxPQUFPO0lBQ1Q7QUFDRjtBQUNBOzs7OztDQUtDLEdBQ0QsTUFBTWdHLGdCQUFnQixTQUFVckQsT0FBTztJQUNyQyxJQUFJQSxZQUFZLEtBQUssR0FBRztRQUN0QkEsVUFBVSxDQUFDO0lBQ2I7SUFDQSxPQUFPO1FBQ0xWLE1BQU07UUFDTlU7UUFDQSxNQUFNVCxJQUFHUSxLQUFLO1lBQ1osSUFBSXVELHVCQUF1QkMsd0JBQXdCQztZQUNuRCxNQUFNLEVBQ0p6RSxLQUFLLEVBQ0xHLGNBQWMsRUFDZDdCLFNBQVMsRUFDVHFCLFFBQVEsRUFDUm1CLFFBQVEsRUFDVCxHQUFHRTtZQUNKLE1BQU0sRUFDSjBELFlBQVksS0FBSyxFQUNqQlIsU0FBUyxFQUNURSxvQkFBb0J6RywwREFBVSxFQUM5QndHLGdCQUFnQixJQUFJLEVBQ3BCLEdBQUdRLHVCQUNKLEdBQUdySCw0REFBUUEsQ0FBQzJELFNBQVNEO1lBQ3RCLE1BQU00RCxlQUFlVixjQUFjVyxhQUFhVCxzQkFBc0J6RywwREFBVUEsR0FBR3NHLGlCQUFpQkMsYUFBYSxNQUFNQyxlQUFlQyxxQkFBcUJBO1lBQzNKLE1BQU1VLFdBQVcsTUFBTS9ELGVBQWVDLE9BQU8yRDtZQUM3QyxNQUFNSSxlQUFlLENBQUMsQ0FBQ1Isd0JBQXdCcEUsZUFBZW1FLGFBQWEsS0FBSyxPQUFPLEtBQUssSUFBSUMsc0JBQXNCUyxLQUFLLEtBQUs7WUFDaEksTUFBTUMsbUJBQW1CTCxZQUFZLENBQUNHLGFBQWE7WUFDbkQsSUFBSUUsb0JBQW9CLE1BQU07Z0JBQzVCLE9BQU8sQ0FBQztZQUNWO1lBQ0EsTUFBTUMsaUJBQWlCdEgscUVBQWlCQSxDQUFDcUgsa0JBQWtCakYsT0FBTyxNQUFPTCxDQUFBQSxTQUFTSSxLQUFLLElBQUksT0FBTyxLQUFLLElBQUlKLFNBQVNJLEtBQUssQ0FBQ2UsU0FBU3JDLFFBQVE7WUFFM0ksbURBQW1EO1lBQ25ELElBQUlILGNBQWMyRyxrQkFBa0I7Z0JBQ2xDLE9BQU87b0JBQ0xyRSxPQUFPO3dCQUNMdEMsV0FBV3NHLFlBQVksQ0FBQyxFQUFFO29CQUM1QjtnQkFDRjtZQUNGO1lBQ0EsTUFBTU8sbUJBQW1CO2dCQUFDTCxRQUFRLENBQUMxSCwyREFBT0EsQ0FBQzZILGtCQUFrQjtnQkFBRUgsUUFBUSxDQUFDSSxjQUFjLENBQUMsRUFBRSxDQUFDO2dCQUFFSixRQUFRLENBQUNJLGNBQWMsQ0FBQyxFQUFFLENBQUM7YUFBQztZQUN4SCxNQUFNRSxlQUFlO21CQUFLLENBQUMsQ0FBQ1oseUJBQXlCckUsZUFBZW1FLGFBQWEsS0FBSyxPQUFPLEtBQUssSUFBSUUsdUJBQXVCYSxTQUFTLEtBQUssRUFBRTtnQkFBRztvQkFDOUkvRyxXQUFXMkc7b0JBQ1hJLFdBQVdGO2dCQUNiO2FBQUU7WUFDRixNQUFNRyxnQkFBZ0JWLFlBQVksQ0FBQ0csZUFBZSxFQUFFO1lBRXBELHNDQUFzQztZQUN0QyxJQUFJTyxlQUFlO2dCQUNqQixPQUFPO29CQUNMM0UsTUFBTTt3QkFDSnFFLE9BQU9ELGVBQWU7d0JBQ3RCTSxXQUFXRDtvQkFDYjtvQkFDQXhFLE9BQU87d0JBQ0x0QyxXQUFXZ0g7b0JBQ2I7Z0JBQ0Y7WUFDRjtZQUNBLE1BQU1DLDhCQUE4QkgsYUFBYUksR0FBRyxDQUFDQyxDQUFBQTtnQkFDbkQsTUFBTXZCLFlBQVk3RyxnRUFBWUEsQ0FBQ29JLEVBQUVuSCxTQUFTO2dCQUMxQyxPQUFPO29CQUFDbUgsRUFBRW5ILFNBQVM7b0JBQUU0RixhQUFhUSxZQUNsQyxvREFBb0Q7b0JBQ3BEZSxFQUFFSixTQUFTLENBQUNLLEtBQUssQ0FBQyxHQUFHLEdBQUdDLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxJQUFNRCxNQUFNQyxHQUFHLEtBQ3BELDJCQUEyQjtvQkFDM0JKLEVBQUVKLFNBQVMsQ0FBQyxFQUFFO29CQUFFSSxFQUFFSixTQUFTO2lCQUFDO1lBQzlCLEdBQUdTLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxDQUFDLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRTtZQUM3QixNQUFNQyw4QkFBOEJWLDRCQUE0QjFGLE1BQU0sQ0FBQzRGLENBQUFBLElBQUtBLENBQUMsQ0FBQyxFQUFFLENBQUNDLEtBQUssQ0FBQyxHQUN2RiwrREFBK0Q7Z0JBQy9ELFFBQVE7Z0JBQ1JySSxnRUFBWUEsQ0FBQ29JLENBQUMsQ0FBQyxFQUFFLElBQUksSUFBSSxHQUFHUyxLQUFLLENBQUNMLENBQUFBLElBQUtBLEtBQUs7WUFDNUMsTUFBTU0saUJBQWlCLENBQUMsQ0FBQzFCLHdCQUF3QndCLDJCQUEyQixDQUFDLEVBQUUsS0FBSyxPQUFPLEtBQUssSUFBSXhCLHFCQUFxQixDQUFDLEVBQUUsS0FBS2MsMkJBQTJCLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFDbEssSUFBSVksbUJBQW1CN0gsV0FBVztnQkFDaEMsT0FBTztvQkFDTHFDLE1BQU07d0JBQ0pxRSxPQUFPRCxlQUFlO3dCQUN0Qk0sV0FBV0Q7b0JBQ2I7b0JBQ0F4RSxPQUFPO3dCQUNMdEMsV0FBVzZIO29CQUNiO2dCQUNGO1lBQ0Y7WUFDQSxPQUFPLENBQUM7UUFDVjtJQUNGO0FBQ0Y7QUFFQTs7Ozs7Q0FLQyxHQUNELE1BQU1DLE9BQU8sU0FBVW5GLE9BQU87SUFDNUIsSUFBSUEsWUFBWSxLQUFLLEdBQUc7UUFDdEJBLFVBQVUsQ0FBQztJQUNiO0lBQ0EsT0FBTztRQUNMVixNQUFNO1FBQ05VO1FBQ0EsTUFBTVQsSUFBR1EsS0FBSztZQUNaLElBQUlxRix1QkFBdUJDO1lBQzNCLE1BQU0sRUFDSmhJLFNBQVMsRUFDVDZCLGNBQWMsRUFDZEgsS0FBSyxFQUNMYSxnQkFBZ0IsRUFDaEJsQixRQUFRLEVBQ1JtQixRQUFRLEVBQ1QsR0FBR0U7WUFDSixNQUFNLEVBQ0p1RixVQUFVQyxnQkFBZ0IsSUFBSSxFQUM5QjlCLFdBQVcrQixpQkFBaUIsSUFBSSxFQUNoQ0Msb0JBQW9CQywyQkFBMkIsRUFDL0NDLG1CQUFtQixTQUFTLEVBQzVCQyw0QkFBNEIsTUFBTSxFQUNsQ0MsZ0JBQWdCLElBQUksRUFDcEIsR0FBR25DLHVCQUNKLEdBQUdySCw0REFBUUEsQ0FBQzJELFNBQVNEO1lBRXRCLHNFQUFzRTtZQUN0RSwwRUFBMEU7WUFDMUUsUUFBUTtZQUNSLGlGQUFpRjtZQUNqRixJQUFJLENBQUNxRix3QkFBd0JsRyxlQUFld0MsS0FBSyxLQUFLLFFBQVEwRCxzQkFBc0J0QyxlQUFlLEVBQUU7Z0JBQ25HLE9BQU8sQ0FBQztZQUNWO1lBQ0EsTUFBTWxGLE9BQU96QiwyREFBT0EsQ0FBQ2tCO1lBQ3JCLE1BQU15SSxrQkFBa0IzSiwyREFBT0EsQ0FBQ3lELHNCQUFzQkE7WUFDdEQsTUFBTXRDLE1BQU0sTUFBT29CLENBQUFBLFNBQVNJLEtBQUssSUFBSSxPQUFPLEtBQUssSUFBSUosU0FBU0ksS0FBSyxDQUFDZSxTQUFTckMsUUFBUTtZQUNyRixNQUFNaUkscUJBQXFCQywrQkFBZ0NJLENBQUFBLG1CQUFtQixDQUFDRCxnQkFBZ0I7Z0JBQUNoSix3RUFBb0JBLENBQUMrQzthQUFrQixHQUFHOUMseUVBQXFCQSxDQUFDOEMsaUJBQWdCO1lBQ2hMLElBQUksQ0FBQzhGLCtCQUErQkUsOEJBQThCLFFBQVE7Z0JBQ3hFSCxtQkFBbUJNLElBQUksSUFBSWhKLDZFQUF5QkEsQ0FBQzZDLGtCQUFrQmlHLGVBQWVELDJCQUEyQnRJO1lBQ25IO1lBQ0EsTUFBTVosYUFBYTtnQkFBQ2tEO21CQUFxQjZGO2FBQW1CO1lBQzVELE1BQU01QixXQUFXLE1BQU0vRCxlQUFlQyxPQUFPMkQ7WUFDN0MsTUFBTVUsWUFBWSxFQUFFO1lBQ3BCLElBQUk0QixnQkFBZ0IsQ0FBQyxDQUFDWCx1QkFBdUJuRyxlQUFlaUcsSUFBSSxLQUFLLE9BQU8sS0FBSyxJQUFJRSxxQkFBcUJqQixTQUFTLEtBQUssRUFBRTtZQUMxSCxJQUFJbUIsZUFBZTtnQkFDakJuQixVQUFVMkIsSUFBSSxDQUFDbEMsUUFBUSxDQUFDakcsS0FBSztZQUMvQjtZQUNBLElBQUk0SCxnQkFBZ0I7Z0JBQ2xCLE1BQU14SSxRQUFRTCxxRUFBaUJBLENBQUNVLFdBQVcwQixPQUFPekI7Z0JBQ2xEOEcsVUFBVTJCLElBQUksQ0FBQ2xDLFFBQVEsQ0FBQzdHLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRTZHLFFBQVEsQ0FBQzdHLEtBQUssQ0FBQyxFQUFFLENBQUM7WUFDdkQ7WUFDQWdKLGdCQUFnQjttQkFBSUE7Z0JBQWU7b0JBQ2pDM0k7b0JBQ0ErRztnQkFDRjthQUFFO1lBRUYsb0NBQW9DO1lBQ3BDLElBQUksQ0FBQ0EsVUFBVWEsS0FBSyxDQUFDckgsQ0FBQUEsT0FBUUEsUUFBUSxJQUFJO2dCQUN2QyxJQUFJcUksdUJBQXVCQztnQkFDM0IsTUFBTUMsWUFBWSxDQUFDLENBQUMsQ0FBQ0Ysd0JBQXdCL0csZUFBZWlHLElBQUksS0FBSyxPQUFPLEtBQUssSUFBSWMsc0JBQXNCbEMsS0FBSyxLQUFLLEtBQUs7Z0JBQzFILE1BQU1NLGdCQUFnQjNILFVBQVUsQ0FBQ3lKLFVBQVU7Z0JBQzNDLElBQUk5QixlQUFlO29CQUNqQiwrQ0FBK0M7b0JBQy9DLE9BQU87d0JBQ0wzRSxNQUFNOzRCQUNKcUUsT0FBT29DOzRCQUNQL0IsV0FBVzRCO3dCQUNiO3dCQUNBckcsT0FBTzs0QkFDTHRDLFdBQVdnSDt3QkFDYjtvQkFDRjtnQkFDRjtnQkFFQSx3RUFBd0U7Z0JBQ3hFLHlFQUF5RTtnQkFDekUsSUFBSWEsaUJBQWlCLENBQUNnQix3QkFBd0JGLGNBQWNwSCxNQUFNLENBQUM0RixDQUFBQSxJQUFLQSxFQUFFSixTQUFTLENBQUMsRUFBRSxJQUFJLEdBQUdTLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFVixTQUFTLENBQUMsRUFBRSxHQUFHVyxFQUFFWCxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxLQUFLLE9BQU8sS0FBSyxJQUFJOEIsc0JBQXNCN0ksU0FBUztnQkFFbk0sc0JBQXNCO2dCQUN0QixJQUFJLENBQUM2SCxnQkFBZ0I7b0JBQ25CLE9BQVFTO3dCQUNOLEtBQUs7NEJBQ0g7Z0NBQ0UsSUFBSVM7Z0NBQ0osTUFBTS9JLFlBQVksQ0FBQytJLHdCQUF3QkosY0FBY3pCLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBSzt3Q0FBQ0EsRUFBRW5ILFNBQVM7d0NBQUVtSCxFQUFFSixTQUFTLENBQUN4RixNQUFNLENBQUNpRixDQUFBQSxXQUFZQSxXQUFXLEdBQUdhLE1BQU0sQ0FBQyxDQUFDQyxLQUFLZCxXQUFhYyxNQUFNZCxVQUFVO3FDQUFHLEVBQUVnQixJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsS0FBSyxPQUFPLEtBQUssSUFBSXFCLHFCQUFxQixDQUFDLEVBQUU7Z0NBQ3ZQLElBQUkvSSxXQUFXO29DQUNiNkgsaUJBQWlCN0g7Z0NBQ25CO2dDQUNBOzRCQUNGO3dCQUNGLEtBQUs7NEJBQ0g2SCxpQkFBaUJ0Rjs0QkFDakI7b0JBQ0o7Z0JBQ0Y7Z0JBQ0EsSUFBSXZDLGNBQWM2SCxnQkFBZ0I7b0JBQ2hDLE9BQU87d0JBQ0x2RixPQUFPOzRCQUNMdEMsV0FBVzZIO3dCQUNiO29CQUNGO2dCQUNGO1lBQ0Y7WUFDQSxPQUFPLENBQUM7UUFDVjtJQUNGO0FBQ0Y7QUFFQSxTQUFTbUIsZUFBZXhDLFFBQVEsRUFBRTlDLElBQUk7SUFDcEMsT0FBTztRQUNMTyxLQUFLdUMsU0FBU3ZDLEdBQUcsR0FBR1AsS0FBSzVDLE1BQU07UUFDL0JzRCxPQUFPb0MsU0FBU3BDLEtBQUssR0FBR1YsS0FBSy9DLEtBQUs7UUFDbEN1RCxRQUFRc0MsU0FBU3RDLE1BQU0sR0FBR1IsS0FBSzVDLE1BQU07UUFDckNxRCxNQUFNcUMsU0FBU3JDLElBQUksR0FBR1QsS0FBSy9DLEtBQUs7SUFDbEM7QUFDRjtBQUNBLFNBQVNzSSxzQkFBc0J6QyxRQUFRO0lBQ3JDLE9BQU83RyxxREFBS0EsQ0FBQ3VKLElBQUksQ0FBQzNJLENBQUFBLE9BQVFpRyxRQUFRLENBQUNqRyxLQUFLLElBQUk7QUFDOUM7QUFDQTs7OztDQUlDLEdBQ0QsTUFBTTRJLE9BQU8sU0FBVXhHLE9BQU87SUFDNUIsSUFBSUEsWUFBWSxLQUFLLEdBQUc7UUFDdEJBLFVBQVUsQ0FBQztJQUNiO0lBQ0EsT0FBTztRQUNMVixNQUFNO1FBQ05VO1FBQ0EsTUFBTVQsSUFBR1EsS0FBSztZQUNaLE1BQU0sRUFDSmhCLEtBQUssRUFDTixHQUFHZ0I7WUFDSixNQUFNLEVBQ0p2QixXQUFXLGlCQUFpQixFQUM1QixHQUFHa0YsdUJBQ0osR0FBR3JILDREQUFRQSxDQUFDMkQsU0FBU0Q7WUFDdEIsT0FBUXZCO2dCQUNOLEtBQUs7b0JBQ0g7d0JBQ0UsTUFBTXFGLFdBQVcsTUFBTS9ELGVBQWVDLE9BQU87NEJBQzNDLEdBQUcyRCxxQkFBcUI7NEJBQ3hCdEQsZ0JBQWdCO3dCQUNsQjt3QkFDQSxNQUFNcUcsVUFBVUosZUFBZXhDLFVBQVU5RSxNQUFNeEIsU0FBUzt3QkFDeEQsT0FBTzs0QkFDTG1DLE1BQU07Z0NBQ0pnSCx3QkFBd0JEO2dDQUN4QkUsaUJBQWlCTCxzQkFBc0JHOzRCQUN6Qzt3QkFDRjtvQkFDRjtnQkFDRixLQUFLO29CQUNIO3dCQUNFLE1BQU01QyxXQUFXLE1BQU0vRCxlQUFlQyxPQUFPOzRCQUMzQyxHQUFHMkQscUJBQXFCOzRCQUN4QnJELGFBQWE7d0JBQ2Y7d0JBQ0EsTUFBTW9HLFVBQVVKLGVBQWV4QyxVQUFVOUUsTUFBTXZCLFFBQVE7d0JBQ3ZELE9BQU87NEJBQ0xrQyxNQUFNO2dDQUNKa0gsZ0JBQWdCSDtnQ0FDaEJJLFNBQVNQLHNCQUFzQkc7NEJBQ2pDO3dCQUNGO29CQUNGO2dCQUNGO29CQUNFO3dCQUNFLE9BQU8sQ0FBQztvQkFDVjtZQUNKO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsU0FBU0ssZ0JBQWdCL0gsS0FBSztJQUM1QixNQUFNZ0ksT0FBT3ZLLHVEQUFHQSxJQUFJdUMsTUFBTXdGLEdBQUcsQ0FBQ3hELENBQUFBLE9BQVFBLEtBQUtTLElBQUk7SUFDL0MsTUFBTXdGLE9BQU94Syx1REFBR0EsSUFBSXVDLE1BQU13RixHQUFHLENBQUN4RCxDQUFBQSxPQUFRQSxLQUFLTyxHQUFHO0lBQzlDLE1BQU0yRixPQUFPaEssdURBQUdBLElBQUk4QixNQUFNd0YsR0FBRyxDQUFDeEQsQ0FBQUEsT0FBUUEsS0FBS1UsS0FBSztJQUNoRCxNQUFNeUYsT0FBT2pLLHVEQUFHQSxJQUFJOEIsTUFBTXdGLEdBQUcsQ0FBQ3hELENBQUFBLE9BQVFBLEtBQUtRLE1BQU07SUFDakQsT0FBTztRQUNMeEQsR0FBR2dKO1FBQ0g3SSxHQUFHOEk7UUFDSGhKLE9BQU9pSixPQUFPRjtRQUNkNUksUUFBUStJLE9BQU9GO0lBQ2pCO0FBQ0Y7QUFDQSxTQUFTRyxlQUFlcEksS0FBSztJQUMzQixNQUFNcUksY0FBY3JJLE1BQU0wRixLQUFLLEdBQUdJLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFNUcsQ0FBQyxHQUFHNkcsRUFBRTdHLENBQUM7SUFDMUQsTUFBTW1KLFNBQVMsRUFBRTtJQUNqQixJQUFJQyxXQUFXO0lBQ2YsSUFBSyxJQUFJbEksSUFBSSxHQUFHQSxJQUFJZ0ksWUFBWS9ILE1BQU0sRUFBRUQsSUFBSztRQUMzQyxNQUFNMkIsT0FBT3FHLFdBQVcsQ0FBQ2hJLEVBQUU7UUFDM0IsSUFBSSxDQUFDa0ksWUFBWXZHLEtBQUs3QyxDQUFDLEdBQUdvSixTQUFTcEosQ0FBQyxHQUFHb0osU0FBU25KLE1BQU0sR0FBRyxHQUFHO1lBQzFEa0osT0FBT3RCLElBQUksQ0FBQztnQkFBQ2hGO2FBQUs7UUFDcEIsT0FBTztZQUNMc0csTUFBTSxDQUFDQSxPQUFPaEksTUFBTSxHQUFHLEVBQUUsQ0FBQzBHLElBQUksQ0FBQ2hGO1FBQ2pDO1FBQ0F1RyxXQUFXdkc7SUFDYjtJQUNBLE9BQU9zRyxPQUFPOUMsR0FBRyxDQUFDeEQsQ0FBQUEsT0FBUXhFLG9FQUFnQkEsQ0FBQ3VLLGdCQUFnQi9GO0FBQzdEO0FBQ0E7Ozs7Q0FJQyxHQUNELE1BQU13RyxTQUFTLFNBQVV2SCxPQUFPO0lBQzlCLElBQUlBLFlBQVksS0FBSyxHQUFHO1FBQ3RCQSxVQUFVLENBQUM7SUFDYjtJQUNBLE9BQU87UUFDTFYsTUFBTTtRQUNOVTtRQUNBLE1BQU1ULElBQUdRLEtBQUs7WUFDWixNQUFNLEVBQ0oxQyxTQUFTLEVBQ1R3QyxRQUFRLEVBQ1JkLEtBQUssRUFDTEwsUUFBUSxFQUNSRixRQUFRLEVBQ1QsR0FBR3VCO1lBQ0osZ0VBQWdFO1lBQ2hFLHFFQUFxRTtZQUNyRSwyQ0FBMkM7WUFDM0MsTUFBTSxFQUNKTyxVQUFVLENBQUMsRUFDWHZDLENBQUMsRUFDREcsQ0FBQyxFQUNGLEdBQUc3Qiw0REFBUUEsQ0FBQzJELFNBQVNEO1lBQ3RCLE1BQU15SCxvQkFBb0JDLE1BQU1DLElBQUksQ0FBQyxNQUFRaEosQ0FBQUEsU0FBU2lKLGNBQWMsSUFBSSxPQUFPLEtBQUssSUFBSWpKLFNBQVNpSixjQUFjLENBQUM5SCxTQUFTdEMsU0FBUyxNQUFPLEVBQUU7WUFDM0ksTUFBTXFLLGNBQWNULGVBQWVLO1lBQ25DLE1BQU1LLFdBQVd0TCxvRUFBZ0JBLENBQUN1SyxnQkFBZ0JVO1lBQ2xELE1BQU1qSCxnQkFBZ0JqRSxvRUFBZ0JBLENBQUNnRTtZQUN2QyxTQUFTd0g7Z0JBQ1AsOENBQThDO2dCQUM5QyxJQUFJRixZQUFZdkksTUFBTSxLQUFLLEtBQUt1SSxXQUFXLENBQUMsRUFBRSxDQUFDcEcsSUFBSSxHQUFHb0csV0FBVyxDQUFDLEVBQUUsQ0FBQ25HLEtBQUssSUFBSTFELEtBQUssUUFBUUcsS0FBSyxNQUFNO29CQUNwRywwREFBMEQ7b0JBQzFELE9BQU8wSixZQUFZRyxJQUFJLENBQUNoSCxDQUFBQSxPQUFRaEQsSUFBSWdELEtBQUtTLElBQUksR0FBR2pCLGNBQWNpQixJQUFJLElBQUl6RCxJQUFJZ0QsS0FBS1UsS0FBSyxHQUFHbEIsY0FBY2tCLEtBQUssSUFBSXZELElBQUk2QyxLQUFLTyxHQUFHLEdBQUdmLGNBQWNlLEdBQUcsSUFBSXBELElBQUk2QyxLQUFLUSxNQUFNLEdBQUdoQixjQUFjZ0IsTUFBTSxLQUFLc0c7Z0JBQy9MO2dCQUVBLHVDQUF1QztnQkFDdkMsSUFBSUQsWUFBWXZJLE1BQU0sSUFBSSxHQUFHO29CQUMzQixJQUFJckQsK0RBQVdBLENBQUNxQixlQUFlLEtBQUs7d0JBQ2xDLE1BQU0ySyxZQUFZSixXQUFXLENBQUMsRUFBRTt3QkFDaEMsTUFBTUssV0FBV0wsV0FBVyxDQUFDQSxZQUFZdkksTUFBTSxHQUFHLEVBQUU7d0JBQ3BELE1BQU02SSxRQUFRL0wsMkRBQU9BLENBQUNrQixlQUFlO3dCQUNyQyxNQUFNaUUsTUFBTTBHLFVBQVUxRyxHQUFHO3dCQUN6QixNQUFNQyxTQUFTMEcsU0FBUzFHLE1BQU07d0JBQzlCLE1BQU1DLE9BQU8wRyxRQUFRRixVQUFVeEcsSUFBSSxHQUFHeUcsU0FBU3pHLElBQUk7d0JBQ25ELE1BQU1DLFFBQVF5RyxRQUFRRixVQUFVdkcsS0FBSyxHQUFHd0csU0FBU3hHLEtBQUs7d0JBQ3RELE1BQU16RCxRQUFReUQsUUFBUUQ7d0JBQ3RCLE1BQU1yRCxTQUFTb0QsU0FBU0Q7d0JBQ3hCLE9BQU87NEJBQ0xBOzRCQUNBQzs0QkFDQUM7NEJBQ0FDOzRCQUNBekQ7NEJBQ0FHOzRCQUNBSixHQUFHeUQ7NEJBQ0h0RCxHQUFHb0Q7d0JBQ0w7b0JBQ0Y7b0JBQ0EsTUFBTTZHLGFBQWFoTSwyREFBT0EsQ0FBQ2tCLGVBQWU7b0JBQzFDLE1BQU0rSyxXQUFXbkwsdURBQUdBLElBQUkySyxZQUFZckQsR0FBRyxDQUFDeEQsQ0FBQUEsT0FBUUEsS0FBS1UsS0FBSztvQkFDMUQsTUFBTTRHLFVBQVU3TCx1REFBR0EsSUFBSW9MLFlBQVlyRCxHQUFHLENBQUN4RCxDQUFBQSxPQUFRQSxLQUFLUyxJQUFJO29CQUN4RCxNQUFNOEcsZUFBZVYsWUFBWWhKLE1BQU0sQ0FBQ21DLENBQUFBLE9BQVFvSCxhQUFhcEgsS0FBS1MsSUFBSSxLQUFLNkcsVUFBVXRILEtBQUtVLEtBQUssS0FBSzJHO29CQUNwRyxNQUFNOUcsTUFBTWdILFlBQVksQ0FBQyxFQUFFLENBQUNoSCxHQUFHO29CQUMvQixNQUFNQyxTQUFTK0csWUFBWSxDQUFDQSxhQUFhakosTUFBTSxHQUFHLEVBQUUsQ0FBQ2tDLE1BQU07b0JBQzNELE1BQU1DLE9BQU82RztvQkFDYixNQUFNNUcsUUFBUTJHO29CQUNkLE1BQU1wSyxRQUFReUQsUUFBUUQ7b0JBQ3RCLE1BQU1yRCxTQUFTb0QsU0FBU0Q7b0JBQ3hCLE9BQU87d0JBQ0xBO3dCQUNBQzt3QkFDQUM7d0JBQ0FDO3dCQUNBekQ7d0JBQ0FHO3dCQUNBSixHQUFHeUQ7d0JBQ0h0RCxHQUFHb0Q7b0JBQ0w7Z0JBQ0Y7Z0JBQ0EsT0FBT3VHO1lBQ1Q7WUFDQSxNQUFNVSxhQUFhLE1BQU03SixTQUFTTSxlQUFlLENBQUM7Z0JBQ2hEekIsV0FBVztvQkFDVHVLO2dCQUNGO2dCQUNBdEssVUFBVXFDLFNBQVNyQyxRQUFRO2dCQUMzQmdCO1lBQ0Y7WUFDQSxJQUFJTyxNQUFNeEIsU0FBUyxDQUFDUSxDQUFDLEtBQUt3SyxXQUFXaEwsU0FBUyxDQUFDUSxDQUFDLElBQUlnQixNQUFNeEIsU0FBUyxDQUFDVyxDQUFDLEtBQUtxSyxXQUFXaEwsU0FBUyxDQUFDVyxDQUFDLElBQUlhLE1BQU14QixTQUFTLENBQUNTLEtBQUssS0FBS3VLLFdBQVdoTCxTQUFTLENBQUNTLEtBQUssSUFBSWUsTUFBTXhCLFNBQVMsQ0FBQ1ksTUFBTSxLQUFLb0ssV0FBV2hMLFNBQVMsQ0FBQ1ksTUFBTSxFQUFFO2dCQUNsTixPQUFPO29CQUNMd0IsT0FBTzt3QkFDTFosT0FBT3dKO29CQUNUO2dCQUNGO1lBQ0Y7WUFDQSxPQUFPLENBQUM7UUFDVjtJQUNGO0FBQ0Y7QUFFQSxzRUFBc0U7QUFDdEUsYUFBYTtBQUNiLGVBQWVDLHFCQUFxQnpJLEtBQUssRUFBRUMsT0FBTztJQUNoRCxNQUFNLEVBQ0ozQyxTQUFTLEVBQ1RxQixRQUFRLEVBQ1JtQixRQUFRLEVBQ1QsR0FBR0U7SUFDSixNQUFNekMsTUFBTSxNQUFPb0IsQ0FBQUEsU0FBU0ksS0FBSyxJQUFJLE9BQU8sS0FBSyxJQUFJSixTQUFTSSxLQUFLLENBQUNlLFNBQVNyQyxRQUFRO0lBQ3JGLE1BQU1JLE9BQU96QiwyREFBT0EsQ0FBQ2tCO0lBQ3JCLE1BQU00RixZQUFZN0csZ0VBQVlBLENBQUNpQjtJQUMvQixNQUFNUSxhQUFhN0IsK0RBQVdBLENBQUNxQixlQUFlO0lBQzlDLE1BQU1vTCxnQkFBZ0I7UUFBQztRQUFRO0tBQU0sQ0FBQ0MsUUFBUSxDQUFDOUssUUFBUSxDQUFDLElBQUk7SUFDNUQsTUFBTStLLGlCQUFpQnJMLE9BQU9PLGFBQWEsQ0FBQyxJQUFJO0lBQ2hELE1BQU0rSyxXQUFXdk0sNERBQVFBLENBQUMyRCxTQUFTRDtJQUVuQyx3Q0FBd0M7SUFDeEMsSUFBSSxFQUNGdUYsUUFBUSxFQUNSN0IsU0FBUyxFQUNUL0YsYUFBYSxFQUNkLEdBQUcsT0FBT2tMLGFBQWEsV0FBVztRQUNqQ3RELFVBQVVzRDtRQUNWbkYsV0FBVztRQUNYL0YsZUFBZTtJQUNqQixJQUFJO1FBQ0Y0SCxVQUFVO1FBQ1Y3QixXQUFXO1FBQ1gvRixlQUFlO1FBQ2YsR0FBR2tMLFFBQVE7SUFDYjtJQUNBLElBQUkzRixhQUFhLE9BQU92RixrQkFBa0IsVUFBVTtRQUNsRCtGLFlBQVlSLGNBQWMsUUFBUXZGLGdCQUFnQixDQUFDLElBQUlBO0lBQ3pEO0lBQ0EsT0FBT0csYUFBYTtRQUNsQkUsR0FBRzBGLFlBQVlrRjtRQUNmekssR0FBR29ILFdBQVdtRDtJQUNoQixJQUFJO1FBQ0YxSyxHQUFHdUgsV0FBV21EO1FBQ2R2SyxHQUFHdUYsWUFBWWtGO0lBQ2pCO0FBQ0Y7QUFFQTs7Ozs7O0NBTUMsR0FDRCxNQUFNL0YsU0FBUyxTQUFVNUMsT0FBTztJQUM5QixJQUFJQSxZQUFZLEtBQUssR0FBRztRQUN0QkEsVUFBVTtJQUNaO0lBQ0EsT0FBTztRQUNMVixNQUFNO1FBQ05VO1FBQ0EsTUFBTVQsSUFBR1EsS0FBSztZQUNaLElBQUk4SSx1QkFBdUJ6RDtZQUMzQixNQUFNLEVBQ0pySCxDQUFDLEVBQ0RHLENBQUMsRUFDRGIsU0FBUyxFQUNUNkIsY0FBYyxFQUNmLEdBQUdhO1lBQ0osTUFBTStJLGFBQWEsTUFBTU4scUJBQXFCekksT0FBT0M7WUFFckQsd0VBQXdFO1lBQ3hFLDREQUE0RDtZQUM1RCxJQUFJM0MsY0FBZSxFQUFDd0wsd0JBQXdCM0osZUFBZTBELE1BQU0sS0FBSyxPQUFPLEtBQUssSUFBSWlHLHNCQUFzQnhMLFNBQVMsS0FBSyxDQUFDK0gsd0JBQXdCbEcsZUFBZXdDLEtBQUssS0FBSyxRQUFRMEQsc0JBQXNCdEMsZUFBZSxFQUFFO2dCQUN6TixPQUFPLENBQUM7WUFDVjtZQUNBLE9BQU87Z0JBQ0wvRSxHQUFHQSxJQUFJK0ssV0FBVy9LLENBQUM7Z0JBQ25CRyxHQUFHQSxJQUFJNEssV0FBVzVLLENBQUM7Z0JBQ25Cd0IsTUFBTTtvQkFDSixHQUFHb0osVUFBVTtvQkFDYnpMO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTTBMLFFBQVEsU0FBVS9JLE9BQU87SUFDN0IsSUFBSUEsWUFBWSxLQUFLLEdBQUc7UUFDdEJBLFVBQVUsQ0FBQztJQUNiO0lBQ0EsT0FBTztRQUNMVixNQUFNO1FBQ05VO1FBQ0EsTUFBTVQsSUFBR1EsS0FBSztZQUNaLE1BQU0sRUFDSmhDLENBQUMsRUFDREcsQ0FBQyxFQUNEYixTQUFTLEVBQ1YsR0FBRzBDO1lBQ0osTUFBTSxFQUNKdUYsVUFBVUMsZ0JBQWdCLElBQUksRUFDOUI5QixXQUFXK0IsaUJBQWlCLEtBQUssRUFDakN3RCxVQUFVO2dCQUNSekosSUFBSW5DLENBQUFBO29CQUNGLElBQUksRUFDRlcsQ0FBQyxFQUNERyxDQUFDLEVBQ0YsR0FBR2Q7b0JBQ0osT0FBTzt3QkFDTFc7d0JBQ0FHO29CQUNGO2dCQUNGO1lBQ0YsQ0FBQyxFQUNELEdBQUd3Rix1QkFDSixHQUFHckgsNERBQVFBLENBQUMyRCxTQUFTRDtZQUN0QixNQUFNMUIsU0FBUztnQkFDYk47Z0JBQ0FHO1lBQ0Y7WUFDQSxNQUFNMkYsV0FBVyxNQUFNL0QsZUFBZUMsT0FBTzJEO1lBQzdDLE1BQU1ELFlBQVl6SCwrREFBV0EsQ0FBQ0csMkRBQU9BLENBQUNrQjtZQUN0QyxNQUFNaUksV0FBV3BJLG1FQUFlQSxDQUFDdUc7WUFDakMsSUFBSXdGLGdCQUFnQjVLLE1BQU0sQ0FBQ2lILFNBQVM7WUFDcEMsSUFBSTRELGlCQUFpQjdLLE1BQU0sQ0FBQ29GLFVBQVU7WUFDdEMsSUFBSThCLGVBQWU7Z0JBQ2pCLE1BQU00RCxVQUFVN0QsYUFBYSxNQUFNLFFBQVE7Z0JBQzNDLE1BQU04RCxVQUFVOUQsYUFBYSxNQUFNLFdBQVc7Z0JBQzlDLE1BQU05SSxNQUFNeU0sZ0JBQWdCcEYsUUFBUSxDQUFDc0YsUUFBUTtnQkFDN0MsTUFBTWxNLE1BQU1nTSxnQkFBZ0JwRixRQUFRLENBQUN1RixRQUFRO2dCQUM3Q0gsZ0JBQWdCeE0seURBQUtBLENBQUNELEtBQUt5TSxlQUFlaE07WUFDNUM7WUFDQSxJQUFJdUksZ0JBQWdCO2dCQUNsQixNQUFNMkQsVUFBVTFGLGNBQWMsTUFBTSxRQUFRO2dCQUM1QyxNQUFNMkYsVUFBVTNGLGNBQWMsTUFBTSxXQUFXO2dCQUMvQyxNQUFNakgsTUFBTTBNLGlCQUFpQnJGLFFBQVEsQ0FBQ3NGLFFBQVE7Z0JBQzlDLE1BQU1sTSxNQUFNaU0saUJBQWlCckYsUUFBUSxDQUFDdUYsUUFBUTtnQkFDOUNGLGlCQUFpQnpNLHlEQUFLQSxDQUFDRCxLQUFLME0sZ0JBQWdCak07WUFDOUM7WUFDQSxNQUFNb00sZ0JBQWdCTCxRQUFRekosRUFBRSxDQUFDO2dCQUMvQixHQUFHUSxLQUFLO2dCQUNSLENBQUN1RixTQUFTLEVBQUUyRDtnQkFDWixDQUFDeEYsVUFBVSxFQUFFeUY7WUFDZjtZQUNBLE9BQU87Z0JBQ0wsR0FBR0csYUFBYTtnQkFDaEIzSixNQUFNO29CQUNKM0IsR0FBR3NMLGNBQWN0TCxDQUFDLEdBQUdBO29CQUNyQkcsR0FBR21MLGNBQWNuTCxDQUFDLEdBQUdBO2dCQUN2QjtZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBQ0E7O0NBRUMsR0FDRCxNQUFNb0wsYUFBYSxTQUFVdEosT0FBTztJQUNsQyxJQUFJQSxZQUFZLEtBQUssR0FBRztRQUN0QkEsVUFBVSxDQUFDO0lBQ2I7SUFDQSxPQUFPO1FBQ0xBO1FBQ0FULElBQUdRLEtBQUs7WUFDTixNQUFNLEVBQ0poQyxDQUFDLEVBQ0RHLENBQUMsRUFDRGIsU0FBUyxFQUNUMEIsS0FBSyxFQUNMRyxjQUFjLEVBQ2YsR0FBR2E7WUFDSixNQUFNLEVBQ0o2QyxTQUFTLENBQUMsRUFDVjBDLFVBQVVDLGdCQUFnQixJQUFJLEVBQzlCOUIsV0FBVytCLGlCQUFpQixJQUFJLEVBQ2pDLEdBQUduSiw0REFBUUEsQ0FBQzJELFNBQVNEO1lBQ3RCLE1BQU0xQixTQUFTO2dCQUNiTjtnQkFDQUc7WUFDRjtZQUNBLE1BQU11RixZQUFZekgsK0RBQVdBLENBQUNxQjtZQUM5QixNQUFNaUksV0FBV3BJLG1FQUFlQSxDQUFDdUc7WUFDakMsSUFBSXdGLGdCQUFnQjVLLE1BQU0sQ0FBQ2lILFNBQVM7WUFDcEMsSUFBSTRELGlCQUFpQjdLLE1BQU0sQ0FBQ29GLFVBQVU7WUFDdEMsTUFBTThGLFlBQVlsTiw0REFBUUEsQ0FBQ3VHLFFBQVE3QztZQUNuQyxNQUFNeUosaUJBQWlCLE9BQU9ELGNBQWMsV0FBVztnQkFDckRqRSxVQUFVaUU7Z0JBQ1Y5RixXQUFXO1lBQ2IsSUFBSTtnQkFDRjZCLFVBQVU7Z0JBQ1Y3QixXQUFXO2dCQUNYLEdBQUc4RixTQUFTO1lBQ2Q7WUFDQSxJQUFJaEUsZUFBZTtnQkFDakIsTUFBTWtFLE1BQU1uRSxhQUFhLE1BQU0sV0FBVztnQkFDMUMsTUFBTW9FLFdBQVczSyxNQUFNeEIsU0FBUyxDQUFDK0gsU0FBUyxHQUFHdkcsTUFBTXZCLFFBQVEsQ0FBQ2lNLElBQUksR0FBR0QsZUFBZWxFLFFBQVE7Z0JBQzFGLE1BQU1xRSxXQUFXNUssTUFBTXhCLFNBQVMsQ0FBQytILFNBQVMsR0FBR3ZHLE1BQU14QixTQUFTLENBQUNrTSxJQUFJLEdBQUdELGVBQWVsRSxRQUFRO2dCQUMzRixJQUFJMkQsZ0JBQWdCUyxVQUFVO29CQUM1QlQsZ0JBQWdCUztnQkFDbEIsT0FBTyxJQUFJVCxnQkFBZ0JVLFVBQVU7b0JBQ25DVixnQkFBZ0JVO2dCQUNsQjtZQUNGO1lBQ0EsSUFBSW5FLGdCQUFnQjtnQkFDbEIsSUFBSXFELHVCQUF1QmU7Z0JBQzNCLE1BQU1ILE1BQU1uRSxhQUFhLE1BQU0sVUFBVTtnQkFDekMsTUFBTXVFLGVBQWU7b0JBQUM7b0JBQU87aUJBQU8sQ0FBQ25CLFFBQVEsQ0FBQ3ZNLDJEQUFPQSxDQUFDa0I7Z0JBQ3RELE1BQU1xTSxXQUFXM0ssTUFBTXhCLFNBQVMsQ0FBQ2tHLFVBQVUsR0FBRzFFLE1BQU12QixRQUFRLENBQUNpTSxJQUFJLEdBQUlJLENBQUFBLGVBQWUsQ0FBQyxDQUFDaEIsd0JBQXdCM0osZUFBZTBELE1BQU0sS0FBSyxPQUFPLEtBQUssSUFBSWlHLHFCQUFxQixDQUFDcEYsVUFBVSxLQUFLLElBQUksS0FBTW9HLENBQUFBLGVBQWUsSUFBSUwsZUFBZS9GLFNBQVM7Z0JBQ2xQLE1BQU1rRyxXQUFXNUssTUFBTXhCLFNBQVMsQ0FBQ2tHLFVBQVUsR0FBRzFFLE1BQU14QixTQUFTLENBQUNrTSxJQUFJLEdBQUlJLENBQUFBLGVBQWUsSUFBSSxDQUFDLENBQUNELHlCQUF5QjFLLGVBQWUwRCxNQUFNLEtBQUssT0FBTyxLQUFLLElBQUlnSCxzQkFBc0IsQ0FBQ25HLFVBQVUsS0FBSyxLQUFNb0csQ0FBQUEsZUFBZUwsZUFBZS9GLFNBQVMsR0FBRztnQkFDcFAsSUFBSXlGLGlCQUFpQlEsVUFBVTtvQkFDN0JSLGlCQUFpQlE7Z0JBQ25CLE9BQU8sSUFBSVIsaUJBQWlCUyxVQUFVO29CQUNwQ1QsaUJBQWlCUztnQkFDbkI7WUFDRjtZQUNBLE9BQU87Z0JBQ0wsQ0FBQ3JFLFNBQVMsRUFBRTJEO2dCQUNaLENBQUN4RixVQUFVLEVBQUV5RjtZQUNmO1FBQ0Y7SUFDRjtBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDRCxNQUFNWSxPQUFPLFNBQVU5SixPQUFPO0lBQzVCLElBQUlBLFlBQVksS0FBSyxHQUFHO1FBQ3RCQSxVQUFVLENBQUM7SUFDYjtJQUNBLE9BQU87UUFDTFYsTUFBTTtRQUNOVTtRQUNBLE1BQU1ULElBQUdRLEtBQUs7WUFDWixNQUFNLEVBQ0oxQyxTQUFTLEVBQ1QwQixLQUFLLEVBQ0xMLFFBQVEsRUFDUm1CLFFBQVEsRUFDVCxHQUFHRTtZQUNKLE1BQU0sRUFDSmdLLFFBQVEsS0FBTyxDQUFDLEVBQ2hCLEdBQUdyRyx1QkFDSixHQUFHckgsNERBQVFBLENBQUMyRCxTQUFTRDtZQUN0QixNQUFNOEQsV0FBVyxNQUFNL0QsZUFBZUMsT0FBTzJEO1lBQzdDLE1BQU05RixPQUFPekIsMkRBQU9BLENBQUNrQjtZQUNyQixNQUFNNEYsWUFBWTdHLGdFQUFZQSxDQUFDaUI7WUFDL0IsTUFBTXlFLFVBQVU5RiwrREFBV0EsQ0FBQ3FCLGVBQWU7WUFDM0MsTUFBTSxFQUNKVyxLQUFLLEVBQ0xHLE1BQU0sRUFDUCxHQUFHWSxNQUFNdkIsUUFBUTtZQUNsQixJQUFJd007WUFDSixJQUFJQztZQUNKLElBQUlyTSxTQUFTLFNBQVNBLFNBQVMsVUFBVTtnQkFDdkNvTSxhQUFhcE07Z0JBQ2JxTSxZQUFZaEgsY0FBZSxPQUFRdkUsQ0FBQUEsU0FBU0ksS0FBSyxJQUFJLE9BQU8sS0FBSyxJQUFJSixTQUFTSSxLQUFLLENBQUNlLFNBQVNyQyxRQUFRLEtBQU0sVUFBVSxLQUFJLElBQUssU0FBUztZQUN6SSxPQUFPO2dCQUNMeU0sWUFBWXJNO2dCQUNab00sYUFBYS9HLGNBQWMsUUFBUSxRQUFRO1lBQzdDO1lBQ0EsTUFBTWlILDBCQUEwQi9MLFNBQVMwRixRQUFRLENBQUNtRyxXQUFXO1lBQzdELE1BQU1HLHlCQUF5Qm5NLFFBQVE2RixRQUFRLENBQUNvRyxVQUFVO1lBQzFELE1BQU1HLFVBQVUsQ0FBQ3JLLE1BQU1iLGNBQWMsQ0FBQzZKLEtBQUs7WUFDM0MsSUFBSXNCLGtCQUFrQkg7WUFDdEIsSUFBSUksaUJBQWlCSDtZQUNyQixJQUFJckksU0FBUztnQkFDWCxNQUFNeUksdUJBQXVCdk0sUUFBUTZGLFNBQVNyQyxJQUFJLEdBQUdxQyxTQUFTcEMsS0FBSztnQkFDbkU2SSxpQkFBaUJySCxhQUFhbUgsVUFBVTVOLHVEQUFHQSxDQUFDMk4sd0JBQXdCSSx3QkFBd0JBO1lBQzlGLE9BQU87Z0JBQ0wsTUFBTUMsd0JBQXdCck0sU0FBUzBGLFNBQVN2QyxHQUFHLEdBQUd1QyxTQUFTdEMsTUFBTTtnQkFDckU4SSxrQkFBa0JwSCxhQUFhbUgsVUFBVTVOLHVEQUFHQSxDQUFDME4seUJBQXlCTSx5QkFBeUJBO1lBQ2pHO1lBQ0EsSUFBSUosV0FBVyxDQUFDbkgsV0FBVztnQkFDekIsTUFBTXdILE9BQU94Tix1REFBR0EsQ0FBQzRHLFNBQVNyQyxJQUFJLEVBQUU7Z0JBQ2hDLE1BQU1rSixPQUFPek4sdURBQUdBLENBQUM0RyxTQUFTcEMsS0FBSyxFQUFFO2dCQUNqQyxNQUFNa0osT0FBTzFOLHVEQUFHQSxDQUFDNEcsU0FBU3ZDLEdBQUcsRUFBRTtnQkFDL0IsTUFBTXNKLE9BQU8zTix1REFBR0EsQ0FBQzRHLFNBQVN0QyxNQUFNLEVBQUU7Z0JBQ2xDLElBQUlPLFNBQVM7b0JBQ1h3SSxpQkFBaUJ0TSxRQUFRLElBQUt5TSxDQUFBQSxTQUFTLEtBQUtDLFNBQVMsSUFBSUQsT0FBT0MsT0FBT3pOLHVEQUFHQSxDQUFDNEcsU0FBU3JDLElBQUksRUFBRXFDLFNBQVNwQyxLQUFLO2dCQUMxRyxPQUFPO29CQUNMNEksa0JBQWtCbE0sU0FBUyxJQUFLd00sQ0FBQUEsU0FBUyxLQUFLQyxTQUFTLElBQUlELE9BQU9DLE9BQU8zTix1REFBR0EsQ0FBQzRHLFNBQVN2QyxHQUFHLEVBQUV1QyxTQUFTdEMsTUFBTTtnQkFDNUc7WUFDRjtZQUNBLE1BQU13SSxNQUFNO2dCQUNWLEdBQUdoSyxLQUFLO2dCQUNSdUs7Z0JBQ0FEO1lBQ0Y7WUFDQSxNQUFNUSxpQkFBaUIsTUFBTW5NLFNBQVNtRCxhQUFhLENBQUNoQyxTQUFTckMsUUFBUTtZQUNyRSxJQUFJUSxVQUFVNk0sZUFBZTdNLEtBQUssSUFBSUcsV0FBVzBNLGVBQWUxTSxNQUFNLEVBQUU7Z0JBQ3RFLE9BQU87b0JBQ0x3QixPQUFPO3dCQUNMWixPQUFPO29CQUNUO2dCQUNGO1lBQ0Y7WUFDQSxPQUFPLENBQUM7UUFDVjtJQUNGO0FBQ0Y7QUFFc0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iZW5nZ3JpLmdpdGh1Yi5pby8uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvY29yZS9kaXN0L2Zsb2F0aW5nLXVpLmNvcmUubWpzPzU2YmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0U2lkZUF4aXMsIGdldEFsaWdubWVudEF4aXMsIGdldEF4aXNMZW5ndGgsIGdldFNpZGUsIGdldEFsaWdubWVudCwgZXZhbHVhdGUsIGdldFBhZGRpbmdPYmplY3QsIHJlY3RUb0NsaWVudFJlY3QsIG1pbiwgY2xhbXAsIHBsYWNlbWVudHMsIGdldEFsaWdubWVudFNpZGVzLCBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQsIGdldEV4cGFuZGVkUGxhY2VtZW50cywgZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cywgc2lkZXMsIG1heCwgZ2V0T3Bwb3NpdGVBeGlzIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcbmV4cG9ydCB7IHJlY3RUb0NsaWVudFJlY3QgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMnO1xuXG5mdW5jdGlvbiBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChfcmVmLCBwbGFjZW1lbnQsIHJ0bCkge1xuICBsZXQge1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZ1xuICB9ID0gX3JlZjtcbiAgY29uc3Qgc2lkZUF4aXMgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnRBeGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbkxlbmd0aCA9IGdldEF4aXNMZW5ndGgoYWxpZ25tZW50QXhpcyk7XG4gIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBzaWRlQXhpcyA9PT0gJ3knO1xuICBjb25zdCBjb21tb25YID0gcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gZmxvYXRpbmcud2lkdGggLyAyO1xuICBjb25zdCBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGZsb2F0aW5nLmhlaWdodCAvIDI7XG4gIGNvbnN0IGNvbW1vbkFsaWduID0gcmVmZXJlbmNlW2FsaWduTGVuZ3RoXSAvIDIgLSBmbG9hdGluZ1thbGlnbkxlbmd0aF0gLyAyO1xuICBsZXQgY29vcmRzO1xuICBzd2l0Y2ggKHNpZGUpIHtcbiAgICBjYXNlICd0b3AnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGZsb2F0aW5nLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBmbG9hdGluZy53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54LFxuICAgICAgICB5OiByZWZlcmVuY2UueVxuICAgICAgfTtcbiAgfVxuICBzd2l0Y2ggKGdldEFsaWdubWVudChwbGFjZW1lbnQpKSB7XG4gICAgY2FzZSAnc3RhcnQnOlxuICAgICAgY29vcmRzW2FsaWdubWVudEF4aXNdIC09IGNvbW1vbkFsaWduICogKHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2VuZCc6XG4gICAgICBjb29yZHNbYWxpZ25tZW50QXhpc10gKz0gY29tbW9uQWxpZ24gKiAocnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDEpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGNvb3Jkcztcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgdGhhdCB3aWxsIHBsYWNlIHRoZSBmbG9hdGluZyBlbGVtZW50XG4gKiBuZXh0IHRvIGEgcmVmZXJlbmNlIGVsZW1lbnQgd2hlbiBpdCBpcyBnaXZlbiBhIGNlcnRhaW4gcG9zaXRpb25pbmcgc3RyYXRlZ3kuXG4gKlxuICogVGhpcyBleHBvcnQgZG9lcyBub3QgaGF2ZSBhbnkgYHBsYXRmb3JtYCBpbnRlcmZhY2UgbG9naWMuIFlvdSB3aWxsIG5lZWQgdG9cbiAqIHdyaXRlIG9uZSBmb3IgdGhlIHBsYXRmb3JtIHlvdSBhcmUgdXNpbmcgRmxvYXRpbmcgVUkgd2l0aC5cbiAqL1xuY29uc3QgY29tcHV0ZVBvc2l0aW9uID0gYXN5bmMgKHJlZmVyZW5jZSwgZmxvYXRpbmcsIGNvbmZpZykgPT4ge1xuICBjb25zdCB7XG4gICAgcGxhY2VtZW50ID0gJ2JvdHRvbScsXG4gICAgc3RyYXRlZ3kgPSAnYWJzb2x1dGUnLFxuICAgIG1pZGRsZXdhcmUgPSBbXSxcbiAgICBwbGF0Zm9ybVxuICB9ID0gY29uZmlnO1xuICBjb25zdCB2YWxpZE1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlLmZpbHRlcihCb29sZWFuKTtcbiAgY29uc3QgcnRsID0gYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChmbG9hdGluZykpO1xuICBsZXQgcmVjdHMgPSBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZyxcbiAgICBzdHJhdGVneVxuICB9KTtcbiAgbGV0IHtcbiAgICB4LFxuICAgIHlcbiAgfSA9IGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KHJlY3RzLCBwbGFjZW1lbnQsIHJ0bCk7XG4gIGxldCBzdGF0ZWZ1bFBsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgbGV0IG1pZGRsZXdhcmVEYXRhID0ge307XG4gIGxldCByZXNldENvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWxpZE1pZGRsZXdhcmUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgZm5cbiAgICB9ID0gdmFsaWRNaWRkbGV3YXJlW2ldO1xuICAgIGNvbnN0IHtcbiAgICAgIHg6IG5leHRYLFxuICAgICAgeTogbmV4dFksXG4gICAgICBkYXRhLFxuICAgICAgcmVzZXRcbiAgICB9ID0gYXdhaXQgZm4oe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBpbml0aWFsUGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQ6IHN0YXRlZnVsUGxhY2VtZW50LFxuICAgICAgc3RyYXRlZ3ksXG4gICAgICBtaWRkbGV3YXJlRGF0YSxcbiAgICAgIHJlY3RzLFxuICAgICAgcGxhdGZvcm0sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgIGZsb2F0aW5nXG4gICAgICB9XG4gICAgfSk7XG4gICAgeCA9IG5leHRYICE9IG51bGwgPyBuZXh0WCA6IHg7XG4gICAgeSA9IG5leHRZICE9IG51bGwgPyBuZXh0WSA6IHk7XG4gICAgbWlkZGxld2FyZURhdGEgPSB7XG4gICAgICAuLi5taWRkbGV3YXJlRGF0YSxcbiAgICAgIFtuYW1lXToge1xuICAgICAgICAuLi5taWRkbGV3YXJlRGF0YVtuYW1lXSxcbiAgICAgICAgLi4uZGF0YVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHJlc2V0ICYmIHJlc2V0Q291bnQgPD0gNTApIHtcbiAgICAgIHJlc2V0Q291bnQrKztcbiAgICAgIGlmICh0eXBlb2YgcmVzZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChyZXNldC5wbGFjZW1lbnQpIHtcbiAgICAgICAgICBzdGF0ZWZ1bFBsYWNlbWVudCA9IHJlc2V0LnBsYWNlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzZXQucmVjdHMpIHtcbiAgICAgICAgICByZWN0cyA9IHJlc2V0LnJlY3RzID09PSB0cnVlID8gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICAgICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgICAgIGZsb2F0aW5nLFxuICAgICAgICAgICAgc3RyYXRlZ3lcbiAgICAgICAgICB9KSA6IHJlc2V0LnJlY3RzO1xuICAgICAgICB9XG4gICAgICAgICh7XG4gICAgICAgICAgeCxcbiAgICAgICAgICB5XG4gICAgICAgIH0gPSBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChyZWN0cywgc3RhdGVmdWxQbGFjZW1lbnQsIHJ0bCkpO1xuICAgICAgfVxuICAgICAgaSA9IC0xO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHBsYWNlbWVudDogc3RhdGVmdWxQbGFjZW1lbnQsXG4gICAgc3RyYXRlZ3ksXG4gICAgbWlkZGxld2FyZURhdGFcbiAgfTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgd2l0aCBhbiBvYmplY3Qgb2Ygb3ZlcmZsb3cgc2lkZSBvZmZzZXRzIHRoYXQgZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZVxuICogZWxlbWVudCBpcyBvdmVyZmxvd2luZyBhIGdpdmVuIGNsaXBwaW5nIGJvdW5kYXJ5IG9uIGVhY2ggc2lkZS5cbiAqIC0gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgYm91bmRhcnkgYnkgdGhhdCBudW1iZXIgb2YgcGl4ZWxzXG4gKiAtIG5lZ2F0aXZlID0gaG93IG1hbnkgcGl4ZWxzIGxlZnQgYmVmb3JlIGl0IHdpbGwgb3ZlcmZsb3dcbiAqIC0gMCA9IGxpZXMgZmx1c2ggd2l0aCB0aGUgYm91bmRhcnlcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9kZXRlY3RPdmVyZmxvd1xuICovXG5hc3luYyBmdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xuICB2YXIgX2F3YWl0JHBsYXRmb3JtJGlzRWxlO1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHksXG4gICAgcGxhdGZvcm0sXG4gICAgcmVjdHMsXG4gICAgZWxlbWVudHMsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IHN0YXRlO1xuICBjb25zdCB7XG4gICAgYm91bmRhcnkgPSAnY2xpcHBpbmdBbmNlc3RvcnMnLFxuICAgIHJvb3RCb3VuZGFyeSA9ICd2aWV3cG9ydCcsXG4gICAgZWxlbWVudENvbnRleHQgPSAnZmxvYXRpbmcnLFxuICAgIGFsdEJvdW5kYXJ5ID0gZmFsc2UsXG4gICAgcGFkZGluZyA9IDBcbiAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFBhZGRpbmdPYmplY3QocGFkZGluZyk7XG4gIGNvbnN0IGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gJ2Zsb2F0aW5nJyA/ICdyZWZlcmVuY2UnIDogJ2Zsb2F0aW5nJztcbiAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgY29uc3QgY2xpcHBpbmdDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChhd2FpdCBwbGF0Zm9ybS5nZXRDbGlwcGluZ1JlY3Qoe1xuICAgIGVsZW1lbnQ6ICgoX2F3YWl0JHBsYXRmb3JtJGlzRWxlID0gYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KGVsZW1lbnQpKSkgIT0gbnVsbCA/IF9hd2FpdCRwbGF0Zm9ybSRpc0VsZSA6IHRydWUpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgKGF3YWl0IChwbGF0Zm9ybS5nZXREb2N1bWVudEVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldERvY3VtZW50RWxlbWVudChlbGVtZW50cy5mbG9hdGluZykpKSxcbiAgICBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnksXG4gICAgc3RyYXRlZ3lcbiAgfSkpO1xuICBjb25zdCByZWN0ID0gZWxlbWVudENvbnRleHQgPT09ICdmbG9hdGluZycgPyB7XG4gICAgLi4ucmVjdHMuZmxvYXRpbmcsXG4gICAgeCxcbiAgICB5XG4gIH0gOiByZWN0cy5yZWZlcmVuY2U7XG4gIGNvbnN0IG9mZnNldFBhcmVudCA9IGF3YWl0IChwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldE9mZnNldFBhcmVudChlbGVtZW50cy5mbG9hdGluZykpO1xuICBjb25zdCBvZmZzZXRTY2FsZSA9IChhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQob2Zmc2V0UGFyZW50KSkpID8gKGF3YWl0IChwbGF0Zm9ybS5nZXRTY2FsZSA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0U2NhbGUob2Zmc2V0UGFyZW50KSkpIHx8IHtcbiAgICB4OiAxLFxuICAgIHk6IDFcbiAgfSA6IHtcbiAgICB4OiAxLFxuICAgIHk6IDFcbiAgfTtcbiAgY29uc3QgZWxlbWVudENsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0ID8gYXdhaXQgcGxhdGZvcm0uY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3Qoe1xuICAgIHJlY3QsXG4gICAgb2Zmc2V0UGFyZW50LFxuICAgIHN0cmF0ZWd5XG4gIH0pIDogcmVjdCk7XG4gIHJldHVybiB7XG4gICAgdG9wOiAoY2xpcHBpbmdDbGllbnRSZWN0LnRvcCAtIGVsZW1lbnRDbGllbnRSZWN0LnRvcCArIHBhZGRpbmdPYmplY3QudG9wKSAvIG9mZnNldFNjYWxlLnksXG4gICAgYm90dG9tOiAoZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC0gY2xpcHBpbmdDbGllbnRSZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tKSAvIG9mZnNldFNjYWxlLnksXG4gICAgbGVmdDogKGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCkgLyBvZmZzZXRTY2FsZS54LFxuICAgIHJpZ2h0OiAoZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0KSAvIG9mZnNldFNjYWxlLnhcbiAgfTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc28gdGhhdCBpdFxuICogYXBwZWFycyBjZW50ZXJlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3cgPSBvcHRpb25zID0+ICh7XG4gIG5hbWU6ICdhcnJvdycsXG4gIG9wdGlvbnMsXG4gIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBwbGFjZW1lbnQsXG4gICAgICByZWN0cyxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgZWxlbWVudHMsXG4gICAgICBtaWRkbGV3YXJlRGF0YVxuICAgIH0gPSBzdGF0ZTtcbiAgICAvLyBTaW5jZSBgZWxlbWVudGAgaXMgcmVxdWlyZWQsIHdlIGRvbid0IFBhcnRpYWw8PiB0aGUgdHlwZS5cbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50LFxuICAgICAgcGFkZGluZyA9IDBcbiAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpIHx8IHt9O1xuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFBhZGRpbmdPYmplY3QocGFkZGluZyk7XG4gICAgY29uc3QgY29vcmRzID0ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICAgIGNvbnN0IGF4aXMgPSBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCk7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0QXhpc0xlbmd0aChheGlzKTtcbiAgICBjb25zdCBhcnJvd0RpbWVuc2lvbnMgPSBhd2FpdCBwbGF0Zm9ybS5nZXREaW1lbnNpb25zKGVsZW1lbnQpO1xuICAgIGNvbnN0IGlzWUF4aXMgPSBheGlzID09PSAneSc7XG4gICAgY29uc3QgbWluUHJvcCA9IGlzWUF4aXMgPyAndG9wJyA6ICdsZWZ0JztcbiAgICBjb25zdCBtYXhQcm9wID0gaXNZQXhpcyA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgICBjb25zdCBjbGllbnRQcm9wID0gaXNZQXhpcyA/ICdjbGllbnRIZWlnaHQnIDogJ2NsaWVudFdpZHRoJztcbiAgICBjb25zdCBlbmREaWZmID0gcmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gKyByZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBjb29yZHNbYXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5ndGhdO1xuICAgIGNvbnN0IHN0YXJ0RGlmZiA9IGNvb3Jkc1theGlzXSAtIHJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgICBjb25zdCBhcnJvd09mZnNldFBhcmVudCA9IGF3YWl0IChwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldE9mZnNldFBhcmVudChlbGVtZW50KSk7XG4gICAgbGV0IGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGFycm93T2Zmc2V0UGFyZW50W2NsaWVudFByb3BdIDogMDtcblxuICAgIC8vIERPTSBwbGF0Zm9ybSBjYW4gcmV0dXJuIGB3aW5kb3dgIGFzIHRoZSBgb2Zmc2V0UGFyZW50YC5cbiAgICBpZiAoIWNsaWVudFNpemUgfHwgIShhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQoYXJyb3dPZmZzZXRQYXJlbnQpKSkpIHtcbiAgICAgIGNsaWVudFNpemUgPSBlbGVtZW50cy5mbG9hdGluZ1tjbGllbnRQcm9wXSB8fCByZWN0cy5mbG9hdGluZ1tsZW5ndGhdO1xuICAgIH1cbiAgICBjb25zdCBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjtcblxuICAgIC8vIElmIHRoZSBwYWRkaW5nIGlzIGxhcmdlIGVub3VnaCB0aGF0IGl0IGNhdXNlcyB0aGUgYXJyb3cgdG8gbm8gbG9uZ2VyIGJlXG4gICAgLy8gY2VudGVyZWQsIG1vZGlmeSB0aGUgcGFkZGluZyBzbyB0aGF0IGl0IGlzIGNlbnRlcmVkLlxuICAgIGNvbnN0IGxhcmdlc3RQb3NzaWJsZVBhZGRpbmcgPSBjbGllbnRTaXplIC8gMiAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC8gMiAtIDE7XG4gICAgY29uc3QgbWluUGFkZGluZyA9IG1pbihwYWRkaW5nT2JqZWN0W21pblByb3BdLCBsYXJnZXN0UG9zc2libGVQYWRkaW5nKTtcbiAgICBjb25zdCBtYXhQYWRkaW5nID0gbWluKHBhZGRpbmdPYmplY3RbbWF4UHJvcF0sIGxhcmdlc3RQb3NzaWJsZVBhZGRpbmcpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBmbG9hdGluZyBlbGVtZW50IGlmIHRoZSBjZW50ZXJcbiAgICAvLyBwb2ludCBpcyBvdXRzaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50J3MgYm91bmRzLlxuICAgIGNvbnN0IG1pbiQxID0gbWluUGFkZGluZztcbiAgICBjb25zdCBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLSBtYXhQYWRkaW5nO1xuICAgIGNvbnN0IGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gICAgY29uc3Qgb2Zmc2V0ID0gY2xhbXAobWluJDEsIGNlbnRlciwgbWF4KTtcblxuICAgIC8vIElmIHRoZSByZWZlcmVuY2UgaXMgc21hbGwgZW5vdWdoIHRoYXQgdGhlIGFycm93J3MgcGFkZGluZyBjYXVzZXMgaXQgdG9cbiAgICAvLyB0byBwb2ludCB0byBub3RoaW5nIGZvciBhbiBhbGlnbmVkIHBsYWNlbWVudCwgYWRqdXN0IHRoZSBvZmZzZXQgb2YgdGhlXG4gICAgLy8gZmxvYXRpbmcgZWxlbWVudCBpdHNlbGYuIFRvIGVuc3VyZSBgc2hpZnQoKWAgY29udGludWVzIHRvIHRha2UgYWN0aW9uLFxuICAgIC8vIGEgc2luZ2xlIHJlc2V0IGlzIHBlcmZvcm1lZCB3aGVuIHRoaXMgaXMgdHJ1ZS5cbiAgICBjb25zdCBzaG91bGRBZGRPZmZzZXQgPSAhbWlkZGxld2FyZURhdGEuYXJyb3cgJiYgZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgIT0gbnVsbCAmJiBjZW50ZXIgIT0gb2Zmc2V0ICYmIHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdIC8gMiAtIChjZW50ZXIgPCBtaW4kMSA/IG1pblBhZGRpbmcgOiBtYXhQYWRkaW5nKSAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC8gMiA8IDA7XG4gICAgY29uc3QgYWxpZ25tZW50T2Zmc2V0ID0gc2hvdWxkQWRkT2Zmc2V0ID8gY2VudGVyIDwgbWluJDEgPyBjZW50ZXIgLSBtaW4kMSA6IGNlbnRlciAtIG1heCA6IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtheGlzXTogY29vcmRzW2F4aXNdICsgYWxpZ25tZW50T2Zmc2V0LFxuICAgICAgZGF0YToge1xuICAgICAgICBbYXhpc106IG9mZnNldCxcbiAgICAgICAgY2VudGVyT2Zmc2V0OiBjZW50ZXIgLSBvZmZzZXQgLSBhbGlnbm1lbnRPZmZzZXQsXG4gICAgICAgIC4uLihzaG91bGRBZGRPZmZzZXQgJiYge1xuICAgICAgICAgIGFsaWdubWVudE9mZnNldFxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIHJlc2V0OiBzaG91bGRBZGRPZmZzZXRcbiAgICB9O1xuICB9XG59KTtcblxuZnVuY3Rpb24gZ2V0UGxhY2VtZW50TGlzdChhbGlnbm1lbnQsIGF1dG9BbGlnbm1lbnQsIGFsbG93ZWRQbGFjZW1lbnRzKSB7XG4gIGNvbnN0IGFsbG93ZWRQbGFjZW1lbnRzU29ydGVkQnlBbGlnbm1lbnQgPSBhbGlnbm1lbnQgPyBbLi4uYWxsb3dlZFBsYWNlbWVudHMuZmlsdGVyKHBsYWNlbWVudCA9PiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSA9PT0gYWxpZ25tZW50KSwgLi4uYWxsb3dlZFBsYWNlbWVudHMuZmlsdGVyKHBsYWNlbWVudCA9PiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSAhPT0gYWxpZ25tZW50KV0gOiBhbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldFNpZGUocGxhY2VtZW50KSA9PT0gcGxhY2VtZW50KTtcbiAgcmV0dXJuIGFsbG93ZWRQbGFjZW1lbnRzU29ydGVkQnlBbGlnbm1lbnQuZmlsdGVyKHBsYWNlbWVudCA9PiB7XG4gICAgaWYgKGFsaWdubWVudCkge1xuICAgICAgcmV0dXJuIGdldEFsaWdubWVudChwbGFjZW1lbnQpID09PSBhbGlnbm1lbnQgfHwgKGF1dG9BbGlnbm1lbnQgPyBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpICE9PSBwbGFjZW1lbnQgOiBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn1cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGNob29zaW5nIHRoZSBwbGFjZW1lbnRcbiAqIHRoYXQgaGFzIHRoZSBtb3N0IHNwYWNlIGF2YWlsYWJsZSBhdXRvbWF0aWNhbGx5LCB3aXRob3V0IG5lZWRpbmcgdG8gc3BlY2lmeSBhXG4gKiBwcmVmZXJyZWQgcGxhY2VtZW50LiBBbHRlcm5hdGl2ZSB0byBgZmxpcGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1BsYWNlbWVudFxuICovXG5jb25zdCBhdXRvUGxhY2VtZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdhdXRvUGxhY2VtZW50JyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGF1dG9QLCBfbWlkZGxld2FyZURhdGEkYXV0b1AyLCBfcGxhY2VtZW50c1RoYXRGaXRPbkU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlY3RzLFxuICAgICAgICBtaWRkbGV3YXJlRGF0YSxcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY3Jvc3NBeGlzID0gZmFsc2UsXG4gICAgICAgIGFsaWdubWVudCxcbiAgICAgICAgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLFxuICAgICAgICBhdXRvQWxpZ25tZW50ID0gdHJ1ZSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3QgcGxhY2VtZW50cyQxID0gYWxpZ25tZW50ICE9PSB1bmRlZmluZWQgfHwgYWxsb3dlZFBsYWNlbWVudHMgPT09IHBsYWNlbWVudHMgPyBnZXRQbGFjZW1lbnRMaXN0KGFsaWdubWVudCB8fCBudWxsLCBhdXRvQWxpZ25tZW50LCBhbGxvd2VkUGxhY2VtZW50cykgOiBhbGxvd2VkUGxhY2VtZW50cztcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSAoKF9taWRkbGV3YXJlRGF0YSRhdXRvUCA9IG1pZGRsZXdhcmVEYXRhLmF1dG9QbGFjZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkYXV0b1AuaW5kZXgpIHx8IDA7XG4gICAgICBjb25zdCBjdXJyZW50UGxhY2VtZW50ID0gcGxhY2VtZW50cyQxW2N1cnJlbnRJbmRleF07XG4gICAgICBpZiAoY3VycmVudFBsYWNlbWVudCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFsaWdubWVudFNpZGVzID0gZ2V0QWxpZ25tZW50U2lkZXMoY3VycmVudFBsYWNlbWVudCwgcmVjdHMsIGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKSk7XG5cbiAgICAgIC8vIE1ha2UgYGNvbXB1dGVDb29yZHNgIHN0YXJ0IGZyb20gdGhlIHJpZ2h0IHBsYWNlLlxuICAgICAgaWYgKHBsYWNlbWVudCAhPT0gY3VycmVudFBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudHMkMVswXVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRPdmVyZmxvd3MgPSBbb3ZlcmZsb3dbZ2V0U2lkZShjdXJyZW50UGxhY2VtZW50KV0sIG92ZXJmbG93W2FsaWdubWVudFNpZGVzWzBdXSwgb3ZlcmZsb3dbYWxpZ25tZW50U2lkZXNbMV1dXTtcbiAgICAgIGNvbnN0IGFsbE92ZXJmbG93cyA9IFsuLi4oKChfbWlkZGxld2FyZURhdGEkYXV0b1AyID0gbWlkZGxld2FyZURhdGEuYXV0b1BsYWNlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRhdXRvUDIub3ZlcmZsb3dzKSB8fCBbXSksIHtcbiAgICAgICAgcGxhY2VtZW50OiBjdXJyZW50UGxhY2VtZW50LFxuICAgICAgICBvdmVyZmxvd3M6IGN1cnJlbnRPdmVyZmxvd3NcbiAgICAgIH1dO1xuICAgICAgY29uc3QgbmV4dFBsYWNlbWVudCA9IHBsYWNlbWVudHMkMVtjdXJyZW50SW5kZXggKyAxXTtcblxuICAgICAgLy8gVGhlcmUgYXJlIG1vcmUgcGxhY2VtZW50cyB0byBjaGVjay5cbiAgICAgIGlmIChuZXh0UGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaW5kZXg6IGN1cnJlbnRJbmRleCArIDEsXG4gICAgICAgICAgICBvdmVyZmxvd3M6IGFsbE92ZXJmbG93c1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogbmV4dFBsYWNlbWVudFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBsYWNlbWVudHNTb3J0ZWRCeU1vc3RTcGFjZSA9IGFsbE92ZXJmbG93cy5tYXAoZCA9PiB7XG4gICAgICAgIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChkLnBsYWNlbWVudCk7XG4gICAgICAgIHJldHVybiBbZC5wbGFjZW1lbnQsIGFsaWdubWVudCAmJiBjcm9zc0F4aXMgP1xuICAgICAgICAvLyBDaGVjayBhbG9uZyB0aGUgbWFpbkF4aXMgYW5kIG1haW4gY3Jvc3NBeGlzIHNpZGUuXG4gICAgICAgIGQub3ZlcmZsb3dzLnNsaWNlKDAsIDIpLnJlZHVjZSgoYWNjLCB2KSA9PiBhY2MgKyB2LCAwKSA6XG4gICAgICAgIC8vIENoZWNrIG9ubHkgdGhlIG1haW5BeGlzLlxuICAgICAgICBkLm92ZXJmbG93c1swXSwgZC5vdmVyZmxvd3NdO1xuICAgICAgfSkuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0pO1xuICAgICAgY29uc3QgcGxhY2VtZW50c1RoYXRGaXRPbkVhY2hTaWRlID0gcGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlLmZpbHRlcihkID0+IGRbMl0uc2xpY2UoMCxcbiAgICAgIC8vIEFsaWduZWQgcGxhY2VtZW50cyBzaG91bGQgbm90IGNoZWNrIHRoZWlyIG9wcG9zaXRlIGNyb3NzQXhpc1xuICAgICAgLy8gc2lkZS5cbiAgICAgIGdldEFsaWdubWVudChkWzBdKSA/IDIgOiAzKS5ldmVyeSh2ID0+IHYgPD0gMCkpO1xuICAgICAgY29uc3QgcmVzZXRQbGFjZW1lbnQgPSAoKF9wbGFjZW1lbnRzVGhhdEZpdE9uRSA9IHBsYWNlbWVudHNUaGF0Rml0T25FYWNoU2lkZVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wbGFjZW1lbnRzVGhhdEZpdE9uRVswXSkgfHwgcGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlWzBdWzBdO1xuICAgICAgaWYgKHJlc2V0UGxhY2VtZW50ICE9PSBwbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4ICsgMSxcbiAgICAgICAgICAgIG92ZXJmbG93czogYWxsT3ZlcmZsb3dzXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiByZXNldFBsYWNlbWVudFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBmbGlwcGluZyB0aGUgYHBsYWNlbWVudGBcbiAqIGluIG9yZGVyIHRvIGtlZXAgaXQgaW4gdmlldyB3aGVuIHRoZSBwcmVmZXJyZWQgcGxhY2VtZW50KHMpIHdpbGwgb3ZlcmZsb3cgdGhlXG4gKiBjbGlwcGluZyBib3VuZGFyeS4gQWx0ZXJuYXRpdmUgdG8gYGF1dG9QbGFjZW1lbnRgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2ZsaXBcbiAqL1xuY29uc3QgZmxpcCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnZmxpcCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRhcnJvdywgX21pZGRsZXdhcmVEYXRhJGZsaXA7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBpbml0aWFsUGxhY2VtZW50LFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gdHJ1ZSxcbiAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzOiBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICAgIGZhbGxiYWNrU3RyYXRlZ3kgPSAnYmVzdEZpdCcsXG4gICAgICAgIGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gPSAnbm9uZScsXG4gICAgICAgIGZsaXBBbGlnbm1lbnQgPSB0cnVlLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG5cbiAgICAgIC8vIElmIGEgcmVzZXQgYnkgdGhlIGFycm93IHdhcyBjYXVzZWQgZHVlIHRvIGFuIGFsaWdubWVudCBvZmZzZXQgYmVpbmdcbiAgICAgIC8vIGFkZGVkLCB3ZSBzaG91bGQgc2tpcCBhbnkgbG9naWMgbm93IHNpbmNlIGBmbGlwKClgIGhhcyBhbHJlYWR5IGRvbmUgaXRzXG4gICAgICAvLyB3b3JrLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yNTQ5I2lzc3VlY29tbWVudC0xNzE5NjAxNjQzXG4gICAgICBpZiAoKF9taWRkbGV3YXJlRGF0YSRhcnJvdyA9IG1pZGRsZXdhcmVEYXRhLmFycm93KSAhPSBudWxsICYmIF9taWRkbGV3YXJlRGF0YSRhcnJvdy5hbGlnbm1lbnRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGlzQmFzZVBsYWNlbWVudCA9IGdldFNpZGUoaW5pdGlhbFBsYWNlbWVudCkgPT09IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSk7XG4gICAgICBjb25zdCBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcEFsaWdubWVudCA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChpbml0aWFsUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZFBsYWNlbWVudHMoaW5pdGlhbFBsYWNlbWVudCkpO1xuICAgICAgaWYgKCFzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgJiYgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGZhbGxiYWNrUGxhY2VtZW50cy5wdXNoKC4uLmdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMoaW5pdGlhbFBsYWNlbWVudCwgZmxpcEFsaWdubWVudCwgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiwgcnRsKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwbGFjZW1lbnRzID0gW2luaXRpYWxQbGFjZW1lbnQsIC4uLmZhbGxiYWNrUGxhY2VtZW50c107XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dzID0gW107XG4gICAgICBsZXQgb3ZlcmZsb3dzRGF0YSA9ICgoX21pZGRsZXdhcmVEYXRhJGZsaXAgPSBtaWRkbGV3YXJlRGF0YS5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGZsaXAub3ZlcmZsb3dzKSB8fCBbXTtcbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W3NpZGVdKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCBzaWRlcyA9IGdldEFsaWdubWVudFNpZGVzKHBsYWNlbWVudCwgcmVjdHMsIHJ0bCk7XG4gICAgICAgIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W3NpZGVzWzBdXSwgb3ZlcmZsb3dbc2lkZXNbMV1dKTtcbiAgICAgIH1cbiAgICAgIG92ZXJmbG93c0RhdGEgPSBbLi4ub3ZlcmZsb3dzRGF0YSwge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG92ZXJmbG93c1xuICAgICAgfV07XG5cbiAgICAgIC8vIE9uZSBvciBtb3JlIHNpZGVzIGlzIG92ZXJmbG93aW5nLlxuICAgICAgaWYgKCFvdmVyZmxvd3MuZXZlcnkoc2lkZSA9PiBzaWRlIDw9IDApKSB7XG4gICAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkZmxpcDIsIF9vdmVyZmxvd3NEYXRhJGZpbHRlcjtcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gKCgoX21pZGRsZXdhcmVEYXRhJGZsaXAyID0gbWlkZGxld2FyZURhdGEuZmxpcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRmbGlwMi5pbmRleCkgfHwgMCkgKyAxO1xuICAgICAgICBjb25zdCBuZXh0UGxhY2VtZW50ID0gcGxhY2VtZW50c1tuZXh0SW5kZXhdO1xuICAgICAgICBpZiAobmV4dFBsYWNlbWVudCkge1xuICAgICAgICAgIC8vIFRyeSBuZXh0IHBsYWNlbWVudCBhbmQgcmUtcnVuIHRoZSBsaWZlY3ljbGUuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgaW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgICAgICAgb3ZlcmZsb3dzOiBvdmVyZmxvd3NEYXRhXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpcnN0LCBmaW5kIHRoZSBjYW5kaWRhdGVzIHRoYXQgZml0IG9uIHRoZSBtYWluQXhpcyBzaWRlIG9mIG92ZXJmbG93LFxuICAgICAgICAvLyB0aGVuIGZpbmQgdGhlIHBsYWNlbWVudCB0aGF0IGZpdHMgdGhlIGJlc3Qgb24gdGhlIG1haW4gY3Jvc3NBeGlzIHNpZGUuXG4gICAgICAgIGxldCByZXNldFBsYWNlbWVudCA9IChfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIgPSBvdmVyZmxvd3NEYXRhLmZpbHRlcihkID0+IGQub3ZlcmZsb3dzWzBdIDw9IDApLnNvcnQoKGEsIGIpID0+IGEub3ZlcmZsb3dzWzFdIC0gYi5vdmVyZmxvd3NbMV0pWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX292ZXJmbG93c0RhdGEkZmlsdGVyLnBsYWNlbWVudDtcblxuICAgICAgICAvLyBPdGhlcndpc2UgZmFsbGJhY2suXG4gICAgICAgIGlmICghcmVzZXRQbGFjZW1lbnQpIHtcbiAgICAgICAgICBzd2l0Y2ggKGZhbGxiYWNrU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Jlc3RGaXQnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIF9vdmVyZmxvd3NEYXRhJG1hcCRzbztcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZW1lbnQgPSAoX292ZXJmbG93c0RhdGEkbWFwJHNvID0gb3ZlcmZsb3dzRGF0YS5tYXAoZCA9PiBbZC5wbGFjZW1lbnQsIGQub3ZlcmZsb3dzLmZpbHRlcihvdmVyZmxvdyA9PiBvdmVyZmxvdyA+IDApLnJlZHVjZSgoYWNjLCBvdmVyZmxvdykgPT4gYWNjICsgb3ZlcmZsb3csIDApXSkuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0pWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX292ZXJmbG93c0RhdGEkbWFwJHNvWzBdO1xuICAgICAgICAgICAgICAgIGlmIChwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHJlc2V0UGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnaW5pdGlhbFBsYWNlbWVudCc6XG4gICAgICAgICAgICAgIHJlc2V0UGxhY2VtZW50ID0gaW5pdGlhbFBsYWNlbWVudDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwbGFjZW1lbnQgIT09IHJlc2V0UGxhY2VtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICAgIHBsYWNlbWVudDogcmVzZXRQbGFjZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3QpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aFxuICB9O1xufVxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XG4gIHJldHVybiBzaWRlcy5zb21lKHNpZGUgPT4gb3ZlcmZsb3dbc2lkZV0gPj0gMCk7XG59XG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gaGlkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbiBhcHBsaWNhYmxlIHNpdHVhdGlvbnMsIHN1Y2ggYXNcbiAqIHdoZW4gaXQgaXMgbm90IGluIHRoZSBzYW1lIGNsaXBwaW5nIGNvbnRleHQgYXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2hpZGVcbiAqL1xuY29uc3QgaGlkZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnaGlkZScsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWN0c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdHJhdGVneSA9ICdyZWZlcmVuY2VIaWRkZW4nLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBzd2l0Y2ggKHN0cmF0ZWd5KSB7XG4gICAgICAgIGNhc2UgJ3JlZmVyZW5jZUhpZGRlbic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICAgICAgICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3RzLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSGlkZGVuT2Zmc2V0czogb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VIaWRkZW46IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvZmZzZXRzKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZXNjYXBlZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICAgICAgICAgIGFsdEJvdW5kYXJ5OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdHMuZmxvYXRpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGVzY2FwZWRPZmZzZXRzOiBvZmZzZXRzLFxuICAgICAgICAgICAgICAgIGVzY2FwZWQ6IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvZmZzZXRzKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nUmVjdChyZWN0cykge1xuICBjb25zdCBtaW5YID0gbWluKC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QubGVmdCkpO1xuICBjb25zdCBtaW5ZID0gbWluKC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QudG9wKSk7XG4gIGNvbnN0IG1heFggPSBtYXgoLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC5yaWdodCkpO1xuICBjb25zdCBtYXhZID0gbWF4KC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QuYm90dG9tKSk7XG4gIHJldHVybiB7XG4gICAgeDogbWluWCxcbiAgICB5OiBtaW5ZLFxuICAgIHdpZHRoOiBtYXhYIC0gbWluWCxcbiAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZXG4gIH07XG59XG5mdW5jdGlvbiBnZXRSZWN0c0J5TGluZShyZWN0cykge1xuICBjb25zdCBzb3J0ZWRSZWN0cyA9IHJlY3RzLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gYS55IC0gYi55KTtcbiAgY29uc3QgZ3JvdXBzID0gW107XG4gIGxldCBwcmV2UmVjdCA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc29ydGVkUmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCByZWN0ID0gc29ydGVkUmVjdHNbaV07XG4gICAgaWYgKCFwcmV2UmVjdCB8fCByZWN0LnkgLSBwcmV2UmVjdC55ID4gcHJldlJlY3QuaGVpZ2h0IC8gMikge1xuICAgICAgZ3JvdXBzLnB1c2goW3JlY3RdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXBzW2dyb3Vwcy5sZW5ndGggLSAxXS5wdXNoKHJlY3QpO1xuICAgIH1cbiAgICBwcmV2UmVjdCA9IHJlY3Q7XG4gIH1cbiAgcmV0dXJuIGdyb3Vwcy5tYXAocmVjdCA9PiByZWN0VG9DbGllbnRSZWN0KGdldEJvdW5kaW5nUmVjdChyZWN0KSkpO1xufVxuLyoqXG4gKiBQcm92aWRlcyBpbXByb3ZlZCBwb3NpdGlvbmluZyBmb3IgaW5saW5lIHJlZmVyZW5jZSBlbGVtZW50cyB0aGF0IGNhbiBzcGFuXG4gKiBvdmVyIG11bHRpcGxlIGxpbmVzLCBzdWNoIGFzIGh5cGVybGlua3Mgb3IgcmFuZ2Ugc2VsZWN0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9pbmxpbmVcbiAqL1xuY29uc3QgaW5saW5lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdpbmxpbmUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBzdHJhdGVneVxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgLy8gQSBNb3VzZUV2ZW50J3MgY2xpZW50e1gsWX0gY29vcmRzIGNhbiBiZSB1cCB0byAyIHBpeGVscyBvZmYgYVxuICAgICAgLy8gQ2xpZW50UmVjdCdzIGJvdW5kcywgZGVzcGl0ZSB0aGUgZXZlbnQgbGlzdGVuZXIgYmVpbmcgdHJpZ2dlcmVkLiBBXG4gICAgICAvLyBwYWRkaW5nIG9mIDIgc2VlbXMgdG8gaGFuZGxlIHRoaXMgaXNzdWUuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhZGRpbmcgPSAyLFxuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3QgbmF0aXZlQ2xpZW50UmVjdHMgPSBBcnJheS5mcm9tKChhd2FpdCAocGxhdGZvcm0uZ2V0Q2xpZW50UmVjdHMgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldENsaWVudFJlY3RzKGVsZW1lbnRzLnJlZmVyZW5jZSkpKSB8fCBbXSk7XG4gICAgICBjb25zdCBjbGllbnRSZWN0cyA9IGdldFJlY3RzQnlMaW5lKG5hdGl2ZUNsaWVudFJlY3RzKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrID0gcmVjdFRvQ2xpZW50UmVjdChnZXRCb3VuZGluZ1JlY3QobmF0aXZlQ2xpZW50UmVjdHMpKTtcbiAgICAgIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpO1xuICAgICAgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgdHdvIHJlY3RzIGFuZCB0aGV5IGFyZSBkaXNqb2luZWQuXG4gICAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPT09IDIgJiYgY2xpZW50UmVjdHNbMF0ubGVmdCA+IGNsaWVudFJlY3RzWzFdLnJpZ2h0ICYmIHggIT0gbnVsbCAmJiB5ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCByZWN0IGluIHdoaWNoIHRoZSBwb2ludCBpcyBmdWxseSBpbnNpZGUuXG4gICAgICAgICAgcmV0dXJuIGNsaWVudFJlY3RzLmZpbmQocmVjdCA9PiB4ID4gcmVjdC5sZWZ0IC0gcGFkZGluZ09iamVjdC5sZWZ0ICYmIHggPCByZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodCAmJiB5ID4gcmVjdC50b3AgLSBwYWRkaW5nT2JqZWN0LnRvcCAmJiB5IDwgcmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSkgfHwgZmFsbGJhY2s7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGVyZSBhcmUgMiBvciBtb3JlIGNvbm5lY3RlZCByZWN0cy5cbiAgICAgICAgaWYgKGNsaWVudFJlY3RzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgaWYgKGdldFNpZGVBeGlzKHBsYWNlbWVudCkgPT09ICd5Jykge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RSZWN0ID0gY2xpZW50UmVjdHNbMF07XG4gICAgICAgICAgICBjb25zdCBsYXN0UmVjdCA9IGNsaWVudFJlY3RzW2NsaWVudFJlY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY29uc3QgaXNUb3AgPSBnZXRTaWRlKHBsYWNlbWVudCkgPT09ICd0b3AnO1xuICAgICAgICAgICAgY29uc3QgdG9wID0gZmlyc3RSZWN0LnRvcDtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IGxhc3RSZWN0LmJvdHRvbTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBpc1RvcCA/IGZpcnN0UmVjdC5sZWZ0IDogbGFzdFJlY3QubGVmdDtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gaXNUb3AgPyBmaXJzdFJlY3QucmlnaHQgOiBsYXN0UmVjdC5yaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGlzTGVmdFNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCkgPT09ICdsZWZ0JztcbiAgICAgICAgICBjb25zdCBtYXhSaWdodCA9IG1heCguLi5jbGllbnRSZWN0cy5tYXAocmVjdCA9PiByZWN0LnJpZ2h0KSk7XG4gICAgICAgICAgY29uc3QgbWluTGVmdCA9IG1pbiguLi5jbGllbnRSZWN0cy5tYXAocmVjdCA9PiByZWN0LmxlZnQpKTtcbiAgICAgICAgICBjb25zdCBtZWFzdXJlUmVjdHMgPSBjbGllbnRSZWN0cy5maWx0ZXIocmVjdCA9PiBpc0xlZnRTaWRlID8gcmVjdC5sZWZ0ID09PSBtaW5MZWZ0IDogcmVjdC5yaWdodCA9PT0gbWF4UmlnaHQpO1xuICAgICAgICAgIGNvbnN0IHRvcCA9IG1lYXN1cmVSZWN0c1swXS50b3A7XG4gICAgICAgICAgY29uc3QgYm90dG9tID0gbWVhc3VyZVJlY3RzW21lYXN1cmVSZWN0cy5sZW5ndGggLSAxXS5ib3R0b207XG4gICAgICAgICAgY29uc3QgbGVmdCA9IG1pbkxlZnQ7XG4gICAgICAgICAgY29uc3QgcmlnaHQgPSBtYXhSaWdodDtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgeDogbGVmdCxcbiAgICAgICAgICAgIHk6IHRvcFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzZXRSZWN0cyA9IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICAgICAgICB9LFxuICAgICAgICBmbG9hdGluZzogZWxlbWVudHMuZmxvYXRpbmcsXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9KTtcbiAgICAgIGlmIChyZWN0cy5yZWZlcmVuY2UueCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2UueCB8fCByZWN0cy5yZWZlcmVuY2UueSAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2UueSB8fCByZWN0cy5yZWZlcmVuY2Uud2lkdGggIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLndpZHRoIHx8IHJlY3RzLnJlZmVyZW5jZS5oZWlnaHQgIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLmhlaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICByZWN0czogcmVzZXRSZWN0c1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBGb3IgdHlwZSBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSwgdGhlIGBPZmZzZXRPcHRpb25zYCB0eXBlIHdhcyBhbHNvXG4vLyBEZXJpdmFibGUuXG5hc3luYyBmdW5jdGlvbiBjb252ZXJ0VmFsdWVUb0Nvb3JkcyhzdGF0ZSwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgcGxhY2VtZW50LFxuICAgIHBsYXRmb3JtLFxuICAgIGVsZW1lbnRzXG4gIH0gPSBzdGF0ZTtcbiAgY29uc3QgcnRsID0gYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpO1xuICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCkgPT09ICd5JztcbiAgY29uc3QgbWFpbkF4aXNNdWx0aSA9IFsnbGVmdCcsICd0b3AnXS5pbmNsdWRlcyhzaWRlKSA/IC0xIDogMTtcbiAgY29uc3QgY3Jvc3NBeGlzTXVsdGkgPSBydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMTtcbiAgY29uc3QgcmF3VmFsdWUgPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge1xuICAgIG1haW5BeGlzLFxuICAgIGNyb3NzQXhpcyxcbiAgICBhbGlnbm1lbnRBeGlzXG4gIH0gPSB0eXBlb2YgcmF3VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgIG1haW5BeGlzOiByYXdWYWx1ZSxcbiAgICBjcm9zc0F4aXM6IDAsXG4gICAgYWxpZ25tZW50QXhpczogbnVsbFxuICB9IDoge1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGNyb3NzQXhpczogMCxcbiAgICBhbGlnbm1lbnRBeGlzOiBudWxsLFxuICAgIC4uLnJhd1ZhbHVlXG4gIH07XG4gIGlmIChhbGlnbm1lbnQgJiYgdHlwZW9mIGFsaWdubWVudEF4aXMgPT09ICdudW1iZXInKSB7XG4gICAgY3Jvc3NBeGlzID0gYWxpZ25tZW50ID09PSAnZW5kJyA/IGFsaWdubWVudEF4aXMgKiAtMSA6IGFsaWdubWVudEF4aXM7XG4gIH1cbiAgcmV0dXJuIGlzVmVydGljYWwgPyB7XG4gICAgeDogY3Jvc3NBeGlzICogY3Jvc3NBeGlzTXVsdGksXG4gICAgeTogbWFpbkF4aXMgKiBtYWluQXhpc011bHRpXG4gIH0gOiB7XG4gICAgeDogbWFpbkF4aXMgKiBtYWluQXhpc011bHRpLFxuICAgIHk6IGNyb3NzQXhpcyAqIGNyb3NzQXhpc011bHRpXG4gIH07XG59XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHBsYWNlbWVudCBieSB0cmFuc2xhdGluZyB0aGUgZmxvYXRpbmcgZWxlbWVudCBhbG9uZyB0aGVcbiAqIHNwZWNpZmllZCBheGVzLlxuICogQSBudW1iZXIgKHNob3J0aGFuZCBmb3IgYG1haW5BeGlzYCBvciBkaXN0YW5jZSksIG9yIGFuIGF4ZXMgY29uZmlndXJhdGlvblxuICogb2JqZWN0IG1heSBiZSBwYXNzZWQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvb2Zmc2V0XG4gKi9cbmNvbnN0IG9mZnNldCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0gMDtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkb2Zmc2UsIF9taWRkbGV3YXJlRGF0YSRhcnJvdztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBtaWRkbGV3YXJlRGF0YVxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3QgZGlmZkNvb3JkcyA9IGF3YWl0IGNvbnZlcnRWYWx1ZVRvQ29vcmRzKHN0YXRlLCBvcHRpb25zKTtcblxuICAgICAgLy8gSWYgdGhlIHBsYWNlbWVudCBpcyB0aGUgc2FtZSBhbmQgdGhlIGFycm93IGNhdXNlZCBhbiBhbGlnbm1lbnQgb2Zmc2V0XG4gICAgICAvLyB0aGVuIHdlIGRvbid0IG5lZWQgdG8gY2hhbmdlIHRoZSBwb3NpdGlvbmluZyBjb29yZGluYXRlcy5cbiAgICAgIGlmIChwbGFjZW1lbnQgPT09ICgoX21pZGRsZXdhcmVEYXRhJG9mZnNlID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlLnBsYWNlbWVudCkgJiYgKF9taWRkbGV3YXJlRGF0YSRhcnJvdyA9IG1pZGRsZXdhcmVEYXRhLmFycm93KSAhPSBudWxsICYmIF9taWRkbGV3YXJlRGF0YSRhcnJvdy5hbGlnbm1lbnRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCArIGRpZmZDb29yZHMueCxcbiAgICAgICAgeTogeSArIGRpZmZDb29yZHMueSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIC4uLmRpZmZDb29yZHMsXG4gICAgICAgICAgcGxhY2VtZW50XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgc2hpZnRpbmcgaXQgaW4gb3JkZXIgdG9cbiAqIGtlZXAgaXQgaW4gdmlldyB3aGVuIGl0IHdpbGwgb3ZlcmZsb3cgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NoaWZ0XG4gKi9cbmNvbnN0IHNoaWZ0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdzaGlmdCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwbGFjZW1lbnRcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gZmFsc2UsXG4gICAgICAgIGxpbWl0ZXIgPSB7XG4gICAgICAgICAgZm46IF9yZWYgPT4ge1xuICAgICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICB5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3QgY29vcmRzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IGNyb3NzQXhpcyA9IGdldFNpZGVBeGlzKGdldFNpZGUocGxhY2VtZW50KSk7XG4gICAgICBjb25zdCBtYWluQXhpcyA9IGdldE9wcG9zaXRlQXhpcyhjcm9zc0F4aXMpO1xuICAgICAgbGV0IG1haW5BeGlzQ29vcmQgPSBjb29yZHNbbWFpbkF4aXNdO1xuICAgICAgbGV0IGNyb3NzQXhpc0Nvb3JkID0gY29vcmRzW2Nyb3NzQXhpc107XG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBjb25zdCBtaW5TaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/ICd0b3AnIDogJ2xlZnQnO1xuICAgICAgICBjb25zdCBtYXhTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgICAgICAgY29uc3QgbWluID0gbWFpbkF4aXNDb29yZCArIG92ZXJmbG93W21pblNpZGVdO1xuICAgICAgICBjb25zdCBtYXggPSBtYWluQXhpc0Nvb3JkIC0gb3ZlcmZsb3dbbWF4U2lkZV07XG4gICAgICAgIG1haW5BeGlzQ29vcmQgPSBjbGFtcChtaW4sIG1haW5BeGlzQ29vcmQsIG1heCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgY29uc3QgbWluU2lkZSA9IGNyb3NzQXhpcyA9PT0gJ3knID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgICAgIGNvbnN0IG1heFNpZGUgPSBjcm9zc0F4aXMgPT09ICd5JyA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgICAgICAgY29uc3QgbWluID0gY3Jvc3NBeGlzQ29vcmQgKyBvdmVyZmxvd1ttaW5TaWRlXTtcbiAgICAgICAgY29uc3QgbWF4ID0gY3Jvc3NBeGlzQ29vcmQgLSBvdmVyZmxvd1ttYXhTaWRlXTtcbiAgICAgICAgY3Jvc3NBeGlzQ29vcmQgPSBjbGFtcChtaW4sIGNyb3NzQXhpc0Nvb3JkLCBtYXgpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGltaXRlZENvb3JkcyA9IGxpbWl0ZXIuZm4oe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgW21haW5BeGlzXTogbWFpbkF4aXNDb29yZCxcbiAgICAgICAgW2Nyb3NzQXhpc106IGNyb3NzQXhpc0Nvb3JkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmxpbWl0ZWRDb29yZHMsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB4OiBsaW1pdGVkQ29vcmRzLnggLSB4LFxuICAgICAgICAgIHk6IGxpbWl0ZWRDb29yZHMueSAtIHlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuLyoqXG4gKiBCdWlsdC1pbiBgbGltaXRlcmAgdGhhdCB3aWxsIHN0b3AgYHNoaWZ0KClgIGF0IGEgY2VydGFpbiBwb2ludC5cbiAqL1xuY29uc3QgbGltaXRTaGlmdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBvcHRpb25zLFxuICAgIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9mZnNldCA9IDAsXG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IHRydWVcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH07XG4gICAgICBjb25zdCBjcm9zc0F4aXMgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgbWFpbkF4aXMgPSBnZXRPcHBvc2l0ZUF4aXMoY3Jvc3NBeGlzKTtcbiAgICAgIGxldCBtYWluQXhpc0Nvb3JkID0gY29vcmRzW21haW5BeGlzXTtcbiAgICAgIGxldCBjcm9zc0F4aXNDb29yZCA9IGNvb3Jkc1tjcm9zc0F4aXNdO1xuICAgICAgY29uc3QgcmF3T2Zmc2V0ID0gZXZhbHVhdGUob2Zmc2V0LCBzdGF0ZSk7XG4gICAgICBjb25zdCBjb21wdXRlZE9mZnNldCA9IHR5cGVvZiByYXdPZmZzZXQgPT09ICdudW1iZXInID8ge1xuICAgICAgICBtYWluQXhpczogcmF3T2Zmc2V0LFxuICAgICAgICBjcm9zc0F4aXM6IDBcbiAgICAgIH0gOiB7XG4gICAgICAgIG1haW5BeGlzOiAwLFxuICAgICAgICBjcm9zc0F4aXM6IDAsXG4gICAgICAgIC4uLnJhd09mZnNldFxuICAgICAgfTtcbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICAgIGNvbnN0IGxpbWl0TWluID0gcmVjdHMucmVmZXJlbmNlW21haW5BeGlzXSAtIHJlY3RzLmZsb2F0aW5nW2xlbl0gKyBjb21wdXRlZE9mZnNldC5tYWluQXhpcztcbiAgICAgICAgY29uc3QgbGltaXRNYXggPSByZWN0cy5yZWZlcmVuY2VbbWFpbkF4aXNdICsgcmVjdHMucmVmZXJlbmNlW2xlbl0gLSBjb21wdXRlZE9mZnNldC5tYWluQXhpcztcbiAgICAgICAgaWYgKG1haW5BeGlzQ29vcmQgPCBsaW1pdE1pbikge1xuICAgICAgICAgIG1haW5BeGlzQ29vcmQgPSBsaW1pdE1pbjtcbiAgICAgICAgfSBlbHNlIGlmIChtYWluQXhpc0Nvb3JkID4gbGltaXRNYXgpIHtcbiAgICAgICAgICBtYWluQXhpc0Nvb3JkID0gbGltaXRNYXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJG9mZnNlLCBfbWlkZGxld2FyZURhdGEkb2Zmc2UyO1xuICAgICAgICBjb25zdCBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgICAgICBjb25zdCBpc09yaWdpblNpZGUgPSBbJ3RvcCcsICdsZWZ0J10uaW5jbHVkZXMoZ2V0U2lkZShwbGFjZW1lbnQpKTtcbiAgICAgICAgY29uc3QgbGltaXRNaW4gPSByZWN0cy5yZWZlcmVuY2VbY3Jvc3NBeGlzXSAtIHJlY3RzLmZsb2F0aW5nW2xlbl0gKyAoaXNPcmlnaW5TaWRlID8gKChfbWlkZGxld2FyZURhdGEkb2Zmc2UgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2VbY3Jvc3NBeGlzXSkgfHwgMCA6IDApICsgKGlzT3JpZ2luU2lkZSA/IDAgOiBjb21wdXRlZE9mZnNldC5jcm9zc0F4aXMpO1xuICAgICAgICBjb25zdCBsaW1pdE1heCA9IHJlY3RzLnJlZmVyZW5jZVtjcm9zc0F4aXNdICsgcmVjdHMucmVmZXJlbmNlW2xlbl0gKyAoaXNPcmlnaW5TaWRlID8gMCA6ICgoX21pZGRsZXdhcmVEYXRhJG9mZnNlMiA9IG1pZGRsZXdhcmVEYXRhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRvZmZzZTJbY3Jvc3NBeGlzXSkgfHwgMCkgLSAoaXNPcmlnaW5TaWRlID8gY29tcHV0ZWRPZmZzZXQuY3Jvc3NBeGlzIDogMCk7XG4gICAgICAgIGlmIChjcm9zc0F4aXNDb29yZCA8IGxpbWl0TWluKSB7XG4gICAgICAgICAgY3Jvc3NBeGlzQ29vcmQgPSBsaW1pdE1pbjtcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0F4aXNDb29yZCA+IGxpbWl0TWF4KSB7XG4gICAgICAgICAgY3Jvc3NBeGlzQ29vcmQgPSBsaW1pdE1heDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW21haW5BeGlzXTogbWFpbkF4aXNDb29yZCxcbiAgICAgICAgW2Nyb3NzQXhpc106IGNyb3NzQXhpc0Nvb3JkXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0aGF0IGFsbG93cyB5b3UgdG8gY2hhbmdlIHRoZSBzaXplIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IOKAlFxuICogZm9yIGluc3RhbmNlLCBwcmV2ZW50IGl0IGZyb20gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5IG9yIG1hdGNoIHRoZVxuICogd2lkdGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NpemVcbiAqL1xuY29uc3Qgc2l6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnc2l6ZScsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXBwbHkgPSAoKSA9PiB7fSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGlzWUF4aXMgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneSc7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSByZWN0cy5mbG9hdGluZztcbiAgICAgIGxldCBoZWlnaHRTaWRlO1xuICAgICAgbGV0IHdpZHRoU2lkZTtcbiAgICAgIGlmIChzaWRlID09PSAndG9wJyB8fCBzaWRlID09PSAnYm90dG9tJykge1xuICAgICAgICBoZWlnaHRTaWRlID0gc2lkZTtcbiAgICAgICAgd2lkdGhTaWRlID0gYWxpZ25tZW50ID09PSAoKGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKSkgPyAnc3RhcnQnIDogJ2VuZCcpID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoU2lkZSA9IHNpZGU7XG4gICAgICAgIGhlaWdodFNpZGUgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gb3ZlcmZsb3dbaGVpZ2h0U2lkZV07XG4gICAgICBjb25zdCBvdmVyZmxvd0F2YWlsYWJsZVdpZHRoID0gd2lkdGggLSBvdmVyZmxvd1t3aWR0aFNpZGVdO1xuICAgICAgY29uc3Qgbm9TaGlmdCA9ICFzdGF0ZS5taWRkbGV3YXJlRGF0YS5zaGlmdDtcbiAgICAgIGxldCBhdmFpbGFibGVIZWlnaHQgPSBvdmVyZmxvd0F2YWlsYWJsZUhlaWdodDtcbiAgICAgIGxldCBhdmFpbGFibGVXaWR0aCA9IG92ZXJmbG93QXZhaWxhYmxlV2lkdGg7XG4gICAgICBpZiAoaXNZQXhpcykge1xuICAgICAgICBjb25zdCBtYXhpbXVtQ2xpcHBpbmdXaWR0aCA9IHdpZHRoIC0gb3ZlcmZsb3cubGVmdCAtIG92ZXJmbG93LnJpZ2h0O1xuICAgICAgICBhdmFpbGFibGVXaWR0aCA9IGFsaWdubWVudCB8fCBub1NoaWZ0ID8gbWluKG92ZXJmbG93QXZhaWxhYmxlV2lkdGgsIG1heGltdW1DbGlwcGluZ1dpZHRoKSA6IG1heGltdW1DbGlwcGluZ1dpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF4aW11bUNsaXBwaW5nSGVpZ2h0ID0gaGVpZ2h0IC0gb3ZlcmZsb3cudG9wIC0gb3ZlcmZsb3cuYm90dG9tO1xuICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBhbGlnbm1lbnQgfHwgbm9TaGlmdCA/IG1pbihvdmVyZmxvd0F2YWlsYWJsZUhlaWdodCwgbWF4aW11bUNsaXBwaW5nSGVpZ2h0KSA6IG1heGltdW1DbGlwcGluZ0hlaWdodDtcbiAgICAgIH1cbiAgICAgIGlmIChub1NoaWZ0ICYmICFhbGlnbm1lbnQpIHtcbiAgICAgICAgY29uc3QgeE1pbiA9IG1heChvdmVyZmxvdy5sZWZ0LCAwKTtcbiAgICAgICAgY29uc3QgeE1heCA9IG1heChvdmVyZmxvdy5yaWdodCwgMCk7XG4gICAgICAgIGNvbnN0IHlNaW4gPSBtYXgob3ZlcmZsb3cudG9wLCAwKTtcbiAgICAgICAgY29uc3QgeU1heCA9IG1heChvdmVyZmxvdy5ib3R0b20sIDApO1xuICAgICAgICBpZiAoaXNZQXhpcykge1xuICAgICAgICAgIGF2YWlsYWJsZVdpZHRoID0gd2lkdGggLSAyICogKHhNaW4gIT09IDAgfHwgeE1heCAhPT0gMCA/IHhNaW4gKyB4TWF4IDogbWF4KG92ZXJmbG93LmxlZnQsIG92ZXJmbG93LnJpZ2h0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gMiAqICh5TWluICE9PSAwIHx8IHlNYXggIT09IDAgPyB5TWluICsgeU1heCA6IG1heChvdmVyZmxvdy50b3AsIG92ZXJmbG93LmJvdHRvbSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhd2FpdCBhcHBseSh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBhdmFpbGFibGVXaWR0aCxcbiAgICAgICAgYXZhaWxhYmxlSGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG5leHREaW1lbnNpb25zID0gYXdhaXQgcGxhdGZvcm0uZ2V0RGltZW5zaW9ucyhlbGVtZW50cy5mbG9hdGluZyk7XG4gICAgICBpZiAod2lkdGggIT09IG5leHREaW1lbnNpb25zLndpZHRoIHx8IGhlaWdodCAhPT0gbmV4dERpbWVuc2lvbnMuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHJlY3RzOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBjb21wdXRlUG9zaXRpb24sIGRldGVjdE92ZXJmbG93LCBmbGlwLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgc2hpZnQsIHNpemUgfTtcbiJdLCJuYW1lcyI6WyJnZXRTaWRlQXhpcyIsImdldEFsaWdubWVudEF4aXMiLCJnZXRBeGlzTGVuZ3RoIiwiZ2V0U2lkZSIsImdldEFsaWdubWVudCIsImV2YWx1YXRlIiwiZ2V0UGFkZGluZ09iamVjdCIsInJlY3RUb0NsaWVudFJlY3QiLCJtaW4iLCJjbGFtcCIsInBsYWNlbWVudHMiLCJnZXRBbGlnbm1lbnRTaWRlcyIsImdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50IiwiZ2V0T3Bwb3NpdGVQbGFjZW1lbnQiLCJnZXRFeHBhbmRlZFBsYWNlbWVudHMiLCJnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzIiwic2lkZXMiLCJtYXgiLCJnZXRPcHBvc2l0ZUF4aXMiLCJjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudCIsIl9yZWYiLCJwbGFjZW1lbnQiLCJydGwiLCJyZWZlcmVuY2UiLCJmbG9hdGluZyIsInNpZGVBeGlzIiwiYWxpZ25tZW50QXhpcyIsImFsaWduTGVuZ3RoIiwic2lkZSIsImlzVmVydGljYWwiLCJjb21tb25YIiwieCIsIndpZHRoIiwiY29tbW9uWSIsInkiLCJoZWlnaHQiLCJjb21tb25BbGlnbiIsImNvb3JkcyIsImNvbXB1dGVQb3NpdGlvbiIsImNvbmZpZyIsInN0cmF0ZWd5IiwibWlkZGxld2FyZSIsInBsYXRmb3JtIiwidmFsaWRNaWRkbGV3YXJlIiwiZmlsdGVyIiwiQm9vbGVhbiIsImlzUlRMIiwicmVjdHMiLCJnZXRFbGVtZW50UmVjdHMiLCJzdGF0ZWZ1bFBsYWNlbWVudCIsIm1pZGRsZXdhcmVEYXRhIiwicmVzZXRDb3VudCIsImkiLCJsZW5ndGgiLCJuYW1lIiwiZm4iLCJuZXh0WCIsIm5leHRZIiwiZGF0YSIsInJlc2V0IiwiaW5pdGlhbFBsYWNlbWVudCIsImVsZW1lbnRzIiwiZGV0ZWN0T3ZlcmZsb3ciLCJzdGF0ZSIsIm9wdGlvbnMiLCJfYXdhaXQkcGxhdGZvcm0kaXNFbGUiLCJib3VuZGFyeSIsInJvb3RCb3VuZGFyeSIsImVsZW1lbnRDb250ZXh0IiwiYWx0Qm91bmRhcnkiLCJwYWRkaW5nIiwicGFkZGluZ09iamVjdCIsImFsdENvbnRleHQiLCJlbGVtZW50IiwiY2xpcHBpbmdDbGllbnRSZWN0IiwiZ2V0Q2xpcHBpbmdSZWN0IiwiaXNFbGVtZW50IiwiY29udGV4dEVsZW1lbnQiLCJnZXREb2N1bWVudEVsZW1lbnQiLCJyZWN0Iiwib2Zmc2V0UGFyZW50IiwiZ2V0T2Zmc2V0UGFyZW50Iiwib2Zmc2V0U2NhbGUiLCJnZXRTY2FsZSIsImVsZW1lbnRDbGllbnRSZWN0IiwiY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QiLCJ0b3AiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJhcnJvdyIsImF4aXMiLCJhcnJvd0RpbWVuc2lvbnMiLCJnZXREaW1lbnNpb25zIiwiaXNZQXhpcyIsIm1pblByb3AiLCJtYXhQcm9wIiwiY2xpZW50UHJvcCIsImVuZERpZmYiLCJzdGFydERpZmYiLCJhcnJvd09mZnNldFBhcmVudCIsImNsaWVudFNpemUiLCJjZW50ZXJUb1JlZmVyZW5jZSIsImxhcmdlc3RQb3NzaWJsZVBhZGRpbmciLCJtaW5QYWRkaW5nIiwibWF4UGFkZGluZyIsIm1pbiQxIiwiY2VudGVyIiwib2Zmc2V0Iiwic2hvdWxkQWRkT2Zmc2V0IiwiYWxpZ25tZW50T2Zmc2V0IiwiY2VudGVyT2Zmc2V0IiwiZ2V0UGxhY2VtZW50TGlzdCIsImFsaWdubWVudCIsImF1dG9BbGlnbm1lbnQiLCJhbGxvd2VkUGxhY2VtZW50cyIsImFsbG93ZWRQbGFjZW1lbnRzU29ydGVkQnlBbGlnbm1lbnQiLCJhdXRvUGxhY2VtZW50IiwiX21pZGRsZXdhcmVEYXRhJGF1dG9QIiwiX21pZGRsZXdhcmVEYXRhJGF1dG9QMiIsIl9wbGFjZW1lbnRzVGhhdEZpdE9uRSIsImNyb3NzQXhpcyIsImRldGVjdE92ZXJmbG93T3B0aW9ucyIsInBsYWNlbWVudHMkMSIsInVuZGVmaW5lZCIsIm92ZXJmbG93IiwiY3VycmVudEluZGV4IiwiaW5kZXgiLCJjdXJyZW50UGxhY2VtZW50IiwiYWxpZ25tZW50U2lkZXMiLCJjdXJyZW50T3ZlcmZsb3dzIiwiYWxsT3ZlcmZsb3dzIiwib3ZlcmZsb3dzIiwibmV4dFBsYWNlbWVudCIsInBsYWNlbWVudHNTb3J0ZWRCeU1vc3RTcGFjZSIsIm1hcCIsImQiLCJzbGljZSIsInJlZHVjZSIsImFjYyIsInYiLCJzb3J0IiwiYSIsImIiLCJwbGFjZW1lbnRzVGhhdEZpdE9uRWFjaFNpZGUiLCJldmVyeSIsInJlc2V0UGxhY2VtZW50IiwiZmxpcCIsIl9taWRkbGV3YXJlRGF0YSRhcnJvdyIsIl9taWRkbGV3YXJlRGF0YSRmbGlwIiwibWFpbkF4aXMiLCJjaGVja01haW5BeGlzIiwiY2hlY2tDcm9zc0F4aXMiLCJmYWxsYmFja1BsYWNlbWVudHMiLCJzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMiLCJmYWxsYmFja1N0cmF0ZWd5IiwiZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiIsImZsaXBBbGlnbm1lbnQiLCJpc0Jhc2VQbGFjZW1lbnQiLCJwdXNoIiwib3ZlcmZsb3dzRGF0YSIsIl9taWRkbGV3YXJlRGF0YSRmbGlwMiIsIl9vdmVyZmxvd3NEYXRhJGZpbHRlciIsIm5leHRJbmRleCIsIl9vdmVyZmxvd3NEYXRhJG1hcCRzbyIsImdldFNpZGVPZmZzZXRzIiwiaXNBbnlTaWRlRnVsbHlDbGlwcGVkIiwic29tZSIsImhpZGUiLCJvZmZzZXRzIiwicmVmZXJlbmNlSGlkZGVuT2Zmc2V0cyIsInJlZmVyZW5jZUhpZGRlbiIsImVzY2FwZWRPZmZzZXRzIiwiZXNjYXBlZCIsImdldEJvdW5kaW5nUmVjdCIsIm1pblgiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJnZXRSZWN0c0J5TGluZSIsInNvcnRlZFJlY3RzIiwiZ3JvdXBzIiwicHJldlJlY3QiLCJpbmxpbmUiLCJuYXRpdmVDbGllbnRSZWN0cyIsIkFycmF5IiwiZnJvbSIsImdldENsaWVudFJlY3RzIiwiY2xpZW50UmVjdHMiLCJmYWxsYmFjayIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImZpbmQiLCJmaXJzdFJlY3QiLCJsYXN0UmVjdCIsImlzVG9wIiwiaXNMZWZ0U2lkZSIsIm1heFJpZ2h0IiwibWluTGVmdCIsIm1lYXN1cmVSZWN0cyIsInJlc2V0UmVjdHMiLCJjb252ZXJ0VmFsdWVUb0Nvb3JkcyIsIm1haW5BeGlzTXVsdGkiLCJpbmNsdWRlcyIsImNyb3NzQXhpc011bHRpIiwicmF3VmFsdWUiLCJfbWlkZGxld2FyZURhdGEkb2Zmc2UiLCJkaWZmQ29vcmRzIiwic2hpZnQiLCJsaW1pdGVyIiwibWFpbkF4aXNDb29yZCIsImNyb3NzQXhpc0Nvb3JkIiwibWluU2lkZSIsIm1heFNpZGUiLCJsaW1pdGVkQ29vcmRzIiwibGltaXRTaGlmdCIsInJhd09mZnNldCIsImNvbXB1dGVkT2Zmc2V0IiwibGVuIiwibGltaXRNaW4iLCJsaW1pdE1heCIsIl9taWRkbGV3YXJlRGF0YSRvZmZzZTIiLCJpc09yaWdpblNpZGUiLCJzaXplIiwiYXBwbHkiLCJoZWlnaHRTaWRlIiwid2lkdGhTaWRlIiwib3ZlcmZsb3dBdmFpbGFibGVIZWlnaHQiLCJvdmVyZmxvd0F2YWlsYWJsZVdpZHRoIiwibm9TaGlmdCIsImF2YWlsYWJsZUhlaWdodCIsImF2YWlsYWJsZVdpZHRoIiwibWF4aW11bUNsaXBwaW5nV2lkdGgiLCJtYXhpbXVtQ2xpcHBpbmdIZWlnaHQiLCJ4TWluIiwieE1heCIsInlNaW4iLCJ5TWF4IiwibmV4dERpbWVuc2lvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* binding */ autoUpdate),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.inline),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.offset),\n/* harmony export */   platform: () => (/* binding */ platform),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/core */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs\");\n\n\n\n\n\nfunction getCssDimensions(element) {\n    const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element);\n    // In testing environments, the `width` and `height` properties are empty\n    // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n    let width = parseFloat(css.width) || 0;\n    let height = parseFloat(css.height) || 0;\n    const hasOffset = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element);\n    const offsetWidth = hasOffset ? element.offsetWidth : width;\n    const offsetHeight = hasOffset ? element.offsetHeight : height;\n    const shouldFallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(width) !== offsetWidth || (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(height) !== offsetHeight;\n    if (shouldFallback) {\n        width = offsetWidth;\n        height = offsetHeight;\n    }\n    return {\n        width,\n        height,\n        $: shouldFallback\n    };\n}\nfunction unwrapElement(element) {\n    return !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(element) ? element.contextElement : element;\n}\nfunction getScale(element) {\n    const domElement = unwrapElement(element);\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(domElement)) {\n        return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n    }\n    const rect = domElement.getBoundingClientRect();\n    const { width, height, $ } = getCssDimensions(domElement);\n    let x = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(rect.width) : rect.width) / width;\n    let y = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(rect.height) : rect.height) / height;\n    // 0, NaN, or Infinity should always fallback to 1.\n    if (!x || !Number.isFinite(x)) {\n        x = 1;\n    }\n    if (!y || !Number.isFinite(y)) {\n        y = 1;\n    }\n    return {\n        x,\n        y\n    };\n}\nconst noOffsets = /*#__PURE__*/ (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\nfunction getVisualOffsets(element) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isWebKit)() || !win.visualViewport) {\n        return noOffsets;\n    }\n    return {\n        x: win.visualViewport.offsetLeft,\n        y: win.visualViewport.offsetTop\n    };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n    if (isFixed === void 0) {\n        isFixed = false;\n    }\n    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element)) {\n        return false;\n    }\n    return isFixed;\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n    if (includeScale === void 0) {\n        includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n        isFixedStrategy = false;\n    }\n    const clientRect = element.getBoundingClientRect();\n    const domElement = unwrapElement(element);\n    let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n    if (includeScale) {\n        if (offsetParent) {\n            if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(offsetParent)) {\n                scale = getScale(offsetParent);\n            }\n        } else {\n            scale = getScale(element);\n        }\n    }\n    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\n    let x = (clientRect.left + visualOffsets.x) / scale.x;\n    let y = (clientRect.top + visualOffsets.y) / scale.y;\n    let width = clientRect.width / scale.x;\n    let height = clientRect.height / scale.y;\n    if (domElement) {\n        const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(domElement);\n        const offsetWin = offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(offsetParent) ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(offsetParent) : offsetParent;\n        let currentIFrame = win.frameElement;\n        while(currentIFrame && offsetParent && offsetWin !== win){\n            const iframeScale = getScale(currentIFrame);\n            const iframeRect = currentIFrame.getBoundingClientRect();\n            const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(currentIFrame);\n            const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n            const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n            x *= iframeScale.x;\n            y *= iframeScale.y;\n            width *= iframeScale.x;\n            height *= iframeScale.y;\n            x += left;\n            y += top;\n            currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(currentIFrame).frameElement;\n        }\n    }\n    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.rectToClientRect)({\n        width,\n        height,\n        x,\n        y\n    });\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n    let { rect, offsetParent, strategy } = _ref;\n    const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);\n    const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(offsetParent);\n    if (offsetParent === documentElement) {\n        return rect;\n    }\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n    const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== \"fixed\") {\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) !== \"body\" || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(documentElement)) {\n            scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(offsetParent);\n        }\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent)) {\n            const offsetRect = getBoundingClientRect(offsetParent);\n            scale = getScale(offsetParent);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        }\n    }\n    return {\n        width: rect.width * scale.x,\n        height: rect.height * scale.y,\n        x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n        y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n    };\n}\nfunction getClientRects(element) {\n    return Array.from(element.getClientRects());\n}\nfunction getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    return getBoundingClientRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element)).left + (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(element).scrollLeft;\n}\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n    const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);\n    const scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(element);\n    const body = element.ownerDocument.body;\n    const width = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n    const height = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n    let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n    const y = -scroll.scrollTop;\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(body).direction === \"rtl\") {\n        x += (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.clientWidth, body.clientWidth) - width;\n    }\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\nfunction getViewportRect(element, strategy) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);\n    const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);\n    const visualViewport = win.visualViewport;\n    let width = html.clientWidth;\n    let height = html.clientHeight;\n    let x = 0;\n    let y = 0;\n    if (visualViewport) {\n        width = visualViewport.width;\n        height = visualViewport.height;\n        const visualViewportBased = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isWebKit)();\n        if (!visualViewportBased || visualViewportBased && strategy === \"fixed\") {\n            x = visualViewport.offsetLeft;\n            y = visualViewport.offsetTop;\n        }\n    }\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n    const clientRect = getBoundingClientRect(element, true, strategy === \"fixed\");\n    const top = clientRect.top + element.clientTop;\n    const left = clientRect.left + element.clientLeft;\n    const scale = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) ? getScale(element) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n    const width = element.clientWidth * scale.x;\n    const height = element.clientHeight * scale.y;\n    const x = left * scale.x;\n    const y = top * scale.y;\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n    let rect;\n    if (clippingAncestor === \"viewport\") {\n        rect = getViewportRect(element, strategy);\n    } else if (clippingAncestor === \"document\") {\n        rect = getDocumentRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element));\n    } else if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(clippingAncestor)) {\n        rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n    } else {\n        const visualOffsets = getVisualOffsets(element);\n        rect = {\n            ...clippingAncestor,\n            x: clippingAncestor.x - visualOffsets.x,\n            y: clippingAncestor.y - visualOffsets.y\n        };\n    }\n    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.rectToClientRect)(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n    const parentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(element);\n    if (parentNode === stopNode || !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(parentNode) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isLastTraversableNode)(parentNode)) {\n        return false;\n    }\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(parentNode).position === \"fixed\" || hasFixedPositionAncestor(parentNode, stopNode);\n}\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n    const cachedResult = cache.get(element);\n    if (cachedResult) {\n        return cachedResult;\n    }\n    let result = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(element, [], false).filter((el)=>(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(el) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(el) !== \"body\");\n    let currentContainingBlockComputedStyle = null;\n    const elementIsFixed = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).position === \"fixed\";\n    let currentNode = elementIsFixed ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(element) : element;\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    while((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(currentNode) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isLastTraversableNode)(currentNode)){\n        const computedStyle = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(currentNode);\n        const currentNodeIsContaining = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isContainingBlock)(currentNode);\n        if (!currentNodeIsContaining && computedStyle.position === \"fixed\") {\n            currentContainingBlockComputedStyle = null;\n        }\n        const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === \"static\" && !!currentContainingBlockComputedStyle && [\n            \"absolute\",\n            \"fixed\"\n        ].includes(currentContainingBlockComputedStyle.position) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n        if (shouldDropCurrentNode) {\n            // Drop non-containing blocks.\n            result = result.filter((ancestor)=>ancestor !== currentNode);\n        } else {\n            // Record last containing block for next iteration.\n            currentContainingBlockComputedStyle = computedStyle;\n        }\n        currentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(currentNode);\n    }\n    cache.set(element, result);\n    return result;\n}\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n    let { element, boundary, rootBoundary, strategy } = _ref;\n    const elementClippingAncestors = boundary === \"clippingAncestors\" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n    const clippingAncestors = [\n        ...elementClippingAncestors,\n        rootBoundary\n    ];\n    const firstClippingAncestor = clippingAncestors[0];\n    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor)=>{\n        const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n        accRect.top = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(rect.top, accRect.top);\n        accRect.right = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(rect.right, accRect.right);\n        accRect.bottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(rect.bottom, accRect.bottom);\n        accRect.left = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(rect.left, accRect.left);\n        return accRect;\n    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n    return {\n        width: clippingRect.right - clippingRect.left,\n        height: clippingRect.bottom - clippingRect.top,\n        x: clippingRect.left,\n        y: clippingRect.top\n    };\n}\nfunction getDimensions(element) {\n    return getCssDimensions(element);\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n    const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);\n    const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(offsetParent);\n    const isFixed = strategy === \"fixed\";\n    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) !== \"body\" || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(documentElement)) {\n            scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(offsetParent);\n        }\n        if (isOffsetParentAnElement) {\n            const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        } else if (documentElement) {\n            offsets.x = getWindowScrollBarX(documentElement);\n        }\n    }\n    return {\n        x: rect.left + scroll.scrollLeft - offsets.x,\n        y: rect.top + scroll.scrollTop - offsets.y,\n        width: rect.width,\n        height: rect.height\n    };\n}\nfunction getTrueOffsetParent(element, polyfill) {\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).position === \"fixed\") {\n        return null;\n    }\n    if (polyfill) {\n        return polyfill(element);\n    }\n    return element.offsetParent;\n}\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n    const window = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element)) {\n        return window;\n    }\n    let offsetParent = getTrueOffsetParent(element, polyfill);\n    while(offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isTableElement)(offsetParent) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(offsetParent).position === \"static\"){\n        offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n    }\n    if (offsetParent && ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) === \"html\" || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) === \"body\" && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(offsetParent).position === \"static\" && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isContainingBlock)(offsetParent))) {\n        return window;\n    }\n    return offsetParent || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getContainingBlock)(element) || window;\n}\nconst getElementRects = async function(_ref) {\n    let { reference, floating, strategy } = _ref;\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    return {\n        reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n        floating: {\n            x: 0,\n            y: 0,\n            ...await getDimensionsFn(floating)\n        }\n    };\n};\nfunction isRTL(element) {\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).direction === \"rtl\";\n}\nconst platform = {\n    convertOffsetParentRelativeRectToViewportRelativeRect,\n    getDocumentElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement,\n    getClippingRect,\n    getOffsetParent,\n    getElementRects,\n    getClientRects,\n    getDimensions,\n    getScale,\n    isElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement,\n    isRTL\n};\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n    let io = null;\n    let timeoutId;\n    const root = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);\n    function cleanup() {\n        clearTimeout(timeoutId);\n        io && io.disconnect();\n        io = null;\n    }\n    function refresh(skip, threshold) {\n        if (skip === void 0) {\n            skip = false;\n        }\n        if (threshold === void 0) {\n            threshold = 1;\n        }\n        cleanup();\n        const { left, top, width, height } = element.getBoundingClientRect();\n        if (!skip) {\n            onMove();\n        }\n        if (!width || !height) {\n            return;\n        }\n        const insetTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(top);\n        const insetRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(root.clientWidth - (left + width));\n        const insetBottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(root.clientHeight - (top + height));\n        const insetLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(left);\n        const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n        const options = {\n            rootMargin,\n            threshold: (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(0, (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(1, threshold)) || 1\n        };\n        let isFirstUpdate = true;\n        function handleObserve(entries) {\n            const ratio = entries[0].intersectionRatio;\n            if (ratio !== threshold) {\n                if (!isFirstUpdate) {\n                    return refresh();\n                }\n                if (!ratio) {\n                    timeoutId = setTimeout(()=>{\n                        refresh(false, 1e-7);\n                    }, 100);\n                } else {\n                    refresh(false, ratio);\n                }\n            }\n            isFirstUpdate = false;\n        }\n        // Older browsers don't support a `document` as the root and will throw an\n        // error.\n        try {\n            io = new IntersectionObserver(handleObserve, {\n                ...options,\n                // Handle <iframe>s\n                root: root.ownerDocument\n            });\n        } catch (e) {\n            io = new IntersectionObserver(handleObserve, options);\n        }\n        io.observe(element);\n    }\n    refresh(true);\n    return cleanup;\n}\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */ function autoUpdate(reference, floating, update, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { ancestorScroll = true, ancestorResize = true, elementResize = typeof ResizeObserver === \"function\", layoutShift = typeof IntersectionObserver === \"function\", animationFrame = false } = options;\n    const referenceEl = unwrapElement(reference);\n    const ancestors = ancestorScroll || ancestorResize ? [\n        ...referenceEl ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(referenceEl) : [],\n        ...(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(floating)\n    ] : [];\n    ancestors.forEach((ancestor)=>{\n        ancestorScroll && ancestor.addEventListener(\"scroll\", update, {\n            passive: true\n        });\n        ancestorResize && ancestor.addEventListener(\"resize\", update);\n    });\n    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n    let reobserveFrame = -1;\n    let resizeObserver = null;\n    if (elementResize) {\n        resizeObserver = new ResizeObserver((_ref)=>{\n            let [firstEntry] = _ref;\n            if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n                // Prevent update loops when using the `size` middleware.\n                // https://github.com/floating-ui/floating-ui/issues/1740\n                resizeObserver.unobserve(floating);\n                cancelAnimationFrame(reobserveFrame);\n                reobserveFrame = requestAnimationFrame(()=>{\n                    resizeObserver && resizeObserver.observe(floating);\n                });\n            }\n            update();\n        });\n        if (referenceEl && !animationFrame) {\n            resizeObserver.observe(referenceEl);\n        }\n        resizeObserver.observe(floating);\n    }\n    let frameId;\n    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n    if (animationFrame) {\n        frameLoop();\n    }\n    function frameLoop() {\n        const nextRefRect = getBoundingClientRect(reference);\n        if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n            update();\n        }\n        prevRefRect = nextRefRect;\n        frameId = requestAnimationFrame(frameLoop);\n    }\n    update();\n    return ()=>{\n        ancestors.forEach((ancestor)=>{\n            ancestorScroll && ancestor.removeEventListener(\"scroll\", update);\n            ancestorResize && ancestor.removeEventListener(\"resize\", update);\n        });\n        cleanupIo && cleanupIo();\n        resizeObserver && resizeObserver.disconnect();\n        resizeObserver = null;\n        if (animationFrame) {\n            cancelAnimationFrame(frameId);\n        }\n    };\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */ const computePosition = (reference, floating, options)=>{\n    // This caches the expensive `getClippingElementAncestors` function so that\n    // multiple lifecycle resets re-use the same result. It only lives for a\n    // single call. If other functions become expensive, we can add them as well.\n    const cache = new Map();\n    const mergedOptions = {\n        platform,\n        ...options\n    };\n    const platformWithCache = {\n        ...mergedOptions.platform,\n        _c: cache\n    };\n    return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.computePosition)(reference, floating, {\n        ...mergedOptions,\n        platform: platformWithCache\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkY7QUFDbUM7QUFDcEQ7QUFDcU47QUFDak87QUFFOUQsU0FBU2lDLGlCQUFpQkMsT0FBTztJQUMvQixNQUFNQyxNQUFNakIsd0VBQWdCQSxDQUFDZ0I7SUFDN0IseUVBQXlFO0lBQ3pFLHlFQUF5RTtJQUN6RSxJQUFJRSxRQUFRQyxXQUFXRixJQUFJQyxLQUFLLEtBQUs7SUFDckMsSUFBSUUsU0FBU0QsV0FBV0YsSUFBSUcsTUFBTSxLQUFLO0lBQ3ZDLE1BQU1DLFlBQVlwQixxRUFBYUEsQ0FBQ2U7SUFDaEMsTUFBTU0sY0FBY0QsWUFBWUwsUUFBUU0sV0FBVyxHQUFHSjtJQUN0RCxNQUFNSyxlQUFlRixZQUFZTCxRQUFRTyxZQUFZLEdBQUdIO0lBQ3hELE1BQU1JLGlCQUFpQjdCLHlEQUFLQSxDQUFDdUIsV0FBV0ksZUFBZTNCLHlEQUFLQSxDQUFDeUIsWUFBWUc7SUFDekUsSUFBSUMsZ0JBQWdCO1FBQ2xCTixRQUFRSTtRQUNSRixTQUFTRztJQUNYO0lBQ0EsT0FBTztRQUNMTDtRQUNBRTtRQUNBSyxHQUFHRDtJQUNMO0FBQ0Y7QUFFQSxTQUFTRSxjQUFjVixPQUFPO0lBQzVCLE9BQU8sQ0FBQ2QsaUVBQVNBLENBQUNjLFdBQVdBLFFBQVFXLGNBQWMsR0FBR1g7QUFDeEQ7QUFFQSxTQUFTWSxTQUFTWixPQUFPO0lBQ3ZCLE1BQU1hLGFBQWFILGNBQWNWO0lBQ2pDLElBQUksQ0FBQ2YscUVBQWFBLENBQUM0QixhQUFhO1FBQzlCLE9BQU9qQyxnRUFBWUEsQ0FBQztJQUN0QjtJQUNBLE1BQU1rQyxPQUFPRCxXQUFXRSxxQkFBcUI7SUFDN0MsTUFBTSxFQUNKYixLQUFLLEVBQ0xFLE1BQU0sRUFDTkssQ0FBQyxFQUNGLEdBQUdWLGlCQUFpQmM7SUFDckIsSUFBSUcsSUFBSSxDQUFDUCxJ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M0Usd0VBQXdFO0lBQ3hFLDZFQUE2RTtJQUM3RSxNQUFNekQsUUFBUSxJQUFJNkY7SUFDbEIsTUFBTUMsZ0JBQWdCO1FBQ3BCdEQ7UUFDQSxHQUFHaUIsT0FBTztJQUNaO0lBQ0EsTUFBTXNDLG9CQUFvQjtRQUN4QixHQUFHRCxjQUFjdEQsUUFBUTtRQUN6QnJCLElBQUluQjtJQUNOO0lBQ0EsT0FBTy9HLGtFQUFpQkEsQ0FBQ2tKLFdBQVdDLFVBQVU7UUFDNUMsR0FBRzBELGFBQWE7UUFDaEJ0RCxVQUFVdUQ7SUFDWjtBQUNGO0FBRWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmVuZ2dyaS5naXRodWIuaW8vLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanM/M2ZhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZWN0VG9DbGllbnRSZWN0LCBjb21wdXRlUG9zaXRpb24gYXMgY29tcHV0ZVBvc2l0aW9uJDEgfSBmcm9tICdAZmxvYXRpbmctdWkvY29yZSc7XG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBzaGlmdCwgc2l6ZSB9IGZyb20gJ0BmbG9hdGluZy11aS9jb3JlJztcbmltcG9ydCB7IHJvdW5kLCBjcmVhdGVDb29yZHMsIG1heCwgbWluLCBmbG9vciB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5pbXBvcnQgeyBnZXRDb21wdXRlZFN0eWxlLCBpc0hUTUxFbGVtZW50LCBpc0VsZW1lbnQsIGdldFdpbmRvdywgaXNXZWJLaXQsIGdldERvY3VtZW50RWxlbWVudCwgZ2V0Tm9kZU5hbWUsIGlzT3ZlcmZsb3dFbGVtZW50LCBnZXROb2RlU2Nyb2xsLCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgZ2V0UGFyZW50Tm9kZSwgaXNMYXN0VHJhdmVyc2FibGVOb2RlLCBpc0NvbnRhaW5pbmdCbG9jaywgaXNUYWJsZUVsZW1lbnQsIGdldENvbnRhaW5pbmdCbG9jayB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuZXhwb3J0IHsgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcblxuZnVuY3Rpb24gZ2V0Q3NzRGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIGNvbnN0IGNzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIC8vIEluIHRlc3RpbmcgZW52aXJvbm1lbnRzLCB0aGUgYHdpZHRoYCBhbmQgYGhlaWdodGAgcHJvcGVydGllcyBhcmUgZW1wdHlcbiAgLy8gc3RyaW5ncyBmb3IgU1ZHIGVsZW1lbnRzLCByZXR1cm5pbmcgTmFOLiBGYWxsYmFjayB0byBgMGAgaW4gdGhpcyBjYXNlLlxuICBsZXQgd2lkdGggPSBwYXJzZUZsb2F0KGNzcy53aWR0aCkgfHwgMDtcbiAgbGV0IGhlaWdodCA9IHBhcnNlRmxvYXQoY3NzLmhlaWdodCkgfHwgMDtcbiAgY29uc3QgaGFzT2Zmc2V0ID0gaXNIVE1MRWxlbWVudChlbGVtZW50KTtcbiAgY29uc3Qgb2Zmc2V0V2lkdGggPSBoYXNPZmZzZXQgPyBlbGVtZW50Lm9mZnNldFdpZHRoIDogd2lkdGg7XG4gIGNvbnN0IG9mZnNldEhlaWdodCA9IGhhc09mZnNldCA/IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IDogaGVpZ2h0O1xuICBjb25zdCBzaG91bGRGYWxsYmFjayA9IHJvdW5kKHdpZHRoKSAhPT0gb2Zmc2V0V2lkdGggfHwgcm91bmQoaGVpZ2h0KSAhPT0gb2Zmc2V0SGVpZ2h0O1xuICBpZiAoc2hvdWxkRmFsbGJhY2spIHtcbiAgICB3aWR0aCA9IG9mZnNldFdpZHRoO1xuICAgIGhlaWdodCA9IG9mZnNldEhlaWdodDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICAkOiBzaG91bGRGYWxsYmFja1xuICB9O1xufVxuXG5mdW5jdGlvbiB1bndyYXBFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuICFpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50LmNvbnRleHRFbGVtZW50IDogZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0U2NhbGUoZWxlbWVudCkge1xuICBjb25zdCBkb21FbGVtZW50ID0gdW53cmFwRWxlbWVudChlbGVtZW50KTtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGRvbUVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvb3JkcygxKTtcbiAgfVxuICBjb25zdCByZWN0ID0gZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICAkXG4gIH0gPSBnZXRDc3NEaW1lbnNpb25zKGRvbUVsZW1lbnQpO1xuICBsZXQgeCA9ICgkID8gcm91bmQocmVjdC53aWR0aCkgOiByZWN0LndpZHRoKSAvIHdpZHRoO1xuICBsZXQgeSA9ICgkID8gcm91bmQocmVjdC5oZWlnaHQpIDogcmVjdC5oZWlnaHQpIC8gaGVpZ2h0O1xuXG4gIC8vIDAsIE5hTiwgb3IgSW5maW5pdHkgc2hvdWxkIGFsd2F5cyBmYWxsYmFjayB0byAxLlxuXG4gIGlmICgheCB8fCAhTnVtYmVyLmlzRmluaXRlKHgpKSB7XG4gICAgeCA9IDE7XG4gIH1cbiAgaWYgKCF5IHx8ICFOdW1iZXIuaXNGaW5pdGUoeSkpIHtcbiAgICB5ID0gMTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5jb25zdCBub09mZnNldHMgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29vcmRzKDApO1xuZnVuY3Rpb24gZ2V0VmlzdWFsT2Zmc2V0cyhlbGVtZW50KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgaWYgKCFpc1dlYktpdCgpIHx8ICF3aW4udmlzdWFsVmlld3BvcnQpIHtcbiAgICByZXR1cm4gbm9PZmZzZXRzO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogd2luLnZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQsXG4gICAgeTogd2luLnZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcFxuICB9O1xufVxuZnVuY3Rpb24gc2hvdWxkQWRkVmlzdWFsT2Zmc2V0cyhlbGVtZW50LCBpc0ZpeGVkLCBmbG9hdGluZ09mZnNldFBhcmVudCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG4gIGlmICghZmxvYXRpbmdPZmZzZXRQYXJlbnQgfHwgaXNGaXhlZCAmJiBmbG9hdGluZ09mZnNldFBhcmVudCAhPT0gZ2V0V2luZG93KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpeGVkO1xufVxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3ksIG9mZnNldFBhcmVudCkge1xuICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdWRlU2NhbGUgPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgZG9tRWxlbWVudCA9IHVud3JhcEVsZW1lbnQoZWxlbWVudCk7XG4gIGxldCBzY2FsZSA9IGNyZWF0ZUNvb3JkcygxKTtcbiAgaWYgKGluY2x1ZGVTY2FsZSkge1xuICAgIGlmIChvZmZzZXRQYXJlbnQpIHtcbiAgICAgIGlmIChpc0VsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgICBzY2FsZSA9IGdldFNjYWxlKG9mZnNldFBhcmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gZ2V0U2NhbGUoZWxlbWVudCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHZpc3VhbE9mZnNldHMgPSBzaG91bGRBZGRWaXN1YWxPZmZzZXRzKGRvbUVsZW1lbnQsIGlzRml4ZWRTdHJhdGVneSwgb2Zmc2V0UGFyZW50KSA/IGdldFZpc3VhbE9mZnNldHMoZG9tRWxlbWVudCkgOiBjcmVhdGVDb29yZHMoMCk7XG4gIGxldCB4ID0gKGNsaWVudFJlY3QubGVmdCArIHZpc3VhbE9mZnNldHMueCkgLyBzY2FsZS54O1xuICBsZXQgeSA9IChjbGllbnRSZWN0LnRvcCArIHZpc3VhbE9mZnNldHMueSkgLyBzY2FsZS55O1xuICBsZXQgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGUueDtcbiAgbGV0IGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0IC8gc2NhbGUueTtcbiAgaWYgKGRvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZG9tRWxlbWVudCk7XG4gICAgY29uc3Qgb2Zmc2V0V2luID0gb2Zmc2V0UGFyZW50ICYmIGlzRWxlbWVudChvZmZzZXRQYXJlbnQpID8gZ2V0V2luZG93KG9mZnNldFBhcmVudCkgOiBvZmZzZXRQYXJlbnQ7XG4gICAgbGV0IGN1cnJlbnRJRnJhbWUgPSB3aW4uZnJhbWVFbGVtZW50O1xuICAgIHdoaWxlIChjdXJyZW50SUZyYW1lICYmIG9mZnNldFBhcmVudCAmJiBvZmZzZXRXaW4gIT09IHdpbikge1xuICAgICAgY29uc3QgaWZyYW1lU2NhbGUgPSBnZXRTY2FsZShjdXJyZW50SUZyYW1lKTtcbiAgICAgIGNvbnN0IGlmcmFtZVJlY3QgPSBjdXJyZW50SUZyYW1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50SUZyYW1lKTtcbiAgICAgIGNvbnN0IGxlZnQgPSBpZnJhbWVSZWN0LmxlZnQgKyAoY3VycmVudElGcmFtZS5jbGllbnRMZWZ0ICsgcGFyc2VGbG9hdChjc3MucGFkZGluZ0xlZnQpKSAqIGlmcmFtZVNjYWxlLng7XG4gICAgICBjb25zdCB0b3AgPSBpZnJhbWVSZWN0LnRvcCArIChjdXJyZW50SUZyYW1lLmNsaWVudFRvcCArIHBhcnNlRmxvYXQoY3NzLnBhZGRpbmdUb3ApKSAqIGlmcmFtZVNjYWxlLnk7XG4gICAgICB4ICo9IGlmcmFtZVNjYWxlLng7XG4gICAgICB5ICo9IGlmcmFtZVNjYWxlLnk7XG4gICAgICB3aWR0aCAqPSBpZnJhbWVTY2FsZS54O1xuICAgICAgaGVpZ2h0ICo9IGlmcmFtZVNjYWxlLnk7XG4gICAgICB4ICs9IGxlZnQ7XG4gICAgICB5ICs9IHRvcDtcbiAgICAgIGN1cnJlbnRJRnJhbWUgPSBnZXRXaW5kb3coY3VycmVudElGcmFtZSkuZnJhbWVFbGVtZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVjdFRvQ2xpZW50UmVjdCh7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QoX3JlZikge1xuICBsZXQge1xuICAgIHJlY3QsXG4gICAgb2Zmc2V0UGFyZW50LFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBfcmVmO1xuICBjb25zdCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGlmIChvZmZzZXRQYXJlbnQgPT09IGRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiByZWN0O1xuICB9XG4gIGxldCBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgbGV0IHNjYWxlID0gY3JlYXRlQ29vcmRzKDEpO1xuICBjb25zdCBvZmZzZXRzID0gY3JlYXRlQ29vcmRzKDApO1xuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmIHN0cmF0ZWd5ICE9PSAnZml4ZWQnKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcbiAgICAgIHNjYWxlID0gZ2V0U2NhbGUob2Zmc2V0UGFyZW50KTtcbiAgICAgIG9mZnNldHMueCA9IG9mZnNldFJlY3QueCArIG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ID0gb2Zmc2V0UmVjdC55ICsgb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCAqIHNjYWxlLngsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCAqIHNjYWxlLnksXG4gICAgeDogcmVjdC54ICogc2NhbGUueCAtIHNjcm9sbC5zY3JvbGxMZWZ0ICogc2NhbGUueCArIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnkgKiBzY2FsZS55IC0gc2Nyb2xsLnNjcm9sbFRvcCAqIHNjYWxlLnkgKyBvZmZzZXRzLnlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdHMoZWxlbWVudCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmdldENsaWVudFJlY3RzKCkpO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59XG5cbi8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGUuXG5mdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpO1xuICBjb25zdCBib2R5ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkuc2Nyb2xsV2lkdGgsIGJvZHkuY2xpZW50V2lkdGgpO1xuICBjb25zdCBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5LnNjcm9sbEhlaWdodCwgYm9keS5jbGllbnRIZWlnaHQpO1xuICBsZXQgeCA9IC1zY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIGNvbnN0IHkgPSAtc2Nyb2xsLnNjcm9sbFRvcDtcbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkuY2xpZW50V2lkdGgpIC0gd2lkdGg7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICBsZXQgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICBsZXQgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XG4gIGxldCB4ID0gMDtcbiAgbGV0IHkgPSAwO1xuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICBjb25zdCB2aXN1YWxWaWV3cG9ydEJhc2VkID0gaXNXZWJLaXQoKTtcbiAgICBpZiAoIXZpc3VhbFZpZXdwb3J0QmFzZWQgfHwgdmlzdWFsVmlld3BvcnRCYXNlZCAmJiBzdHJhdGVneSA9PT0gJ2ZpeGVkJykge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuLy8gUmV0dXJucyB0aGUgaW5uZXIgY2xpZW50IHJlY3QsIHN1YnRyYWN0aW5nIHNjcm9sbGJhcnMgaWYgcHJlc2VudC5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgc3RyYXRlZ3kgPT09ICdmaXhlZCcpO1xuICBjb25zdCB0b3AgPSBjbGllbnRSZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xuICBjb25zdCBsZWZ0ID0gY2xpZW50UmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICBjb25zdCBzY2FsZSA9IGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRTY2FsZShlbGVtZW50KSA6IGNyZWF0ZUNvb3JkcygxKTtcbiAgY29uc3Qgd2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoICogc2NhbGUueDtcbiAgY29uc3QgaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQgKiBzY2FsZS55O1xuICBjb25zdCB4ID0gbGVmdCAqIHNjYWxlLng7XG4gIGNvbnN0IHkgPSB0b3AgKiBzY2FsZS55O1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkge1xuICBsZXQgcmVjdDtcbiAgaWYgKGNsaXBwaW5nQW5jZXN0b3IgPT09ICd2aWV3cG9ydCcpIHtcbiAgICByZWN0ID0gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KTtcbiAgfSBlbHNlIGlmIChjbGlwcGluZ0FuY2VzdG9yID09PSAnZG9jdW1lbnQnKSB7XG4gICAgcmVjdCA9IGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpO1xuICB9IGVsc2UgaWYgKGlzRWxlbWVudChjbGlwcGluZ0FuY2VzdG9yKSkge1xuICAgIHJlY3QgPSBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdmlzdWFsT2Zmc2V0cyA9IGdldFZpc3VhbE9mZnNldHMoZWxlbWVudCk7XG4gICAgcmVjdCA9IHtcbiAgICAgIC4uLmNsaXBwaW5nQW5jZXN0b3IsXG4gICAgICB4OiBjbGlwcGluZ0FuY2VzdG9yLnggLSB2aXN1YWxPZmZzZXRzLngsXG4gICAgICB5OiBjbGlwcGluZ0FuY2VzdG9yLnkgLSB2aXN1YWxPZmZzZXRzLnlcbiAgICB9O1xuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHJlY3QpO1xufVxuZnVuY3Rpb24gaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKGVsZW1lbnQsIHN0b3BOb2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICBpZiAocGFyZW50Tm9kZSA9PT0gc3RvcE5vZGUgfHwgIWlzRWxlbWVudChwYXJlbnROb2RlKSB8fCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUocGFyZW50Tm9kZSkucG9zaXRpb24gPT09ICdmaXhlZCcgfHwgaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKHBhcmVudE5vZGUsIHN0b3BOb2RlKTtcbn1cblxuLy8gQSBcImNsaXBwaW5nIGFuY2VzdG9yXCIgaXMgYW4gYG92ZXJmbG93YCBlbGVtZW50IHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBjaGlsZCBlbGVtZW50cy4gVGhpcyByZXR1cm5zIGFsbCBjbGlwcGluZyBhbmNlc3RvcnNcbi8vIG9mIHRoZSBnaXZlbiBlbGVtZW50IHVwIHRoZSB0cmVlLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzKGVsZW1lbnQsIGNhY2hlKSB7XG4gIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGNhY2hlLmdldChlbGVtZW50KTtcbiAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IGdldE92ZXJmbG93QW5jZXN0b3JzKGVsZW1lbnQsIFtdLCBmYWxzZSkuZmlsdGVyKGVsID0+IGlzRWxlbWVudChlbCkgJiYgZ2V0Tm9kZU5hbWUoZWwpICE9PSAnYm9keScpO1xuICBsZXQgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBudWxsO1xuICBjb25zdCBlbGVtZW50SXNGaXhlZCA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCc7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcbiAgd2hpbGUgKGlzRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7XG4gICAgY29uc3QgY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgPSBpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSk7XG4gICAgaWYgKCFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZERyb3BDdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmICFjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA6ICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJyAmJiAhIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlICYmIFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmNsdWRlcyhjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZS5wb3NpdGlvbikgfHwgaXNPdmVyZmxvd0VsZW1lbnQoY3VycmVudE5vZGUpICYmICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IoZWxlbWVudCwgY3VycmVudE5vZGUpO1xuICAgIGlmIChzaG91bGREcm9wQ3VycmVudE5vZGUpIHtcbiAgICAgIC8vIERyb3Agbm9uLWNvbnRhaW5pbmcgYmxvY2tzLlxuICAgICAgcmVzdWx0ID0gcmVzdWx0LmZpbHRlcihhbmNlc3RvciA9PiBhbmNlc3RvciAhPT0gY3VycmVudE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWNvcmQgbGFzdCBjb250YWluaW5nIGJsb2NrIGZvciBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgIGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgfVxuICBjYWNoZS5zZXQoZWxlbWVudCwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgYW5jZXN0b3JzLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50LFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgZWxlbWVudENsaXBwaW5nQW5jZXN0b3JzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ0FuY2VzdG9ycycgPyBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgdGhpcy5fYykgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICBjb25zdCBjbGlwcGluZ0FuY2VzdG9ycyA9IFsuLi5lbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMsIHJvb3RCb3VuZGFyeV07XG4gIGNvbnN0IGZpcnN0Q2xpcHBpbmdBbmNlc3RvciA9IGNsaXBwaW5nQW5jZXN0b3JzWzBdO1xuICBjb25zdCBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ0FuY2VzdG9ycy5yZWR1Y2UoKGFjY1JlY3QsIGNsaXBwaW5nQW5jZXN0b3IpID0+IHtcbiAgICBjb25zdCByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgZmlyc3RDbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdCxcbiAgICBoZWlnaHQ6IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wLFxuICAgIHg6IGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIHk6IGNsaXBwaW5nUmVjdC50b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIHJldHVybiBnZXRDc3NEaW1lbnNpb25zKGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudChlbGVtZW50LCBvZmZzZXRQYXJlbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgaXNGaXhlZCA9IHN0cmF0ZWd5ID09PSAnZml4ZWQnO1xuICBjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHRydWUsIGlzRml4ZWQsIG9mZnNldFBhcmVudCk7XG4gIGxldCBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgY29uc3Qgb2Zmc2V0cyA9IGNyZWF0ZUNvb3JkcygwKTtcbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgaXNPdmVyZmxvd0VsZW1lbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlLCBpc0ZpeGVkLCBvZmZzZXRQYXJlbnQpO1xuICAgICAgb2Zmc2V0cy54ID0gb2Zmc2V0UmVjdC54ICsgb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgPSBvZmZzZXRSZWN0LnkgKyBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwb2x5ZmlsbCkge1xuICAgIHJldHVybiBwb2x5ZmlsbChlbGVtZW50KTtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59XG5cbi8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCwgcG9seWZpbGwpIHtcbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIGxldCBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKTtcbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCwgcG9seWZpbGwpO1xuICB9XG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fCBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJyAmJiAhaXNDb250YWluaW5nQmxvY2sob2Zmc2V0UGFyZW50KSkpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn1cblxuY29uc3QgZ2V0RWxlbWVudFJlY3RzID0gYXN5bmMgZnVuY3Rpb24gKF9yZWYpIHtcbiAgbGV0IHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmcsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGdldE9mZnNldFBhcmVudEZuID0gdGhpcy5nZXRPZmZzZXRQYXJlbnQgfHwgZ2V0T2Zmc2V0UGFyZW50O1xuICBjb25zdCBnZXREaW1lbnNpb25zRm4gPSB0aGlzLmdldERpbWVuc2lvbnM7XG4gIHJldHVybiB7XG4gICAgcmVmZXJlbmNlOiBnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudChyZWZlcmVuY2UsIGF3YWl0IGdldE9mZnNldFBhcmVudEZuKGZsb2F0aW5nKSwgc3RyYXRlZ3kpLFxuICAgIGZsb2F0aW5nOiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIC4uLihhd2FpdCBnZXREaW1lbnNpb25zRm4oZmxvYXRpbmcpKVxuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGlzUlRMKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZGlyZWN0aW9uID09PSAncnRsJztcbn1cblxuY29uc3QgcGxhdGZvcm0gPSB7XG4gIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0LFxuICBnZXREb2N1bWVudEVsZW1lbnQsXG4gIGdldENsaXBwaW5nUmVjdCxcbiAgZ2V0T2Zmc2V0UGFyZW50LFxuICBnZXRFbGVtZW50UmVjdHMsXG4gIGdldENsaWVudFJlY3RzLFxuICBnZXREaW1lbnNpb25zLFxuICBnZXRTY2FsZSxcbiAgaXNFbGVtZW50LFxuICBpc1JUTFxufTtcblxuLy8gaHR0cHM6Ly9zYW10aG9yLmF1LzIwMjEvb2JzZXJ2aW5nLWRvbS9cbmZ1bmN0aW9uIG9ic2VydmVNb3ZlKGVsZW1lbnQsIG9uTW92ZSkge1xuICBsZXQgaW8gPSBudWxsO1xuICBsZXQgdGltZW91dElkO1xuICBjb25zdCByb290ID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIGlvICYmIGlvLmRpc2Nvbm5lY3QoKTtcbiAgICBpbyA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gcmVmcmVzaChza2lwLCB0aHJlc2hvbGQpIHtcbiAgICBpZiAoc2tpcCA9PT0gdm9pZCAwKSB7XG4gICAgICBza2lwID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aHJlc2hvbGQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyZXNob2xkID0gMTtcbiAgICB9XG4gICAgY2xlYW51cCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQsXG4gICAgICB0b3AsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmICghc2tpcCkge1xuICAgICAgb25Nb3ZlKCk7XG4gICAgfVxuICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbnNldFRvcCA9IGZsb29yKHRvcCk7XG4gICAgY29uc3QgaW5zZXRSaWdodCA9IGZsb29yKHJvb3QuY2xpZW50V2lkdGggLSAobGVmdCArIHdpZHRoKSk7XG4gICAgY29uc3QgaW5zZXRCb3R0b20gPSBmbG9vcihyb290LmNsaWVudEhlaWdodCAtICh0b3AgKyBoZWlnaHQpKTtcbiAgICBjb25zdCBpbnNldExlZnQgPSBmbG9vcihsZWZ0KTtcbiAgICBjb25zdCByb290TWFyZ2luID0gLWluc2V0VG9wICsgXCJweCBcIiArIC1pbnNldFJpZ2h0ICsgXCJweCBcIiArIC1pbnNldEJvdHRvbSArIFwicHggXCIgKyAtaW5zZXRMZWZ0ICsgXCJweFwiO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICByb290TWFyZ2luLFxuICAgICAgdGhyZXNob2xkOiBtYXgoMCwgbWluKDEsIHRocmVzaG9sZCkpIHx8IDFcbiAgICB9O1xuICAgIGxldCBpc0ZpcnN0VXBkYXRlID0gdHJ1ZTtcbiAgICBmdW5jdGlvbiBoYW5kbGVPYnNlcnZlKGVudHJpZXMpIHtcbiAgICAgIGNvbnN0IHJhdGlvID0gZW50cmllc1swXS5pbnRlcnNlY3Rpb25SYXRpbztcbiAgICAgIGlmIChyYXRpbyAhPT0gdGhyZXNob2xkKSB7XG4gICAgICAgIGlmICghaXNGaXJzdFVwZGF0ZSkge1xuICAgICAgICAgIHJldHVybiByZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyYXRpbykge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVmcmVzaChmYWxzZSwgMWUtNyk7XG4gICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZyZXNoKGZhbHNlLCByYXRpbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlzRmlyc3RVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBPbGRlciBicm93c2VycyBkb24ndCBzdXBwb3J0IGEgYGRvY3VtZW50YCBhcyB0aGUgcm9vdCBhbmQgd2lsbCB0aHJvdyBhblxuICAgIC8vIGVycm9yLlxuICAgIHRyeSB7XG4gICAgICBpbyA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihoYW5kbGVPYnNlcnZlLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIC8vIEhhbmRsZSA8aWZyYW1lPnNcbiAgICAgICAgcm9vdDogcm9vdC5vd25lckRvY3VtZW50XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpbyA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihoYW5kbGVPYnNlcnZlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaW8ub2JzZXJ2ZShlbGVtZW50KTtcbiAgfVxuICByZWZyZXNoKHRydWUpO1xuICByZXR1cm4gY2xlYW51cDtcbn1cblxuLyoqXG4gKiBBdXRvbWF0aWNhbGx5IHVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHdoZW4gbmVjZXNzYXJ5LlxuICogU2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgbW91bnRlZCBvbiB0aGUgRE9NIG9yXG4gKiB2aXNpYmxlIG9uIHRoZSBzY3JlZW4uXG4gKiBAcmV0dXJucyBjbGVhbnVwIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGludm9rZWQgd2hlbiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpc1xuICogcmVtb3ZlZCBmcm9tIHRoZSBET00gb3IgaGlkZGVuIGZyb20gdGhlIHNjcmVlbi5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvVXBkYXRlXG4gKi9cbmZ1bmN0aW9uIGF1dG9VcGRhdGUocmVmZXJlbmNlLCBmbG9hdGluZywgdXBkYXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGFuY2VzdG9yU2Nyb2xsID0gdHJ1ZSxcbiAgICBhbmNlc3RvclJlc2l6ZSA9IHRydWUsXG4gICAgZWxlbWVudFJlc2l6ZSA9IHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBsYXlvdXRTaGlmdCA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBhbmltYXRpb25GcmFtZSA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCByZWZlcmVuY2VFbCA9IHVud3JhcEVsZW1lbnQocmVmZXJlbmNlKTtcbiAgY29uc3QgYW5jZXN0b3JzID0gYW5jZXN0b3JTY3JvbGwgfHwgYW5jZXN0b3JSZXNpemUgPyBbLi4uKHJlZmVyZW5jZUVsID8gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMocmVmZXJlbmNlRWwpIDogW10pLCAuLi5nZXRPdmVyZmxvd0FuY2VzdG9ycyhmbG9hdGluZyldIDogW107XG4gIGFuY2VzdG9ycy5mb3JFYWNoKGFuY2VzdG9yID0+IHtcbiAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGUsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBhbmNlc3RvclJlc2l6ZSAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGUpO1xuICB9KTtcbiAgY29uc3QgY2xlYW51cElvID0gcmVmZXJlbmNlRWwgJiYgbGF5b3V0U2hpZnQgPyBvYnNlcnZlTW92ZShyZWZlcmVuY2VFbCwgdXBkYXRlKSA6IG51bGw7XG4gIGxldCByZW9ic2VydmVGcmFtZSA9IC0xO1xuICBsZXQgcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICBpZiAoZWxlbWVudFJlc2l6ZSkge1xuICAgIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKF9yZWYgPT4ge1xuICAgICAgbGV0IFtmaXJzdEVudHJ5XSA9IF9yZWY7XG4gICAgICBpZiAoZmlyc3RFbnRyeSAmJiBmaXJzdEVudHJ5LnRhcmdldCA9PT0gcmVmZXJlbmNlRWwgJiYgcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgLy8gUHJldmVudCB1cGRhdGUgbG9vcHMgd2hlbiB1c2luZyB0aGUgYHNpemVgIG1pZGRsZXdhcmUuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMTc0MFxuICAgICAgICByZXNpemVPYnNlcnZlci51bm9ic2VydmUoZmxvYXRpbmcpO1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyZW9ic2VydmVGcmFtZSk7XG4gICAgICAgIHJlb2JzZXJ2ZUZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICByZXNpemVPYnNlcnZlciAmJiByZXNpemVPYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB1cGRhdGUoKTtcbiAgICB9KTtcbiAgICBpZiAocmVmZXJlbmNlRWwgJiYgIWFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHJlZmVyZW5jZUVsKTtcbiAgICB9XG4gICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShmbG9hdGluZyk7XG4gIH1cbiAgbGV0IGZyYW1lSWQ7XG4gIGxldCBwcmV2UmVmUmVjdCA9IGFuaW1hdGlvbkZyYW1lID8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZSkgOiBudWxsO1xuICBpZiAoYW5pbWF0aW9uRnJhbWUpIHtcbiAgICBmcmFtZUxvb3AoKTtcbiAgfVxuICBmdW5jdGlvbiBmcmFtZUxvb3AoKSB7XG4gICAgY29uc3QgbmV4dFJlZlJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKTtcbiAgICBpZiAocHJldlJlZlJlY3QgJiYgKG5leHRSZWZSZWN0LnggIT09IHByZXZSZWZSZWN0LnggfHwgbmV4dFJlZlJlY3QueSAhPT0gcHJldlJlZlJlY3QueSB8fCBuZXh0UmVmUmVjdC53aWR0aCAhPT0gcHJldlJlZlJlY3Qud2lkdGggfHwgbmV4dFJlZlJlY3QuaGVpZ2h0ICE9PSBwcmV2UmVmUmVjdC5oZWlnaHQpKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gICAgcHJldlJlZlJlY3QgPSBuZXh0UmVmUmVjdDtcbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lTG9vcCk7XG4gIH1cbiAgdXBkYXRlKCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlKTtcbiAgICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSk7XG4gICAgfSk7XG4gICAgY2xlYW51cElvICYmIGNsZWFudXBJbygpO1xuICAgIHJlc2l6ZU9ic2VydmVyICYmIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIHJlZmVyZW5jZSBlbGVtZW50IHdoZW4gaXQgaXMgZ2l2ZW4gYSBjZXJ0YWluIENTUyBwb3NpdGlvbmluZ1xuICogc3RyYXRlZ3kuXG4gKi9cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IChyZWZlcmVuY2UsIGZsb2F0aW5nLCBvcHRpb25zKSA9PiB7XG4gIC8vIFRoaXMgY2FjaGVzIHRoZSBleHBlbnNpdmUgYGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9yc2AgZnVuY3Rpb24gc28gdGhhdFxuICAvLyBtdWx0aXBsZSBsaWZlY3ljbGUgcmVzZXRzIHJlLXVzZSB0aGUgc2FtZSByZXN1bHQuIEl0IG9ubHkgbGl2ZXMgZm9yIGFcbiAgLy8gc2luZ2xlIGNhbGwuIElmIG90aGVyIGZ1bmN0aW9ucyBiZWNvbWUgZXhwZW5zaXZlLCB3ZSBjYW4gYWRkIHRoZW0gYXMgd2VsbC5cbiAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB7XG4gICAgcGxhdGZvcm0sXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBwbGF0Zm9ybVdpdGhDYWNoZSA9IHtcbiAgICAuLi5tZXJnZWRPcHRpb25zLnBsYXRmb3JtLFxuICAgIF9jOiBjYWNoZVxuICB9O1xuICByZXR1cm4gY29tcHV0ZVBvc2l0aW9uJDEocmVmZXJlbmNlLCBmbG9hdGluZywge1xuICAgIC4uLm1lcmdlZE9wdGlvbnMsXG4gICAgcGxhdGZvcm06IHBsYXRmb3JtV2l0aENhY2hlXG4gIH0pO1xufTtcblxuZXhwb3J0IHsgYXV0b1VwZGF0ZSwgY29tcHV0ZVBvc2l0aW9uLCBwbGF0Zm9ybSB9O1xuIl0sIm5hbWVzIjpbInJlY3RUb0NsaWVudFJlY3QiLCJjb21wdXRlUG9zaXRpb24iLCJjb21wdXRlUG9zaXRpb24kMSIsImFycm93IiwiYXV0b1BsYWNlbWVudCIsImRldGVjdE92ZXJmbG93IiwiZmxpcCIsImhpZGUiLCJpbmxpbmUiLCJsaW1pdFNoaWZ0Iiwib2Zmc2V0Iiwic2hpZnQiLCJzaXplIiwicm91bmQiLCJjcmVhdGVDb29yZHMiLCJtYXgiLCJtaW4iLCJmbG9vciIsImdldENvbXB1dGVkU3R5bGUiLCJpc0hUTUxFbGVtZW50IiwiaXNFbGVtZW50IiwiZ2V0V2luZG93IiwiaXNXZWJLaXQiLCJnZXREb2N1bWVudEVsZW1lbnQiLCJnZXROb2RlTmFtZSIsImlzT3ZlcmZsb3dFbGVtZW50IiwiZ2V0Tm9kZVNjcm9sbCIsImdldE92ZXJmbG93QW5jZXN0b3JzIiwiZ2V0UGFyZW50Tm9kZSIsImlzTGFzdFRyYXZlcnNhYmxlTm9kZSIsImlzQ29udGFpbmluZ0Jsb2NrIiwiaXNUYWJsZUVsZW1lbnQiLCJnZXRDb250YWluaW5nQmxvY2siLCJnZXRDc3NEaW1lbnNpb25zIiwiZWxlbWVudCIsImNzcyIsIndpZHRoIiwicGFyc2VGbG9hdCIsImhlaWdodCIsImhhc09mZnNldCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0Iiwic2hvdWxkRmFsbGJhY2siLCIkIiwidW53cmFwRWxlbWVudCIsImNvbnRleHRFbGVtZW50IiwiZ2V0U2NhbGUiLCJkb21FbGVtZW50IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIngiLCJ5IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJub09mZnNldHMiLCJnZXRWaXN1YWxPZmZzZXRzIiwid2luIiwidmlzdWFsVmlld3BvcnQiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwic2hvdWxkQWRkVmlzdWFsT2Zmc2V0cyIsImlzRml4ZWQiLCJmbG9hdGluZ09mZnNldFBhcmVudCIsImluY2x1ZGVTY2FsZSIsImlzRml4ZWRTdHJhdGVneSIsIm9mZnNldFBhcmVudCIsImNsaWVudFJlY3QiLCJzY2FsZSIsInZpc3VhbE9mZnNldHMiLCJsZWZ0IiwidG9wIiwib2Zmc2V0V2luIiwiY3VycmVudElGcmFtZSIsImZyYW1lRWxlbWVudCIsImlmcmFtZVNjYWxlIiwiaWZyYW1lUmVjdCIsImNsaWVudExlZnQiLCJwYWRkaW5nTGVmdCIsImNsaWVudFRvcCIsInBhZGRpbmdUb3AiLCJjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCIsIl9yZWYiLCJzdHJhdGVneSIsImlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IiwiZG9jdW1lbnRFbGVtZW50Iiwic2Nyb2xsIiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsIm9mZnNldHMiLCJvZmZzZXRSZWN0IiwiZ2V0Q2xpZW50UmVjdHMiLCJBcnJheSIsImZyb20iLCJnZXRXaW5kb3dTY3JvbGxCYXJYIiwiZ2V0RG9jdW1lbnRSZWN0IiwiaHRtbCIsImJvZHkiLCJvd25lckRvY3VtZW50Iiwic2Nyb2xsV2lkdGgiLCJjbGllbnRXaWR0aCIsInNjcm9sbEhlaWdodCIsImNsaWVudEhlaWdodCIsImRpcmVjdGlvbiIsImdldFZpZXdwb3J0UmVjdCIsInZpc3VhbFZpZXdwb3J0QmFzZWQiLCJnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdCIsImdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvciIsImNsaXBwaW5nQW5jZXN0b3IiLCJoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IiLCJzdG9wTm9kZSIsInBhcmVudE5vZGUiLCJwb3NpdGlvbiIsImdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9ycyIsImNhY2hlIiwiY2FjaGVkUmVzdWx0IiwiZ2V0IiwicmVzdWx0IiwiZmlsdGVyIiwiZWwiLCJjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSIsImVsZW1lbnRJc0ZpeGVkIiwiY3VycmVudE5vZGUiLCJjb21wdXRlZFN0eWxlIiwiY3VycmVudE5vZGVJc0NvbnRhaW5pbmciLCJzaG91bGREcm9wQ3VycmVudE5vZGUiLCJpbmNsdWRlcyIsImFuY2VzdG9yIiwic2V0IiwiZ2V0Q2xpcHBpbmdSZWN0IiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJlbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMiLCJfYyIsImNvbmNhdCIsImNsaXBwaW5nQW5jZXN0b3JzIiwiZmlyc3RDbGlwcGluZ0FuY2VzdG9yIiwiY2xpcHBpbmdSZWN0IiwicmVkdWNlIiwiYWNjUmVjdCIsInJpZ2h0IiwiYm90dG9tIiwiZ2V0RGltZW5zaW9ucyIsImdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50IiwiZ2V0VHJ1ZU9mZnNldFBhcmVudCIsInBvbHlmaWxsIiwiZ2V0T2Zmc2V0UGFyZW50Iiwid2luZG93IiwiZ2V0RWxlbWVudFJlY3RzIiwicmVmZXJlbmNlIiwiZmxvYXRpbmciLCJnZXRPZmZzZXRQYXJlbnRGbiIsImdldERpbWVuc2lvbnNGbiIsImlzUlRMIiwicGxhdGZvcm0iLCJvYnNlcnZlTW92ZSIsIm9uTW92ZSIsImlvIiwidGltZW91dElkIiwicm9vdCIsImNsZWFudXAiLCJjbGVhclRpbWVvdXQiLCJkaXNjb25uZWN0IiwicmVmcmVzaCIsInNraXAiLCJ0aHJlc2hvbGQiLCJpbnNldFRvcCIsImluc2V0UmlnaHQiLCJpbnNldEJvdHRvbSIsImluc2V0TGVmdCIsInJvb3RNYXJnaW4iLCJvcHRpb25zIiwiaXNGaXJzdFVwZGF0ZSIsImhhbmRsZU9ic2VydmUiLCJlbnRyaWVzIiwicmF0aW8iLCJpbnRlcnNlY3Rpb25SYXRpbyIsInNldFRpbWVvdXQiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsImUiLCJvYnNlcnZlIiwiYXV0b1VwZGF0ZSIsInVwZGF0ZSIsImFuY2VzdG9yU2Nyb2xsIiwiYW5jZXN0b3JSZXNpemUiLCJlbGVtZW50UmVzaXplIiwiUmVzaXplT2JzZXJ2ZXIiLCJsYXlvdXRTaGlmdCIsImFuaW1hdGlvbkZyYW1lIiwicmVmZXJlbmNlRWwiLCJhbmNlc3RvcnMiLCJmb3JFYWNoIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJjbGVhbnVwSW8iLCJyZW9ic2VydmVGcmFtZSIsInJlc2l6ZU9ic2VydmVyIiwiZmlyc3RFbnRyeSIsInRhcmdldCIsInVub2JzZXJ2ZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZnJhbWVJZCIsInByZXZSZWZSZWN0IiwiZnJhbWVMb29wIiwibmV4dFJlZlJlY3QiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiTWFwIiwibWVyZ2VkT3B0aW9ucyIsInBsYXRmb3JtV2l0aENhY2hlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.inline),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.platform),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.size),\n/* harmony export */   useFloating: () => (/* binding */ useFloating)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\n\n\n\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = (options)=>{\n    function isRef(value) {\n        return ({}).hasOwnProperty.call(value, \"current\");\n    }\n    return {\n        name: \"arrow\",\n        options,\n        fn (state) {\n            const { element, padding } = typeof options === \"function\" ? options(state) : options;\n            if (element && isRef(element)) {\n                if (element.current != null) {\n                    return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n                        element: element.current,\n                        padding\n                    }).fn(state);\n                }\n                return {};\n            } else if (element) {\n                return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n                    element,\n                    padding\n                }).fn(state);\n            }\n            return {};\n        }\n    };\n};\nvar index = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_3__.useEffect;\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (typeof a !== typeof b) {\n        return false;\n    }\n    if (typeof a === \"function\" && a.toString() === b.toString()) {\n        return true;\n    }\n    let length, i, keys;\n    if (a && b && typeof a == \"object\") {\n        if (Array.isArray(a)) {\n            length = a.length;\n            if (length != b.length) return false;\n            for(i = length; i-- !== 0;){\n                if (!deepEqual(a[i], b[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) {\n            return false;\n        }\n        for(i = length; i-- !== 0;){\n            if (!({}).hasOwnProperty.call(b, keys[i])) {\n                return false;\n            }\n        }\n        for(i = length; i-- !== 0;){\n            const key = keys[i];\n            if (key === \"_owner\" && a.$$typeof) {\n                continue;\n            }\n            if (!deepEqual(a[key], b[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return a !== a && b !== b;\n}\nfunction getDPR(element) {\n    if (true) {\n        return 1;\n    }\n    const win = element.ownerDocument.defaultView || window;\n    return win.devicePixelRatio || 1;\n}\nfunction roundByDPR(element, value) {\n    const dpr = getDPR(element);\n    return Math.round(value * dpr) / dpr;\n}\nfunction useLatestRef(value) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_3__.useRef(value);\n    index(()=>{\n        ref.current = value;\n    });\n    return ref;\n}\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/useFloating\n */ function useFloating(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { placement = \"bottom\", strategy = \"absolute\", middleware = [], platform, elements: { reference: externalReference, floating: externalFloating } = {}, transform = true, whileElementsMounted, open } = options;\n    const [data, setData] = react__WEBPACK_IMPORTED_MODULE_3__.useState({\n        x: 0,\n        y: 0,\n        strategy,\n        placement,\n        middlewareData: {},\n        isPositioned: false\n    });\n    const [latestMiddleware, setLatestMiddleware] = react__WEBPACK_IMPORTED_MODULE_3__.useState(middleware);\n    if (!deepEqual(latestMiddleware, middleware)) {\n        setLatestMiddleware(middleware);\n    }\n    const [_reference, _setReference] = react__WEBPACK_IMPORTED_MODULE_3__.useState(null);\n    const [_floating, _setFloating] = react__WEBPACK_IMPORTED_MODULE_3__.useState(null);\n    const setReference = react__WEBPACK_IMPORTED_MODULE_3__.useCallback((node)=>{\n        if (node != referenceRef.current) {\n            referenceRef.current = node;\n            _setReference(node);\n        }\n    }, [\n        _setReference\n    ]);\n    const setFloating = react__WEBPACK_IMPORTED_MODULE_3__.useCallback((node)=>{\n        if (node !== floatingRef.current) {\n            floatingRef.current = node;\n            _setFloating(node);\n        }\n    }, [\n        _setFloating\n    ]);\n    const referenceEl = externalReference || _reference;\n    const floatingEl = externalFloating || _floating;\n    const referenceRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(null);\n    const floatingRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(null);\n    const dataRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(data);\n    const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n    const platformRef = useLatestRef(platform);\n    const update = react__WEBPACK_IMPORTED_MODULE_3__.useCallback(()=>{\n        if (!referenceRef.current || !floatingRef.current) {\n            return;\n        }\n        const config = {\n            placement,\n            strategy,\n            middleware: latestMiddleware\n        };\n        if (platformRef.current) {\n            config.platform = platformRef.current;\n        }\n        (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.computePosition)(referenceRef.current, floatingRef.current, config).then((data)=>{\n            const fullData = {\n                ...data,\n                isPositioned: true\n            };\n            if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n                dataRef.current = fullData;\n                react_dom__WEBPACK_IMPORTED_MODULE_4__.flushSync(()=>{\n                    setData(fullData);\n                });\n            }\n        });\n    }, [\n        latestMiddleware,\n        placement,\n        strategy,\n        platformRef\n    ]);\n    index(()=>{\n        if (open === false && dataRef.current.isPositioned) {\n            dataRef.current.isPositioned = false;\n            setData((data)=>({\n                    ...data,\n                    isPositioned: false\n                }));\n        }\n    }, [\n        open\n    ]);\n    const isMountedRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(false);\n    index(()=>{\n        isMountedRef.current = true;\n        return ()=>{\n            isMountedRef.current = false;\n        };\n    }, []);\n    index(()=>{\n        if (referenceEl) referenceRef.current = referenceEl;\n        if (floatingEl) floatingRef.current = floatingEl;\n        if (referenceEl && floatingEl) {\n            if (whileElementsMountedRef.current) {\n                return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n            } else {\n                update();\n            }\n        }\n    }, [\n        referenceEl,\n        floatingEl,\n        update,\n        whileElementsMountedRef\n    ]);\n    const refs = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>({\n            reference: referenceRef,\n            floating: floatingRef,\n            setReference,\n            setFloating\n        }), [\n        setReference,\n        setFloating\n    ]);\n    const elements = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>({\n            reference: referenceEl,\n            floating: floatingEl\n        }), [\n        referenceEl,\n        floatingEl\n    ]);\n    const floatingStyles = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>{\n        const initialStyles = {\n            position: strategy,\n            left: 0,\n            top: 0\n        };\n        if (!elements.floating) {\n            return initialStyles;\n        }\n        const x = roundByDPR(elements.floating, data.x);\n        const y = roundByDPR(elements.floating, data.y);\n        if (transform) {\n            return {\n                ...initialStyles,\n                transform: \"translate(\" + x + \"px, \" + y + \"px)\",\n                ...getDPR(elements.floating) >= 1.5 && {\n                    willChange: \"transform\"\n                }\n            };\n        }\n        return {\n            position: strategy,\n            left: x,\n            top: y\n        };\n    }, [\n        strategy,\n        transform,\n        elements.floating,\n        data.x,\n        data.y\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>({\n            ...data,\n            update,\n            refs,\n            elements,\n            floatingStyles\n        }), [\n        data,\n        update,\n        refs,\n        elements,\n        floatingStyles\n    ]);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0LWRvbS9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LWRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUU7QUFDOEc7QUFDcEo7QUFDb0I7QUFDYjtBQUV0Qzs7Ozs7Q0FLQyxHQUNELE1BQU1BLFFBQVFtQixDQUFBQTtJQUNaLFNBQVNDLE1BQU1DLEtBQUs7UUFDbEIsT0FBTyxFQUFDLEdBQUVDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDRixPQUFPO0lBQ3ZDO0lBQ0EsT0FBTztRQUNMRyxNQUFNO1FBQ05MO1FBQ0FNLElBQUdDLEtBQUs7WUFDTixNQUFNLEVBQ0pDLE9BQU8sRUFDUEMsT0FBTyxFQUNSLEdBQUcsT0FBT1QsWUFBWSxhQUFhQSxRQUFRTyxTQUFTUDtZQUNyRCxJQUFJUSxXQUFXUCxNQUFNTyxVQUFVO2dCQUM3QixJQUFJQSxRQUFRRSxPQUFPLElBQUksTUFBTTtvQkFDM0IsT0FBTzVCLHVEQUFPQSxDQUFDO3dCQUNiMEIsU0FBU0EsUUFBUUUsT0FBTzt3QkFDeEJEO29CQUNGLEdBQUdILEVBQUUsQ0FBQ0M7Z0JBQ1I7Z0JBQ0EsT0FBTyxDQUFDO1lBQ1YsT0FBTyxJQUFJQyxTQUFTO2dCQUNsQixPQUFPMUIsdURBQU9BLENBQUM7b0JBQ2IwQjtvQkFDQUM7Z0JBQ0YsR0FBR0gsRUFBRSxDQUFDQztZQUNSO1lBQ0EsT0FBTyxDQUFDO1FBQ1Y7SUFDRjtBQUNGO0FBRUEsSUFBSUksUUFBUSxPQUFPQyxhQUFhLGNBQWNmLGtEQUFlQSxHQUFHQyw0Q0FBU0E7QUFFekUsZ0ZBQWdGO0FBQ2hGLFlBQVk7QUFDWixTQUFTZSxVQUFVQyxDQUFDLEVBQUVDLENBQUM7SUFDckIsSUFBSUQsTUFBTUMsR0FBRztRQUNYLE9BQU87SUFDVDtJQUNBLElBQUksT0FBT0QsTUFBTSxPQUFPQyxHQUFHO1FBQ3pCLE9BQU87SUFDVDtJQUNBLElBQUksT0FBT0QsTUFBTSxjQUFj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QUNaLElBQUk7UUFBQ0Q7UUFBYUM7S0FBVztJQUM3QixNQUFNWSxpQkFBaUJ0RiwwQ0FBYSxDQUFDO1FBQ25DLE1BQU11RixnQkFBZ0I7WUFDcEJDLFVBQVU1QztZQUNWNkMsTUFBTTtZQUNOQyxLQUFLO1FBQ1A7UUFDQSxJQUFJLENBQUM1QyxTQUFTRyxRQUFRLEVBQUU7WUFDdEIsT0FBT3NDO1FBQ1Q7UUFDQSxNQUFNOUIsSUFBSXRCLFdBQVdXLFNBQVNHLFFBQVEsRUFBRUssS0FBS0csQ0FBQztRQUM5QyxNQUFNQyxJQUFJdkIsV0FBV1csU0FBU0csUUFBUSxFQUFFSyxLQUFLSSxDQUFDO1FBQzlDLElBQUlQLFdBQVc7WUFDYixPQUFPO2dCQUNMLEdBQUdvQyxhQUFhO2dCQUNoQnBDLFdBQVcsZUFBZU0sSUFBSSxTQUFTQyxJQUFJO2dCQUMzQyxHQUFJN0IsT0FBT2lCLFNBQVNHLFFBQVEsS0FBSyxPQUFPO29CQUN0QzBDLFlBQVk7Z0JBQ2QsQ0FBQztZQUNIO1FBQ0Y7UUFDQSxPQUFPO1lBQ0xILFVBQVU1QztZQUNWNkMsTUFBTWhDO1lBQ05pQyxLQUFLaEM7UUFDUDtJQUNGLEdBQUc7UUFBQ2Q7UUFBVU87UUFBV0wsU0FBU0csUUFBUTtRQUFFSyxLQUFLRyxDQUFDO1FBQUVILEtBQUtJLENBQUM7S0FBQztJQUMzRCxPQUFPMUQsMENBQWEsQ0FBQyxJQUFPO1lBQzFCLEdBQUdzRCxJQUFJO1lBQ1B3QjtZQUNBTTtZQUNBdEM7WUFDQXdDO1FBQ0YsSUFBSTtRQUFDaEM7UUFBTXdCO1FBQVFNO1FBQU10QztRQUFVd0M7S0FBZTtBQUNwRDtBQUU4QiIsInNvdXJjZXMiOlsid2VicGFjazovL2JlbmdncmkuZ2l0aHViLmlvLy4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9yZWFjdC1kb20vZGlzdC9mbG9hdGluZy11aS5yZWFjdC1kb20ubWpzP2M3OWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXJyb3cgYXMgYXJyb3ckMSwgY29tcHV0ZVBvc2l0aW9uIH0gZnJvbSAnQGZsb2F0aW5nLXVpL2RvbSc7XG5leHBvcnQgeyBhdXRvUGxhY2VtZW50LCBhdXRvVXBkYXRlLCBjb21wdXRlUG9zaXRpb24sIGRldGVjdE92ZXJmbG93LCBmbGlwLCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHBsYXRmb3JtLCBzaGlmdCwgc2l6ZSB9IGZyb20gJ0BmbG9hdGluZy11aS9kb20nO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYW4gaW5uZXIgZWxlbWVudCBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBzbyB0aGF0IGl0XG4gKiBhcHBlYXJzIGNlbnRlcmVkIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIFRoaXMgd3JhcHMgdGhlIGNvcmUgYGFycm93YCBtaWRkbGV3YXJlIHRvIGFsbG93IFJlYWN0IHJlZnMgYXMgdGhlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3cgPSBvcHRpb25zID0+IHtcbiAgZnVuY3Rpb24gaXNSZWYodmFsdWUpIHtcbiAgICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2N1cnJlbnQnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdhcnJvdycsXG4gICAgb3B0aW9ucyxcbiAgICBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbGVtZW50LFxuICAgICAgICBwYWRkaW5nXG4gICAgICB9ID0gdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zKHN0YXRlKSA6IG9wdGlvbnM7XG4gICAgICBpZiAoZWxlbWVudCAmJiBpc1JlZihlbGVtZW50KSkge1xuICAgICAgICBpZiAoZWxlbWVudC5jdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gYXJyb3ckMSh7XG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LmN1cnJlbnQsXG4gICAgICAgICAgICBwYWRkaW5nXG4gICAgICAgICAgfSkuZm4oc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gYXJyb3ckMSh7XG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICBwYWRkaW5nXG4gICAgICAgIH0pLmZuKHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgaW5kZXggPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG4vLyBGb3JrIG9mIGBmYXN0LWRlZXAtZXF1YWxgIHRoYXQgb25seSBkb2VzIHRoZSBjb21wYXJpc29ucyB3ZSBuZWVkIGFuZCBjb21wYXJlc1xuLy8gZnVuY3Rpb25zXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgYSAhPT0gdHlwZW9mIGIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBhID09PSAnZnVuY3Rpb24nICYmIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgbGV0IGxlbmd0aCwgaSwga2V5cztcbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgICBpZiAoIWRlZXBFcXVhbChhW2ldLCBiW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoa2V5ID09PSAnX293bmVyJyAmJiBhLiQkdHlwZW9mKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGEgIT09IGEgJiYgYiAhPT0gYjtcbn1cblxuZnVuY3Rpb24gZ2V0RFBSKGVsZW1lbnQpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgY29uc3Qgd2luID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgcmV0dXJuIHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG59XG5cbmZ1bmN0aW9uIHJvdW5kQnlEUFIoZWxlbWVudCwgdmFsdWUpIHtcbiAgY29uc3QgZHByID0gZ2V0RFBSKGVsZW1lbnQpO1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIGRwcikgLyBkcHI7XG59XG5cbmZ1bmN0aW9uIHVzZUxhdGVzdFJlZih2YWx1ZSkge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYodmFsdWUpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZWY7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlRmxvYXRpbmdcbiAqL1xuZnVuY3Rpb24gdXNlRmxvYXRpbmcob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQgPSAnYm90dG9tJyxcbiAgICBzdHJhdGVneSA9ICdhYnNvbHV0ZScsXG4gICAgbWlkZGxld2FyZSA9IFtdLFxuICAgIHBsYXRmb3JtLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICByZWZlcmVuY2U6IGV4dGVybmFsUmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmc6IGV4dGVybmFsRmxvYXRpbmdcbiAgICB9ID0ge30sXG4gICAgdHJhbnNmb3JtID0gdHJ1ZSxcbiAgICB3aGlsZUVsZW1lbnRzTW91bnRlZCxcbiAgICBvcGVuXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBbZGF0YSwgc2V0RGF0YV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHN0cmF0ZWd5LFxuICAgIHBsYWNlbWVudCxcbiAgICBtaWRkbGV3YXJlRGF0YToge30sXG4gICAgaXNQb3NpdGlvbmVkOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgW2xhdGVzdE1pZGRsZXdhcmUsIHNldExhdGVzdE1pZGRsZXdhcmVdID0gUmVhY3QudXNlU3RhdGUobWlkZGxld2FyZSk7XG4gIGlmICghZGVlcEVxdWFsKGxhdGVzdE1pZGRsZXdhcmUsIG1pZGRsZXdhcmUpKSB7XG4gICAgc2V0TGF0ZXN0TWlkZGxld2FyZShtaWRkbGV3YXJlKTtcbiAgfVxuICBjb25zdCBbX3JlZmVyZW5jZSwgX3NldFJlZmVyZW5jZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW19mbG9hdGluZywgX3NldEZsb2F0aW5nXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBzZXRSZWZlcmVuY2UgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBpZiAobm9kZSAhPSByZWZlcmVuY2VSZWYuY3VycmVudCkge1xuICAgICAgcmVmZXJlbmNlUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgX3NldFJlZmVyZW5jZShub2RlKTtcbiAgICB9XG4gIH0sIFtfc2V0UmVmZXJlbmNlXSk7XG4gIGNvbnN0IHNldEZsb2F0aW5nID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgaWYgKG5vZGUgIT09IGZsb2F0aW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgIGZsb2F0aW5nUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgX3NldEZsb2F0aW5nKG5vZGUpO1xuICAgIH1cbiAgfSwgW19zZXRGbG9hdGluZ10pO1xuICBjb25zdCByZWZlcmVuY2VFbCA9IGV4dGVybmFsUmVmZXJlbmNlIHx8IF9yZWZlcmVuY2U7XG4gIGNvbnN0IGZsb2F0aW5nRWwgPSBleHRlcm5hbEZsb2F0aW5nIHx8IF9mbG9hdGluZztcbiAgY29uc3QgcmVmZXJlbmNlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBmbG9hdGluZ1JlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZGF0YVJlZiA9IFJlYWN0LnVzZVJlZihkYXRhKTtcbiAgY29uc3Qgd2hpbGVFbGVtZW50c01vdW50ZWRSZWYgPSB1c2VMYXRlc3RSZWYod2hpbGVFbGVtZW50c01vdW50ZWQpO1xuICBjb25zdCBwbGF0Zm9ybVJlZiA9IHVzZUxhdGVzdFJlZihwbGF0Zm9ybSk7XG4gIGNvbnN0IHVwZGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXJlZmVyZW5jZVJlZi5jdXJyZW50IHx8ICFmbG9hdGluZ1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIHN0cmF0ZWd5LFxuICAgICAgbWlkZGxld2FyZTogbGF0ZXN0TWlkZGxld2FyZVxuICAgIH07XG4gICAgaWYgKHBsYXRmb3JtUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbmZpZy5wbGF0Zm9ybSA9IHBsYXRmb3JtUmVmLmN1cnJlbnQ7XG4gICAgfVxuICAgIGNvbXB1dGVQb3NpdGlvbihyZWZlcmVuY2VSZWYuY3VycmVudCwgZmxvYXRpbmdSZWYuY3VycmVudCwgY29uZmlnKS50aGVuKGRhdGEgPT4ge1xuICAgICAgY29uc3QgZnVsbERhdGEgPSB7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIGlzUG9zaXRpb25lZDogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCAmJiAhZGVlcEVxdWFsKGRhdGFSZWYuY3VycmVudCwgZnVsbERhdGEpKSB7XG4gICAgICAgIGRhdGFSZWYuY3VycmVudCA9IGZ1bGxEYXRhO1xuICAgICAgICBSZWFjdERPTS5mbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgIHNldERhdGEoZnVsbERhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW2xhdGVzdE1pZGRsZXdhcmUsIHBsYWNlbWVudCwgc3RyYXRlZ3ksIHBsYXRmb3JtUmVmXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAob3BlbiA9PT0gZmFsc2UgJiYgZGF0YVJlZi5jdXJyZW50LmlzUG9zaXRpb25lZCkge1xuICAgICAgZGF0YVJlZi5jdXJyZW50LmlzUG9zaXRpb25lZCA9IGZhbHNlO1xuICAgICAgc2V0RGF0YShkYXRhID0+ICh7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIGlzUG9zaXRpb25lZDogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIFtvcGVuXSk7XG4gIGNvbnN0IGlzTW91bnRlZFJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW10pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKHJlZmVyZW5jZUVsKSByZWZlcmVuY2VSZWYuY3VycmVudCA9IHJlZmVyZW5jZUVsO1xuICAgIGlmIChmbG9hdGluZ0VsKSBmbG9hdGluZ1JlZi5jdXJyZW50ID0gZmxvYXRpbmdFbDtcbiAgICBpZiAocmVmZXJlbmNlRWwgJiYgZmxvYXRpbmdFbCkge1xuICAgICAgaWYgKHdoaWxlRWxlbWVudHNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHdoaWxlRWxlbWVudHNNb3VudGVkUmVmLmN1cnJlbnQocmVmZXJlbmNlRWwsIGZsb2F0aW5nRWwsIHVwZGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtyZWZlcmVuY2VFbCwgZmxvYXRpbmdFbCwgdXBkYXRlLCB3aGlsZUVsZW1lbnRzTW91bnRlZFJlZl0pO1xuICBjb25zdCByZWZzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlUmVmLFxuICAgIGZsb2F0aW5nOiBmbG9hdGluZ1JlZixcbiAgICBzZXRSZWZlcmVuY2UsXG4gICAgc2V0RmxvYXRpbmdcbiAgfSksIFtzZXRSZWZlcmVuY2UsIHNldEZsb2F0aW5nXSk7XG4gIGNvbnN0IGVsZW1lbnRzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlRWwsXG4gICAgZmxvYXRpbmc6IGZsb2F0aW5nRWxcbiAgfSksIFtyZWZlcmVuY2VFbCwgZmxvYXRpbmdFbF0pO1xuICBjb25zdCBmbG9hdGluZ1N0eWxlcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGluaXRpYWxTdHlsZXMgPSB7XG4gICAgICBwb3NpdGlvbjogc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfTtcbiAgICBpZiAoIWVsZW1lbnRzLmZsb2F0aW5nKSB7XG4gICAgICByZXR1cm4gaW5pdGlhbFN0eWxlcztcbiAgICB9XG4gICAgY29uc3QgeCA9IHJvdW5kQnlEUFIoZWxlbWVudHMuZmxvYXRpbmcsIGRhdGEueCk7XG4gICAgY29uc3QgeSA9IHJvdW5kQnlEUFIoZWxlbWVudHMuZmxvYXRpbmcsIGRhdGEueSk7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaW5pdGlhbFN0eWxlcyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiLFxuICAgICAgICAuLi4oZ2V0RFBSKGVsZW1lbnRzLmZsb2F0aW5nKSA+PSAxLjUgJiYge1xuICAgICAgICAgIHdpbGxDaGFuZ2U6ICd0cmFuc2Zvcm0nXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IHN0cmF0ZWd5LFxuICAgICAgbGVmdDogeCxcbiAgICAgIHRvcDogeVxuICAgIH07XG4gIH0sIFtzdHJhdGVneSwgdHJhbnNmb3JtLCBlbGVtZW50cy5mbG9hdGluZywgZGF0YS54LCBkYXRhLnldKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5kYXRhLFxuICAgIHVwZGF0ZSxcbiAgICByZWZzLFxuICAgIGVsZW1lbnRzLFxuICAgIGZsb2F0aW5nU3R5bGVzXG4gIH0pLCBbZGF0YSwgdXBkYXRlLCByZWZzLCBlbGVtZW50cywgZmxvYXRpbmdTdHlsZXNdKTtcbn1cblxuZXhwb3J0IHsgYXJyb3csIHVzZUZsb2F0aW5nIH07XG4iXSwibmFtZXMiOlsiYXJyb3ciLCJhcnJvdyQxIiwiY29tcHV0ZVBvc2l0aW9uIiwiYXV0b1BsYWNlbWVudCIsImF1dG9VcGRhdGUiLCJkZXRlY3RPdmVyZmxvdyIsImZsaXAiLCJnZXRPdmVyZmxvd0FuY2VzdG9ycyIsImhpZGUiLCJpbmxpbmUiLCJsaW1pdFNoaWZ0Iiwib2Zmc2V0IiwicGxhdGZvcm0iLCJzaGlmdCIsInNpemUiLCJSZWFjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsIlJlYWN0RE9NIiwib3B0aW9ucyIsImlzUmVmIiwidmFsdWUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJuYW1lIiwiZm4iLCJzdGF0ZSIsImVsZW1lbnQiLCJwYWRkaW5nIiwiY3VycmVudCIsImluZGV4IiwiZG9jdW1lbnQiLCJkZWVwRXF1YWwiLCJhIiwiYiIsInRvU3RyaW5nIiwibGVuZ3RoIiwiaSIsImtleXMiLCJBcnJheSIsImlzQXJyYXkiLCJPYmplY3QiLCJrZXkiLCIkJHR5cGVvZiIsImdldERQUiIsIndpbiIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJyb3VuZEJ5RFBSIiwiZHByIiwiTWF0aCIsInJvdW5kIiwidXNlTGF0ZXN0UmVmIiwicmVmIiwidXNlUmVmIiwidXNlRmxvYXRpbmciLCJwbGFjZW1lbnQiLCJzdHJhdGVneSIsIm1pZGRsZXdhcmUiLCJlbGVtZW50cyIsInJlZmVyZW5jZSIsImV4dGVybmFsUmVmZXJlbmNlIiwiZmxvYXRpbmciLCJleHRlcm5hbEZsb2F0aW5nIiwidHJhbnNmb3JtIiwid2hpbGVFbGVtZW50c01vdW50ZWQiLCJvcGVuIiwiZGF0YSIsInNldERhdGEiLCJ1c2VTdGF0ZSIsIngiLCJ5IiwibWlkZGxld2FyZURhdGEiLCJpc1Bvc2l0aW9uZWQiLCJsYXRlc3RNaWRkbGV3YXJlIiwic2V0TGF0ZXN0TWlkZGxld2FyZSIsIl9yZWZlcmVuY2UiLCJfc2V0UmVmZXJlbmNlIiwiX2Zsb2F0aW5nIiwiX3NldEZsb2F0aW5nIiwic2V0UmVmZXJlbmNlIiwidXNlQ2FsbGJhY2siLCJub2RlIiwicmVmZXJlbmNlUmVmIiwic2V0RmxvYXRpbmciLCJmbG9hdGluZ1JlZiIsInJlZmVyZW5jZUVsIiwiZmxvYXRpbmdFbCIsImRhdGFSZWYiLCJ3aGlsZUVsZW1lbnRzTW91bnRlZFJlZiIsInBsYXRmb3JtUmVmIiwidXBkYXRlIiwiY29uZmlnIiwidGhlbiIsImZ1bGxEYXRhIiwiaXNNb3VudGVkUmVmIiwiZmx1c2hTeW5jIiwicmVmcyIsInVzZU1lbW8iLCJmbG9hdGluZ1N0eWxlcyIsImluaXRpYWxTdHlsZXMiLCJwb3NpdGlvbiIsImxlZnQiLCJ0b3AiLCJ3aWxsQ2hhbmdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@floating-ui/react/dist/floating-ui.react.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Composite: () => (/* binding */ Composite),\n/* harmony export */   CompositeItem: () => (/* binding */ CompositeItem),\n/* harmony export */   FloatingArrow: () => (/* binding */ FloatingArrow),\n/* harmony export */   FloatingDelayGroup: () => (/* binding */ FloatingDelayGroup),\n/* harmony export */   FloatingFocusManager: () => (/* binding */ FloatingFocusManager),\n/* harmony export */   FloatingList: () => (/* binding */ FloatingList),\n/* harmony export */   FloatingNode: () => (/* binding */ FloatingNode),\n/* harmony export */   FloatingOverlay: () => (/* binding */ FloatingOverlay),\n/* harmony export */   FloatingPortal: () => (/* binding */ FloatingPortal),\n/* harmony export */   FloatingTree: () => (/* binding */ FloatingTree),\n/* harmony export */   arrow: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.inline),\n/* harmony export */   inner: () => (/* binding */ inner),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.platform),\n/* harmony export */   safePolygon: () => (/* binding */ safePolygon),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.size),\n/* harmony export */   useClick: () => (/* binding */ useClick),\n/* harmony export */   useClientPoint: () => (/* binding */ useClientPoint),\n/* harmony export */   useDelayGroup: () => (/* binding */ useDelayGroup),\n/* harmony export */   useDelayGroupContext: () => (/* binding */ useDelayGroupContext),\n/* harmony export */   useDismiss: () => (/* binding */ useDismiss),\n/* harmony export */   useFloating: () => (/* binding */ useFloating),\n/* harmony export */   useFloatingNodeId: () => (/* binding */ useFloatingNodeId),\n/* harmony export */   useFloatingParentNodeId: () => (/* binding */ useFloatingParentNodeId),\n/* harmony export */   useFloatingPortalNode: () => (/* binding */ useFloatingPortalNode),\n/* harmony export */   useFloatingTree: () => (/* binding */ useFloatingTree),\n/* harmony export */   useFocus: () => (/* binding */ useFocus),\n/* harmony export */   useHover: () => (/* binding */ useHover),\n/* harmony export */   useId: () => (/* binding */ useId),\n/* harmony export */   useInnerOffset: () => (/* binding */ useInnerOffset),\n/* harmony export */   useInteractions: () => (/* binding */ useInteractions),\n/* harmony export */   useListItem: () => (/* binding */ useListItem),\n/* harmony export */   useListNavigation: () => (/* binding */ useListNavigation),\n/* harmony export */   useMergeRefs: () => (/* binding */ useMergeRefs),\n/* harmony export */   useRole: () => (/* binding */ useRole),\n/* harmony export */   useTransitionStatus: () => (/* binding */ useTransitionStatus),\n/* harmony export */   useTransitionStyles: () => (/* binding */ useTransitionStyles),\n/* harmony export */   useTypeahead: () => (/* binding */ useTypeahead)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @floating-ui/react/utils */ \"(ssr)/./node_modules/@floating-ui/react/utils/dist/floating-ui.react.utils.mjs\");\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! tabbable */ \"(ssr)/./node_modules/tabbable/dist/index.esm.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\n\n\n\n\n\n\n\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n * @see https://floating-ui.com/docs/useMergeRefs\n */ function useMergeRefs(refs) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (refs.every((ref)=>ref == null)) {\n            return null;\n        }\n        return (value)=>{\n            refs.forEach((ref)=>{\n                if (typeof ref === \"function\") {\n                    ref(value);\n                } else if (ref != null) {\n                    ref.current = value;\n                }\n            });\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, refs);\n}\n// `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`\nconst useInsertionEffect = /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))[/*#__PURE__*/ \"useInsertionEffect\".toString()];\nconst useSafeInsertionEffect = useInsertionEffect || ((fn)=>fn());\nfunction useEffectEvent(callback) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(()=>{\n        if (true) {\n            throw new Error(\"Cannot call an event handler while rendering.\");\n        }\n    });\n    useSafeInsertionEffect(()=>{\n        ref.current = callback;\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return ref.current == null ? void 0 : ref.current(...args);\n    }, []);\n}\nconst ARROW_UP = \"ArrowUp\";\nconst ARROW_DOWN = \"ArrowDown\";\nconst ARROW_LEFT = \"ArrowLeft\";\nconst ARROW_RIGHT = \"ArrowRight\";\nfunction isDifferentRow(index, cols, prevRow) {\n    return Math.floor(index / cols) !== prevRow;\n}\nfunction isIndexOutOfBounds(listRef, index) {\n    return index < 0 || index >= listRef.current.length;\n}\nfunction getMinIndex(listRef, disabledIndices) {\n    return findNonDisabledIndex(listRef, {\n        disabledIndices\n    });\n}\nfunction getMaxIndex(listRef, disabledIndices) {\n    return findNonDisabledIndex(listRef, {\n        decrement: true,\n        startingIndex: listRef.current.length,\n        disabledIndices\n    });\n}\nfunction findNonDisabledIndex(listRef, _temp) {\n    let { startingIndex = -1, decrement = false, disabledIndices, amount = 1 } = _temp === void 0 ? {} : _temp;\n    const list = listRef.current;\n    const isDisabledIndex = disabledIndices ? (index)=>disabledIndices.includes(index) : (index)=>{\n        const element = list[index];\n        return element == null || element.hasAttribute(\"disabled\") || element.getAttribute(\"aria-disabled\") === \"true\";\n    };\n    let index = startingIndex;\n    do {\n        index += decrement ? -amount : amount;\n    }while (index >= 0 && index <= list.length - 1 && isDisabledIndex(index));\n    return index;\n}\nfunction getGridNavigatedIndex(elementsRef, _ref) {\n    let { event, orientation, loop, cols, disabledIndices, minIndex, maxIndex, prevIndex, stopEvent: stop = false } = _ref;\n    let nextIndex = prevIndex;\n    if (event.key === ARROW_UP) {\n        stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n        if (prevIndex === -1) {\n            nextIndex = maxIndex;\n        } else {\n            nextIndex = findNonDisabledIndex(elementsRef, {\n                startingIndex: nextIndex,\n                amount: cols,\n                decrement: true,\n                disabledIndices\n            });\n            if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {\n                const col = prevIndex % cols;\n                const maxCol = maxIndex % cols;\n                const offset = maxIndex - (maxCol - col);\n                if (maxCol === col) {\n                    nextIndex = maxIndex;\n                } else {\n                    nextIndex = maxCol > col ? offset : offset - cols;\n                }\n            }\n        }\n        if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n            nextIndex = prevIndex;\n        }\n    }\n    if (event.key === ARROW_DOWN) {\n        stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n        if (prevIndex === -1) {\n            nextIndex = minIndex;\n        } else {\n            nextIndex = findNonDisabledIndex(elementsRef, {\n                startingIndex: prevIndex,\n                amount: cols,\n                disabledIndices\n            });\n            if (loop && prevIndex + cols > maxIndex) {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex % cols - cols,\n                    amount: cols,\n                    disabledIndices\n                });\n            }\n        }\n        if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n            nextIndex = prevIndex;\n        }\n    }\n    // Remains on the same row/column.\n    if (orientation === \"both\") {\n        const prevRow = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_7__.floor)(prevIndex / cols);\n        if (event.key === ARROW_RIGHT) {\n            stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n            if (prevIndex % cols !== cols - 1) {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex,\n                    disabledIndices\n                });\n                if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n                    nextIndex = findNonDisabledIndex(elementsRef, {\n                        startingIndex: prevIndex - prevIndex % cols - 1,\n                        disabledIndices\n                    });\n                }\n            } else if (loop) {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex - prevIndex % cols - 1,\n                    disabledIndices\n                });\n            }\n            if (isDifferentRow(nextIndex, cols, prevRow)) {\n                nextIndex = prevIndex;\n            }\n        }\n        if (event.key === ARROW_LEFT) {\n            stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n            if (prevIndex % cols !== 0) {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex,\n                    disabledIndices,\n                    decrement: true\n                });\n                if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n                    nextIndex = findNonDisabledIndex(elementsRef, {\n                        startingIndex: prevIndex + (cols - prevIndex % cols),\n                        decrement: true,\n                        disabledIndices\n                    });\n                }\n            } else if (loop) {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex + (cols - prevIndex % cols),\n                    decrement: true,\n                    disabledIndices\n                });\n            }\n            if (isDifferentRow(nextIndex, cols, prevRow)) {\n                nextIndex = prevIndex;\n            }\n        }\n        const lastRow = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_7__.floor)(maxIndex / cols) === prevRow;\n        if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n            if (loop && lastRow) {\n                nextIndex = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex - prevIndex % cols - 1,\n                    disabledIndices\n                });\n            } else {\n                nextIndex = prevIndex;\n            }\n        }\n    }\n    return nextIndex;\n}\nlet rafId = 0;\nfunction enqueueFocus(el, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { preventScroll = false, cancelPrevious = true, sync = false } = options;\n    cancelPrevious && cancelAnimationFrame(rafId);\n    const exec = ()=>el == null ? void 0 : el.focus({\n            preventScroll\n        });\n    if (sync) {\n        exec();\n    } else {\n        rafId = requestAnimationFrame(exec);\n    }\n}\nvar index = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction sortByDocumentPosition(a, b) {\n    const position = a.compareDocumentPosition(b);\n    if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n        return -1;\n    }\n    if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {\n        return 1;\n    }\n    return 0;\n}\nfunction areMapsEqual(map1, map2) {\n    if (map1.size !== map2.size) {\n        return false;\n    }\n    for (const [key, value] of map1.entries()){\n        if (value !== map2.get(key)) {\n            return false;\n        }\n    }\n    return true;\n}\nconst FloatingListContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    register: ()=>{},\n    unregister: ()=>{},\n    map: /*#__PURE__*/ new Map(),\n    elementsRef: {\n        current: []\n    }\n});\n/**\n * Provides context for a list of items within the floating element.\n * @see https://floating-ui.com/docs/FloatingList\n */ function FloatingList(_ref) {\n    let { children, elementsRef, labelsRef } = _ref;\n    const [map, setMap] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new Map());\n    const register = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        setMap((prevMap)=>new Map(prevMap).set(node, null));\n    }, []);\n    const unregister = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        setMap((prevMap)=>{\n            const map = new Map(prevMap);\n            map.delete(node);\n            return map;\n        });\n    }, []);\n    index(()=>{\n        const newMap = new Map(map);\n        const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);\n        nodes.forEach((node, index)=>{\n            newMap.set(node, index);\n        });\n        if (!areMapsEqual(map, newMap)) {\n            setMap(newMap);\n        }\n    }, [\n        map\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingListContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                register,\n                unregister,\n                map,\n                elementsRef,\n                labelsRef\n            }), [\n            register,\n            unregister,\n            map,\n            elementsRef,\n            labelsRef\n        ])\n    }, children);\n}\nfunction useListItem(_temp) {\n    let { label } = _temp === void 0 ? {} : _temp;\n    const [index$1, setIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const componentRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const { register, unregister, map, elementsRef, labelsRef } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingListContext);\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        componentRef.current = node;\n        if (index$1 !== null) {\n            elementsRef.current[index$1] = node;\n            if (labelsRef) {\n                var _node$textContent;\n                const isLabelDefined = label !== undefined;\n                labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;\n            }\n        }\n    }, [\n        index$1,\n        elementsRef,\n        labelsRef,\n        label\n    ]);\n    index(()=>{\n        const node = componentRef.current;\n        if (node) {\n            register(node);\n            return ()=>{\n                unregister(node);\n            };\n        }\n    }, [\n        register,\n        unregister\n    ]);\n    index(()=>{\n        const index = componentRef.current ? map.get(componentRef.current) : null;\n        if (index != null) {\n            setIndex(index);\n        }\n    }, [\n        map\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ref,\n            index: index$1 == null ? -1 : index$1\n        }), [\n        index$1,\n        ref\n    ]);\n}\nfunction renderJsx(render, computedProps) {\n    if (typeof render === \"function\") {\n        return render(computedProps);\n    } else if (render) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(render, computedProps);\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", computedProps);\n}\nconst CompositeContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    activeIndex: 0,\n    onNavigate: ()=>{}\n});\nconst horizontalKeys = [\n    ARROW_LEFT,\n    ARROW_RIGHT\n];\nconst verticalKeys = [\n    ARROW_UP,\n    ARROW_DOWN\n];\nconst allKeys = [\n    ...horizontalKeys,\n    ...verticalKeys\n];\nconst Composite = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function Composite(_ref, forwardedRef) {\n    let { render, orientation = \"both\", loop = true, cols = 1, disabledIndices, activeIndex: externalActiveIndex, onNavigate: externalSetActiveIndex, ...props } = _ref;\n    const [internalActiveIndex, internalSetActiveIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);\n    const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;\n    const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);\n    const elementsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n    const renderElementProps = render && typeof render !== \"function\" ? render.props : {};\n    const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            activeIndex,\n            onNavigate\n        }), [\n        activeIndex,\n        onNavigate\n    ]);\n    const isGrid = cols > 1;\n    function handleKeyDown(event) {\n        if (!allKeys.includes(event.key)) return;\n        const minIndex = getMinIndex(elementsRef, disabledIndices);\n        const maxIndex = getMaxIndex(elementsRef, disabledIndices);\n        const prevIndex = activeIndex;\n        let nextIndex = activeIndex;\n        if (isGrid) {\n            nextIndex = getGridNavigatedIndex(elementsRef, {\n                event,\n                orientation,\n                loop,\n                cols,\n                disabledIndices,\n                minIndex,\n                maxIndex,\n                prevIndex\n            });\n        }\n        const toEndKeys = {\n            horizontal: [\n                ARROW_RIGHT\n            ],\n            vertical: [\n                ARROW_DOWN\n            ],\n            both: [\n                ARROW_RIGHT,\n                ARROW_DOWN\n            ]\n        }[orientation];\n        const toStartKeys = {\n            horizontal: [\n                ARROW_LEFT\n            ],\n            vertical: [\n                ARROW_UP\n            ],\n            both: [\n                ARROW_LEFT,\n                ARROW_UP\n            ]\n        }[orientation];\n        const preventedKeys = isGrid ? allKeys : ({\n            horizontal: horizontalKeys,\n            vertical: verticalKeys,\n            both: allKeys\n        })[orientation];\n        if (nextIndex === activeIndex && [\n            ...toEndKeys,\n            ...toStartKeys\n        ].includes(event.key)) {\n            if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {\n                nextIndex = minIndex;\n            } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {\n                nextIndex = maxIndex;\n            } else {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: nextIndex,\n                    decrement: toStartKeys.includes(event.key),\n                    disabledIndices\n                });\n            }\n        }\n        if (nextIndex !== activeIndex && !isIndexOutOfBounds(elementsRef, nextIndex)) {\n            event.stopPropagation();\n            if (preventedKeys.includes(event.key)) {\n                event.preventDefault();\n            }\n            onNavigate(nextIndex);\n            // Wait for FocusManager `returnFocus` to execute.\n            queueMicrotask(()=>{\n                enqueueFocus(elementsRef.current[nextIndex]);\n            });\n        }\n    }\n    const computedProps = {\n        ...props,\n        ...renderElementProps,\n        ref: forwardedRef,\n        \"aria-orientation\": orientation === \"both\" ? undefined : orientation,\n        onKeyDown (e) {\n            props.onKeyDown == null || props.onKeyDown(e);\n            renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);\n            handleKeyDown(e);\n        }\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CompositeContext.Provider, {\n        value: contextValue\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingList, {\n        elementsRef: elementsRef\n    }, renderJsx(render, computedProps)));\n});\nconst CompositeItem = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function CompositeItem(_ref2, forwardedRef) {\n    let { render, ...props } = _ref2;\n    const renderElementProps = render && typeof render !== \"function\" ? render.props : {};\n    const { activeIndex, onNavigate } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CompositeContext);\n    const { ref, index } = useListItem();\n    const mergedRef = useMergeRefs([\n        ref,\n        forwardedRef,\n        renderElementProps.ref\n    ]);\n    const isActive = activeIndex === index;\n    const computedProps = {\n        ...props,\n        ...renderElementProps,\n        ref: mergedRef,\n        tabIndex: isActive ? 0 : -1,\n        \"data-active\": isActive ? \"\" : undefined,\n        onFocus (e) {\n            props.onFocus == null || props.onFocus(e);\n            renderElementProps.onFocus == null || renderElementProps.onFocus(e);\n            onNavigate(index);\n        }\n    };\n    return renderJsx(render, computedProps);\n});\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nlet serverHandoffComplete = false;\nlet count = 0;\nconst genId = ()=>\"floating-ui-\" + count++;\nfunction useFloatingId() {\n    const [id, setId] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>serverHandoffComplete ? genId() : undefined);\n    index(()=>{\n        if (id == null) {\n            setId(genId());\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!serverHandoffComplete) {\n            serverHandoffComplete = true;\n        }\n    }, []);\n    return id;\n}\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useReactId = /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))[/*#__PURE__*/ \"useId\".toString()];\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/useId\n */ const useId = useReactId || useFloatingId;\n/**\n * Renders a pointing arrow triangle.\n * @see https://floating-ui.com/docs/FloatingArrow\n */ const FloatingArrow = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FloatingArrow(_ref, ref) {\n    let { context: { placement, elements: { floating }, middlewareData: { arrow } }, width = 14, height = 7, tipRadius = 0, strokeWidth = 0, staticOffset, stroke, d, style: { transform, ...restStyle } = {}, ...rest } = _ref;\n    if (true) {\n        if (!ref) {\n            console.warn(\"Floating UI: The `ref` prop is required for the `FloatingArrow`\", \"component.\");\n        }\n    }\n    const clipPathId = useId();\n    if (!floating) {\n        return null;\n    }\n    // Strokes must be double the border width, this ensures the stroke's width\n    // works as you'd expect.\n    strokeWidth *= 2;\n    const halfStrokeWidth = strokeWidth / 2;\n    const svgX = width / 2 * (tipRadius / -8 + 1);\n    const svgY = height / 2 * tipRadius / 4;\n    const [side, alignment] = placement.split(\"-\");\n    const isRTL = _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.platform.isRTL(floating);\n    const isCustomShape = !!d;\n    const isVerticalSide = side === \"top\" || side === \"bottom\";\n    const yOffsetProp = staticOffset && alignment === \"end\" ? \"bottom\" : \"top\";\n    let xOffsetProp = staticOffset && alignment === \"end\" ? \"right\" : \"left\";\n    if (staticOffset && isRTL) {\n        xOffsetProp = alignment === \"end\" ? \"left\" : \"right\";\n    }\n    const arrowX = (arrow == null ? void 0 : arrow.x) != null ? staticOffset || arrow.x : \"\";\n    const arrowY = (arrow == null ? void 0 : arrow.y) != null ? staticOffset || arrow.y : \"\";\n    const dValue = d || \"M0,0\" + (\" H\" + width) + (\" L\" + (width - svgX) + \",\" + (height - svgY)) + (\" Q\" + width / 2 + \",\" + height + \" \" + svgX + \",\" + (height - svgY)) + \" Z\";\n    const rotation = {\n        top: isCustomShape ? \"rotate(180deg)\" : \"\",\n        left: isCustomShape ? \"rotate(90deg)\" : \"rotate(-90deg)\",\n        bottom: isCustomShape ? \"\" : \"rotate(180deg)\",\n        right: isCustomShape ? \"rotate(-90deg)\" : \"rotate(90deg)\"\n    }[side];\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", _extends({}, rest, {\n        \"aria-hidden\": true,\n        ref: ref,\n        width: isCustomShape ? width : width + strokeWidth,\n        height: width,\n        viewBox: \"0 0 \" + width + \" \" + (height > width ? height : width),\n        style: {\n            position: \"absolute\",\n            pointerEvents: \"none\",\n            [xOffsetProp]: arrowX,\n            [yOffsetProp]: arrowY,\n            [side]: isVerticalSide || isCustomShape ? \"100%\" : \"calc(100% - \" + strokeWidth / 2 + \"px)\",\n            transform: \"\" + rotation + (transform != null ? transform : \"\"),\n            ...restStyle\n        }\n    }), strokeWidth > 0 && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        clipPath: \"url(#\" + clipPathId + \")\",\n        fill: \"none\",\n        stroke: stroke,\n        strokeWidth: strokeWidth + (d ? 0 : 1),\n        d: dValue\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        stroke: strokeWidth && !d ? rest.fill : \"none\",\n        d: dValue\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"clipPath\", {\n        id: clipPathId\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n        x: -halfStrokeWidth,\n        y: halfStrokeWidth * (isCustomShape ? -1 : 1),\n        width: width + strokeWidth,\n        height: width\n    })));\n});\nfunction createPubSub() {\n    const map = new Map();\n    return {\n        emit (event, data) {\n            var _map$get;\n            (_map$get = map.get(event)) == null || _map$get.forEach((handler)=>handler(data));\n        },\n        on (event, listener) {\n            map.set(event, [\n                ...map.get(event) || [],\n                listener\n            ]);\n        },\n        off (event, listener) {\n            var _map$get2;\n            map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l)=>l !== listener)) || []);\n        }\n    };\n}\nconst FloatingNodeContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst useFloatingParentNodeId = ()=>{\n    var _React$useContext;\n    return ((_React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n};\nconst useFloatingTree = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingTreeContext);\n/**\n * Registers a node into the floating tree, returning its id.\n */ function useFloatingNodeId(customParentId) {\n    const id = useId();\n    const tree = useFloatingTree();\n    const reactParentId = useFloatingParentNodeId();\n    const parentId = customParentId || reactParentId;\n    index(()=>{\n        const node = {\n            id,\n            parentId\n        };\n        tree == null || tree.addNode(node);\n        return ()=>{\n            tree == null || tree.removeNode(node);\n        };\n    }, [\n        tree,\n        id,\n        parentId\n    ]);\n    return id;\n}\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */ function FloatingNode(_ref) {\n    let { children, id } = _ref;\n    const parentId = useFloatingParentNodeId();\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingNodeContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                id,\n                parentId\n            }), [\n            id,\n            parentId\n        ])\n    }, children);\n}\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM (i.e. portalled to a common node, rather than their\n * respective parent).\n * @see https://floating-ui.com/docs/FloatingTree\n */ function FloatingTree(_ref2) {\n    let { children } = _ref2;\n    const nodesRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n    const addNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        nodesRef.current = [\n            ...nodesRef.current,\n            node\n        ];\n    }, []);\n    const removeNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        nodesRef.current = nodesRef.current.filter((n)=>n !== node);\n    }, []);\n    const events = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>createPubSub())[0];\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingTreeContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                nodesRef,\n                addNode,\n                removeNode,\n                events\n            }), [\n            nodesRef,\n            addNode,\n            removeNode,\n            events\n        ])\n    }, children);\n}\nfunction createAttribute(name) {\n    return \"data-floating-ui-\" + name;\n}\nfunction useLatestRef(value) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n    index(()=>{\n        ref.current = value;\n    });\n    return ref;\n}\nconst safePolygonIdentifier = /*#__PURE__*/ createAttribute(\"safe-polygon\");\nfunction getDelay(value, prop, pointerType) {\n    if (pointerType && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerType)) {\n        return 0;\n    }\n    if (typeof value === \"number\") {\n        return value;\n    }\n    return value == null ? void 0 : value[prop];\n}\n/**\n * Opens the floating element while hovering over the reference element, like\n * CSS `:hover`.\n * @see https://floating-ui.com/docs/useHover\n */ function useHover(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, dataRef, events, elements: { domReference, floating }, refs } = context;\n    const { enabled = true, delay = 0, handleClose = null, mouseOnly = false, restMs = 0, move = true } = props;\n    const tree = useFloatingTree();\n    const parentId = useFloatingParentNodeId();\n    const handleCloseRef = useLatestRef(handleClose);\n    const delayRef = useLatestRef(delay);\n    const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const handlerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const restTimeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const blockMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    const performedPointerEventsMutationRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const unbindMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(()=>{});\n    const isHoverOpen = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        var _dataRef$current$open;\n        const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n        return (type == null ? void 0 : type.includes(\"mouse\")) && type !== \"mousedown\";\n    }, [\n        dataRef\n    ]);\n    // When closing before opening, clear the delay timeouts to cancel it\n    // from showing.\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        function onOpenChange(_ref) {\n            let { open } = _ref;\n            if (!open) {\n                clearTimeout(timeoutRef.current);\n                clearTimeout(restTimeoutRef.current);\n                blockMouseMoveRef.current = true;\n            }\n        }\n        events.on(\"openchange\", onOpenChange);\n        return ()=>{\n            events.off(\"openchange\", onOpenChange);\n        };\n    }, [\n        enabled,\n        events\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled || !handleCloseRef.current || !open) {\n            return;\n        }\n        function onLeave(event) {\n            if (isHoverOpen()) {\n                onOpenChange(false, event, \"hover\");\n            }\n        }\n        const html = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating).documentElement;\n        html.addEventListener(\"mouseleave\", onLeave);\n        return ()=>{\n            html.removeEventListener(\"mouseleave\", onLeave);\n        };\n    }, [\n        floating,\n        open,\n        onOpenChange,\n        enabled,\n        handleCloseRef,\n        dataRef,\n        isHoverOpen\n    ]);\n    const closeWithDelay = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(event, runElseBranch, reason) {\n        if (runElseBranch === void 0) {\n            runElseBranch = true;\n        }\n        if (reason === void 0) {\n            reason = \"hover\";\n        }\n        const closeDelay = getDelay(delayRef.current, \"close\", pointerTypeRef.current);\n        if (closeDelay && !handlerRef.current) {\n            clearTimeout(timeoutRef.current);\n            timeoutRef.current = setTimeout(()=>onOpenChange(false, event, reason), closeDelay);\n        } else if (runElseBranch) {\n            clearTimeout(timeoutRef.current);\n            onOpenChange(false, event, reason);\n        }\n    }, [\n        delayRef,\n        onOpenChange\n    ]);\n    const cleanupMouseMoveHandler = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        unbindMouseMoveRef.current();\n        handlerRef.current = undefined;\n    }, []);\n    const clearPointerEvents = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        if (performedPointerEventsMutationRef.current) {\n            const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(refs.floating.current).body;\n            body.style.pointerEvents = \"\";\n            body.removeAttribute(safePolygonIdentifier);\n            performedPointerEventsMutationRef.current = false;\n        }\n    }, [\n        refs\n    ]);\n    // Registering the mouse events on the reference directly to bypass React's\n    // delegation system. If the cursor was on a disabled element and then entered\n    // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        function isClickLikeOpenEvent() {\n            return dataRef.current.openEvent ? [\n                \"click\",\n                \"mousedown\"\n            ].includes(dataRef.current.openEvent.type) : false;\n        }\n        function onMouseEnter(event) {\n            clearTimeout(timeoutRef.current);\n            blockMouseMoveRef.current = false;\n            if (mouseOnly && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, \"open\") === 0) {\n                return;\n            }\n            const openDelay = getDelay(delayRef.current, \"open\", pointerTypeRef.current);\n            if (openDelay) {\n                timeoutRef.current = setTimeout(()=>{\n                    onOpenChange(true, event, \"hover\");\n                }, openDelay);\n            } else {\n                onOpenChange(true, event, \"hover\");\n            }\n        }\n        function onMouseLeave(event) {\n            if (isClickLikeOpenEvent()) {\n                return;\n            }\n            unbindMouseMoveRef.current();\n            const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating);\n            clearTimeout(restTimeoutRef.current);\n            if (handleCloseRef.current) {\n                // Prevent clearing `onScrollMouseLeave` timeout.\n                if (!open) {\n                    clearTimeout(timeoutRef.current);\n                }\n                handlerRef.current = handleCloseRef.current({\n                    ...context,\n                    tree,\n                    x: event.clientX,\n                    y: event.clientY,\n                    onClose () {\n                        clearPointerEvents();\n                        cleanupMouseMoveHandler();\n                        closeWithDelay(event, true, \"safe-polygon\");\n                    }\n                });\n                const handler = handlerRef.current;\n                doc.addEventListener(\"mousemove\", handler);\n                unbindMouseMoveRef.current = ()=>{\n                    doc.removeEventListener(\"mousemove\", handler);\n                };\n                return;\n            }\n            // Allow interactivity without `safePolygon` on touch devices. With a\n            // pointer, a short close delay is an alternative, so it should work\n            // consistently.\n            const shouldClose = pointerTypeRef.current === \"touch\" ? !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, event.relatedTarget) : true;\n            if (shouldClose) {\n                closeWithDelay(event);\n            }\n        }\n        // Ensure the floating element closes after scrolling even if the pointer\n        // did not move.\n        // https://github.com/floating-ui/floating-ui/discussions/1692\n        function onScrollMouseLeave(event) {\n            if (isClickLikeOpenEvent()) {\n                return;\n            }\n            handleCloseRef.current == null || handleCloseRef.current({\n                ...context,\n                tree,\n                x: event.clientX,\n                y: event.clientY,\n                onClose () {\n                    clearPointerEvents();\n                    cleanupMouseMoveHandler();\n                    closeWithDelay(event);\n                }\n            })(event);\n        }\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(domReference)) {\n            const ref = domReference;\n            open && ref.addEventListener(\"mouseleave\", onScrollMouseLeave);\n            floating == null || floating.addEventListener(\"mouseleave\", onScrollMouseLeave);\n            move && ref.addEventListener(\"mousemove\", onMouseEnter, {\n                once: true\n            });\n            ref.addEventListener(\"mouseenter\", onMouseEnter);\n            ref.addEventListener(\"mouseleave\", onMouseLeave);\n            return ()=>{\n                open && ref.removeEventListener(\"mouseleave\", onScrollMouseLeave);\n                floating == null || floating.removeEventListener(\"mouseleave\", onScrollMouseLeave);\n                move && ref.removeEventListener(\"mousemove\", onMouseEnter);\n                ref.removeEventListener(\"mouseenter\", onMouseEnter);\n                ref.removeEventListener(\"mouseleave\", onMouseLeave);\n            };\n        }\n    }, [\n        domReference,\n        floating,\n        enabled,\n        context,\n        mouseOnly,\n        restMs,\n        move,\n        closeWithDelay,\n        cleanupMouseMoveHandler,\n        clearPointerEvents,\n        onOpenChange,\n        open,\n        tree,\n        delayRef,\n        handleCloseRef,\n        dataRef\n    ]);\n    // Block pointer-events of every element other than the reference and floating\n    // while the floating element is open and has a `handleClose` handler. Also\n    // handles nested floating elements.\n    // https://github.com/floating-ui/floating-ui/issues/1722\n    index(()=>{\n        var _handleCloseRef$curre;\n        if (!enabled) {\n            return;\n        }\n        if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {\n            const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating).body;\n            body.setAttribute(safePolygonIdentifier, \"\");\n            body.style.pointerEvents = \"none\";\n            performedPointerEventsMutationRef.current = true;\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(domReference) && floating) {\n                var _tree$nodesRef$curren;\n                const ref = domReference;\n                const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node)=>node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;\n                if (parentFloating) {\n                    parentFloating.style.pointerEvents = \"\";\n                }\n                ref.style.pointerEvents = \"auto\";\n                floating.style.pointerEvents = \"auto\";\n                return ()=>{\n                    ref.style.pointerEvents = \"\";\n                    floating.style.pointerEvents = \"\";\n                };\n            }\n        }\n    }, [\n        enabled,\n        open,\n        parentId,\n        floating,\n        domReference,\n        tree,\n        handleCloseRef,\n        dataRef,\n        isHoverOpen\n    ]);\n    index(()=>{\n        if (!open) {\n            pointerTypeRef.current = undefined;\n            cleanupMouseMoveHandler();\n            clearPointerEvents();\n        }\n    }, [\n        open,\n        cleanupMouseMoveHandler,\n        clearPointerEvents\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>{\n            cleanupMouseMoveHandler();\n            clearTimeout(timeoutRef.current);\n            clearTimeout(restTimeoutRef.current);\n            clearPointerEvents();\n        };\n    }, [\n        enabled,\n        domReference,\n        cleanupMouseMoveHandler,\n        clearPointerEvents\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        function setPointerRef(event) {\n            pointerTypeRef.current = event.pointerType;\n        }\n        return {\n            reference: {\n                onPointerDown: setPointerRef,\n                onPointerEnter: setPointerRef,\n                onMouseMove (event) {\n                    if (open || restMs === 0) {\n                        return;\n                    }\n                    clearTimeout(restTimeoutRef.current);\n                    restTimeoutRef.current = setTimeout(()=>{\n                        if (!blockMouseMoveRef.current) {\n                            onOpenChange(true, event.nativeEvent, \"hover\");\n                        }\n                    }, restMs);\n                }\n            },\n            floating: {\n                onMouseEnter () {\n                    clearTimeout(timeoutRef.current);\n                },\n                onMouseLeave (event) {\n                    closeWithDelay(event.nativeEvent, false);\n                }\n            }\n        };\n    }, [\n        enabled,\n        restMs,\n        open,\n        onOpenChange,\n        closeWithDelay\n    ]);\n}\nconst FloatingDelayGroupContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    delay: 0,\n    initialDelay: 0,\n    timeoutMs: 0,\n    currentId: null,\n    setCurrentId: ()=>{},\n    setState: ()=>{},\n    isInstantPhase: false\n});\nconst useDelayGroupContext = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingDelayGroupContext);\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */ const FloatingDelayGroup = (_ref)=>{\n    let { children, delay, timeoutMs = 0 } = _ref;\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useReducer((prev, next)=>({\n            ...prev,\n            ...next\n        }), {\n        delay,\n        timeoutMs,\n        initialDelay: delay,\n        currentId: null,\n        isInstantPhase: false\n    });\n    const initialCurrentIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const setCurrentId = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((currentId)=>{\n        setState({\n            currentId\n        });\n    }, []);\n    index(()=>{\n        if (state.currentId) {\n            if (initialCurrentIdRef.current === null) {\n                initialCurrentIdRef.current = state.currentId;\n            } else {\n                setState({\n                    isInstantPhase: true\n                });\n            }\n        } else {\n            setState({\n                isInstantPhase: false\n            });\n            initialCurrentIdRef.current = null;\n        }\n    }, [\n        state.currentId\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingDelayGroupContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                ...state,\n                setState,\n                setCurrentId\n            }), [\n            state,\n            setState,\n            setCurrentId\n        ])\n    }, children);\n};\nconst useDelayGroup = (_ref2, _ref3)=>{\n    let { open, onOpenChange } = _ref2;\n    let { id } = _ref3;\n    const { currentId, setCurrentId, initialDelay, setState, timeoutMs } = useDelayGroupContext();\n    index(()=>{\n        if (currentId) {\n            setState({\n                delay: {\n                    open: 1,\n                    close: getDelay(initialDelay, \"close\")\n                }\n            });\n            if (currentId !== id) {\n                onOpenChange(false);\n            }\n        }\n    }, [\n        id,\n        onOpenChange,\n        setState,\n        currentId,\n        initialDelay\n    ]);\n    index(()=>{\n        function unset() {\n            onOpenChange(false);\n            setState({\n                delay: initialDelay,\n                currentId: null\n            });\n        }\n        if (!open && currentId === id) {\n            if (timeoutMs) {\n                const timeout = window.setTimeout(unset, timeoutMs);\n                return ()=>{\n                    clearTimeout(timeout);\n                };\n            } else {\n                unset();\n            }\n        }\n    }, [\n        open,\n        setState,\n        currentId,\n        id,\n        onOpenChange,\n        initialDelay,\n        timeoutMs\n    ]);\n    index(()=>{\n        if (open) {\n            setCurrentId(id);\n        }\n    }, [\n        open,\n        setCurrentId,\n        id\n    ]);\n};\nfunction getAncestors(nodes, id) {\n    var _nodes$find;\n    let allAncestors = [];\n    let currentParentId = (_nodes$find = nodes.find((node)=>node.id === id)) == null ? void 0 : _nodes$find.parentId;\n    while(currentParentId){\n        const currentNode = nodes.find((node)=>node.id === currentParentId);\n        currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n        if (currentNode) {\n            allAncestors = allAncestors.concat(currentNode);\n        }\n    }\n    return allAncestors;\n}\nfunction getChildren(nodes, id) {\n    let allChildren = nodes.filter((node)=>{\n        var _node$context;\n        return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n    });\n    let currentChildren = allChildren;\n    while(currentChildren.length){\n        currentChildren = nodes.filter((node)=>{\n            var _currentChildren;\n            return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some((n)=>{\n                var _node$context2;\n                return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n            });\n        });\n        allChildren = allChildren.concat(currentChildren);\n    }\n    return allChildren;\n}\nfunction getDeepestNode(nodes, id) {\n    let deepestNodeId;\n    let maxDepth = -1;\n    function findDeepest(nodeId, depth) {\n        if (depth > maxDepth) {\n            deepestNodeId = nodeId;\n            maxDepth = depth;\n        }\n        const children = getChildren(nodes, nodeId);\n        children.forEach((child)=>{\n            findDeepest(child.id, depth + 1);\n        });\n    }\n    findDeepest(id, 0);\n    return nodes.find((node)=>node.id === deepestNodeId);\n}\n// Modified to add conditional `aria-hidden` support:\n// https://github.com/theKashey/aria-hidden/blob/9220c8f4a4fd35f63bee5510a9f41a37264382d4/src/index.ts\nlet counterMap = /*#__PURE__*/ new WeakMap();\nlet uncontrolledElementsSet = /*#__PURE__*/ new WeakSet();\nlet markerMap = {};\nlet lockCount = 0;\nconst supportsInert = ()=>typeof HTMLElement !== \"undefined\" && \"inert\" in HTMLElement.prototype;\nconst unwrapHost = (node)=>node && (node.host || unwrapHost(node.parentNode));\nconst correctElements = (parent, targets)=>targets.map((target)=>{\n        if (parent.contains(target)) {\n            return target;\n        }\n        const correctedTarget = unwrapHost(target);\n        if (parent.contains(correctedTarget)) {\n            return correctedTarget;\n        }\n        return null;\n    }).filter((x)=>x != null);\nfunction applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {\n    const markerName = \"data-floating-ui-inert\";\n    const controlAttribute = inert ? \"inert\" : ariaHidden ? \"aria-hidden\" : null;\n    const avoidElements = correctElements(body, uncorrectedAvoidElements);\n    const elementsToKeep = new Set();\n    const elementsToStop = new Set(avoidElements);\n    const hiddenElements = [];\n    if (!markerMap[markerName]) {\n        markerMap[markerName] = new WeakMap();\n    }\n    const markerCounter = markerMap[markerName];\n    avoidElements.forEach(keep);\n    deep(body);\n    elementsToKeep.clear();\n    function keep(el) {\n        if (!el || elementsToKeep.has(el)) {\n            return;\n        }\n        elementsToKeep.add(el);\n        el.parentNode && keep(el.parentNode);\n    }\n    function deep(parent) {\n        if (!parent || elementsToStop.has(parent)) {\n            return;\n        }\n        Array.prototype.forEach.call(parent.children, (node)=>{\n            if (elementsToKeep.has(node)) {\n                deep(node);\n            } else {\n                const attr = controlAttribute ? node.getAttribute(controlAttribute) : null;\n                const alreadyHidden = attr !== null && attr !== \"false\";\n                const counterValue = (counterMap.get(node) || 0) + 1;\n                const markerValue = (markerCounter.get(node) || 0) + 1;\n                counterMap.set(node, counterValue);\n                markerCounter.set(node, markerValue);\n                hiddenElements.push(node);\n                if (counterValue === 1 && alreadyHidden) {\n                    uncontrolledElementsSet.add(node);\n                }\n                if (markerValue === 1) {\n                    node.setAttribute(markerName, \"\");\n                }\n                if (!alreadyHidden && controlAttribute) {\n                    node.setAttribute(controlAttribute, \"true\");\n                }\n            }\n        });\n    }\n    lockCount++;\n    return ()=>{\n        hiddenElements.forEach((element)=>{\n            const counterValue = (counterMap.get(element) || 0) - 1;\n            const markerValue = (markerCounter.get(element) || 0) - 1;\n            counterMap.set(element, counterValue);\n            markerCounter.set(element, markerValue);\n            if (!counterValue) {\n                if (!uncontrolledElementsSet.has(element) && controlAttribute) {\n                    element.removeAttribute(controlAttribute);\n                }\n                uncontrolledElementsSet.delete(element);\n            }\n            if (!markerValue) {\n                element.removeAttribute(markerName);\n            }\n        });\n        lockCount--;\n        if (!lockCount) {\n            counterMap = new WeakMap();\n            counterMap = new WeakMap();\n            uncontrolledElementsSet = new WeakSet();\n            markerMap = {};\n        }\n    };\n}\nfunction markOthers(avoidElements, ariaHidden, inert) {\n    if (ariaHidden === void 0) {\n        ariaHidden = false;\n    }\n    if (inert === void 0) {\n        inert = false;\n    }\n    const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(avoidElements[0]).body;\n    return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll(\"[aria-live]\"))), body, ariaHidden, inert);\n}\nconst getTabbableOptions = ()=>({\n        getShadowRoot: true,\n        displayCheck: // JSDOM does not support the `tabbable` library. To solve this we can\n        // check if `ResizeObserver` is a real function (not polyfilled), which\n        // determines if the current environment is JSDOM-like.\n        typeof ResizeObserver === \"function\" && ResizeObserver.toString().includes(\"[native code]\") ? \"full\" : \"none\"\n    });\nfunction getTabbableIn(container, direction) {\n    const allTabbable = (0,tabbable__WEBPACK_IMPORTED_MODULE_8__.tabbable)(container, getTabbableOptions());\n    if (direction === \"prev\") {\n        allTabbable.reverse();\n    }\n    const activeIndex = allTabbable.indexOf((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(container)));\n    const nextTabbableElements = allTabbable.slice(activeIndex + 1);\n    return nextTabbableElements[0];\n}\nfunction getNextTabbable() {\n    return getTabbableIn(document.body, \"next\");\n}\nfunction getPreviousTabbable() {\n    return getTabbableIn(document.body, \"prev\");\n}\nfunction isOutsideEvent(event, container) {\n    const containerElement = container || event.currentTarget;\n    const relatedTarget = event.relatedTarget;\n    return !relatedTarget || !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(containerElement, relatedTarget);\n}\nfunction disableFocusInside(container) {\n    const tabbableElements = (0,tabbable__WEBPACK_IMPORTED_MODULE_8__.tabbable)(container, getTabbableOptions());\n    tabbableElements.forEach((element)=>{\n        element.dataset.tabindex = element.getAttribute(\"tabindex\") || \"\";\n        element.setAttribute(\"tabindex\", \"-1\");\n    });\n}\nfunction enableFocusInside(container) {\n    const elements = container.querySelectorAll(\"[data-tabindex]\");\n    elements.forEach((element)=>{\n        const tabindex = element.dataset.tabindex;\n        delete element.dataset.tabindex;\n        if (tabindex) {\n            element.setAttribute(\"tabindex\", tabindex);\n        } else {\n            element.removeAttribute(\"tabindex\");\n        }\n    });\n}\n// See Diego Haz's Sandbox for making this logic work well on Safari/iOS:\n// https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx\nconst HIDDEN_STYLES = {\n    border: 0,\n    clip: \"rect(0 0 0 0)\",\n    height: \"1px\",\n    margin: \"-1px\",\n    overflow: \"hidden\",\n    padding: 0,\n    position: \"fixed\",\n    whiteSpace: \"nowrap\",\n    width: \"1px\",\n    top: 0,\n    left: 0\n};\nlet timeoutId;\nfunction setActiveElementOnTab(event) {\n    if (event.key === \"Tab\") {\n        event.target;\n        clearTimeout(timeoutId);\n    }\n}\nconst FocusGuard = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FocusGuard(props, ref) {\n    const [role, setRole] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    index(()=>{\n        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isSafari)()) {\n            // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n            // on VoiceOver does trigger the onFocus event, so we can use the focus\n            // trap element. On Safari, only buttons trigger the onFocus event.\n            // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n            // button role.\n            setRole(\"button\");\n        }\n        document.addEventListener(\"keydown\", setActiveElementOnTab);\n        return ()=>{\n            document.removeEventListener(\"keydown\", setActiveElementOnTab);\n        };\n    }, []);\n    const restProps = {\n        ref,\n        tabIndex: 0,\n        // Role is only for VoiceOver\n        role,\n        \"aria-hidden\": role ? undefined : true,\n        [createAttribute(\"focus-guard\")]: \"\",\n        style: HIDDEN_STYLES\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", _extends({}, props, restProps));\n});\nconst PortalContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction useFloatingPortalNode(_temp) {\n    let { id, root } = _temp === void 0 ? {} : _temp;\n    const [portalNode, setPortalNode] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const uniqueId = useId();\n    const portalContext = usePortalContext();\n    const data = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            id,\n            root,\n            portalContext,\n            uniqueId\n        }), [\n        id,\n        root,\n        portalContext,\n        uniqueId\n    ]);\n    const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    index(()=>{\n        return ()=>{\n            portalNode == null || portalNode.remove();\n        };\n    }, [\n        portalNode,\n        data\n    ]);\n    index(()=>{\n        if (dataRef.current === data) return;\n        dataRef.current = data;\n        const { id, root, portalContext, uniqueId } = data;\n        const existingIdRoot = id ? document.getElementById(id) : null;\n        const attr = createAttribute(\"portal\");\n        if (existingIdRoot) {\n            const subRoot = document.createElement(\"div\");\n            subRoot.id = uniqueId;\n            subRoot.setAttribute(attr, \"\");\n            existingIdRoot.appendChild(subRoot);\n            setPortalNode(subRoot);\n        } else {\n            let container = root || (portalContext == null ? void 0 : portalContext.portalNode);\n            if (container && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(container)) container = container.current;\n            container = container || document.body;\n            let idWrapper = null;\n            if (id) {\n                idWrapper = document.createElement(\"div\");\n                idWrapper.id = id;\n                container.appendChild(idWrapper);\n            }\n            const subRoot = document.createElement(\"div\");\n            subRoot.id = uniqueId;\n            subRoot.setAttribute(attr, \"\");\n            container = idWrapper || container;\n            container.appendChild(subRoot);\n            setPortalNode(subRoot);\n        }\n    }, [\n        data\n    ]);\n    return portalNode;\n}\n/**\n * Portals the floating element into a given container element â€” by default,\n * outside of the app root and into the body.\n * @see https://floating-ui.com/docs/FloatingPortal\n */ function FloatingPortal(_ref) {\n    let { children, id, root = null, preserveTabOrder = true } = _ref;\n    const portalNode = useFloatingPortalNode({\n        id,\n        root\n    });\n    const [focusManagerState, setFocusManagerState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const beforeOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const afterOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const beforeInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const afterInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const shouldRenderGuards = // The FocusManager and therefore floating element are currently open/\n    // rendered.\n    !!focusManagerState && // Guards are only for non-modal focus management.\n    !focusManagerState.modal && // Don't render if unmount is transitioning.\n    focusManagerState.open && preserveTabOrder && !!(root || portalNode);\n    // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {\n            return;\n        }\n        // Make sure elements inside the portal element are tabbable only when the\n        // portal has already been focused, either by tabbing into a focus trap\n        // element outside or using the mouse.\n        function onFocus(event) {\n            if (portalNode && isOutsideEvent(event)) {\n                const focusing = event.type === \"focusin\";\n                const manageFocus = focusing ? enableFocusInside : disableFocusInside;\n                manageFocus(portalNode);\n            }\n        }\n        // Listen to the event on the capture phase so they run before the focus\n        // trap elements onFocus prop is called.\n        portalNode.addEventListener(\"focusin\", onFocus, true);\n        portalNode.addEventListener(\"focusout\", onFocus, true);\n        return ()=>{\n            portalNode.removeEventListener(\"focusin\", onFocus, true);\n            portalNode.removeEventListener(\"focusout\", onFocus, true);\n        };\n    }, [\n        portalNode,\n        preserveTabOrder,\n        focusManagerState == null ? void 0 : focusManagerState.modal\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PortalContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                preserveTabOrder,\n                beforeOutsideRef,\n                afterOutsideRef,\n                beforeInsideRef,\n                afterInsideRef,\n                portalNode,\n                setFocusManagerState\n            }), [\n            preserveTabOrder,\n            portalNode\n        ])\n    }, shouldRenderGuards && portalNode && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n        \"data-type\": \"outside\",\n        ref: beforeOutsideRef,\n        onFocus: (event)=>{\n            if (isOutsideEvent(event, portalNode)) {\n                var _beforeInsideRef$curr;\n                (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();\n            } else {\n                const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n                prevTabbable == null || prevTabbable.focus();\n            }\n        }\n    }), shouldRenderGuards && portalNode && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        \"aria-owns\": portalNode.id,\n        style: HIDDEN_STYLES\n    }), portalNode && /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.createPortal)(children, portalNode), shouldRenderGuards && portalNode && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n        \"data-type\": \"outside\",\n        ref: afterOutsideRef,\n        onFocus: (event)=>{\n            if (isOutsideEvent(event, portalNode)) {\n                var _afterInsideRef$curre;\n                (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();\n            } else {\n                const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n                nextTabbable == null || nextTabbable.focus();\n                (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent));\n            }\n        }\n    }));\n}\nconst usePortalContext = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(PortalContext);\nconst LIST_LIMIT = 20;\nlet previouslyFocusedElements = [];\nfunction addPreviouslyFocusedElement(element) {\n    previouslyFocusedElements = previouslyFocusedElements.filter((el)=>el.isConnected);\n    if (element && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getNodeName)(element) !== \"body\") {\n        previouslyFocusedElements.push(element);\n        if (previouslyFocusedElements.length > LIST_LIMIT) {\n            previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);\n        }\n    }\n}\nfunction getPreviouslyFocusedElement() {\n    return previouslyFocusedElements.slice().reverse().find((el)=>el.isConnected);\n}\nconst VisuallyHiddenDismiss = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", _extends({}, props, {\n        type: \"button\",\n        ref: ref,\n        tabIndex: -1,\n        style: HIDDEN_STYLES\n    }));\n});\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */ function FloatingFocusManager(props) {\n    const { context, children, disabled = false, order = [\n        \"content\"\n    ], guards: _guards = true, initialFocus = 0, returnFocus = true, modal = true, visuallyHiddenDismiss = false, closeOnFocusOut = true } = props;\n    const { open, refs, nodeId, onOpenChange, events, dataRef, elements: { domReference, floating } } = context;\n    const ignoreInitialFocus = typeof initialFocus === \"number\" && initialFocus < 0;\n    // If the reference is a combobox and is typeable (e.g. input/textarea),\n    // there are different focus semantics. The guards should not be rendered, but\n    // aria-hidden should be applied to all nodes still. Further, the visually\n    // hidden dismiss button should only appear at the end of the list, not the\n    // start.\n    const isUntrappedTypeableCombobox = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableCombobox)(domReference) && ignoreInitialFocus;\n    // Force the guards to be rendered if the `inert` attribute is not supported.\n    const guards = supportsInert() ? _guards : true;\n    const orderRef = useLatestRef(order);\n    const initialFocusRef = useLatestRef(initialFocus);\n    const returnFocusRef = useLatestRef(returnFocus);\n    const tree = useFloatingTree();\n    const portalContext = usePortalContext();\n    const startDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const endDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const preventReturnFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const isPointerDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const isInsidePortal = portalContext != null;\n    const getTabbableContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(container) {\n        if (container === void 0) {\n            container = floating;\n        }\n        return container ? (0,tabbable__WEBPACK_IMPORTED_MODULE_8__.tabbable)(container, getTabbableOptions()) : [];\n    }, [\n        floating\n    ]);\n    const getTabbableElements = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((container)=>{\n        const content = getTabbableContent(container);\n        return orderRef.current.map((type)=>{\n            if (domReference && type === \"reference\") {\n                return domReference;\n            }\n            if (floating && type === \"floating\") {\n                return floating;\n            }\n            return content;\n        }).filter(Boolean).flat();\n    }, [\n        domReference,\n        floating,\n        orderRef,\n        getTabbableContent\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (disabled || !modal) return;\n        function onKeyDown(event) {\n            if (event.key === \"Tab\") {\n                // The focus guards have nothing to focus, so we need to stop the event.\n                if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {\n                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                }\n                const els = getTabbableElements();\n                const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n                if (orderRef.current[0] === \"reference\" && target === domReference) {\n                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                    if (event.shiftKey) {\n                        enqueueFocus(els[els.length - 1]);\n                    } else {\n                        enqueueFocus(els[1]);\n                    }\n                }\n                if (orderRef.current[1] === \"floating\" && target === floating && event.shiftKey) {\n                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                    enqueueFocus(els[0]);\n                }\n            }\n        }\n        const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating);\n        doc.addEventListener(\"keydown\", onKeyDown);\n        return ()=>{\n            doc.removeEventListener(\"keydown\", onKeyDown);\n        };\n    }, [\n        disabled,\n        domReference,\n        floating,\n        modal,\n        orderRef,\n        refs,\n        isUntrappedTypeableCombobox,\n        getTabbableContent,\n        getTabbableElements\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (disabled || !closeOnFocusOut) return;\n        // In Safari, buttons lose focus when pressing them.\n        function handlePointerDown() {\n            isPointerDownRef.current = true;\n            setTimeout(()=>{\n                isPointerDownRef.current = false;\n            });\n        }\n        function handleFocusOutside(event) {\n            const relatedTarget = event.relatedTarget;\n            queueMicrotask(()=>{\n                const movedToUnrelatedNode = !((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(domReference, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(relatedTarget, floating) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute(\"focus-guard\")) || tree && (getChildren(tree.nodesRef.current, nodeId).find((node)=>{\n                    var _node$context, _node$context2;\n                    return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);\n                }) || getAncestors(tree.nodesRef.current, nodeId).find((node)=>{\n                    var _node$context3, _node$context4;\n                    return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;\n                })));\n                // Focus did not move inside the floating tree, and there are no tabbable\n                // portal guards to handle closing.\n                if (relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current && // Fix React 18 Strict Mode returnFocus due to double rendering.\n                relatedTarget !== getPreviouslyFocusedElement()) {\n                    preventReturnFocusRef.current = true;\n                    onOpenChange(false, event);\n                }\n            });\n        }\n        if (floating && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(domReference)) {\n            domReference.addEventListener(\"focusout\", handleFocusOutside);\n            domReference.addEventListener(\"pointerdown\", handlePointerDown);\n            !modal && floating.addEventListener(\"focusout\", handleFocusOutside);\n            return ()=>{\n                domReference.removeEventListener(\"focusout\", handleFocusOutside);\n                domReference.removeEventListener(\"pointerdown\", handlePointerDown);\n                !modal && floating.removeEventListener(\"focusout\", handleFocusOutside);\n            };\n        }\n    }, [\n        disabled,\n        domReference,\n        floating,\n        modal,\n        nodeId,\n        tree,\n        portalContext,\n        onOpenChange,\n        closeOnFocusOut\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        var _portalContext$portal;\n        if (disabled) return;\n        // Don't hide portals nested within the parent portal.\n        const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll(\"[\" + createAttribute(\"portal\") + \"]\")) || []);\n        if (floating) {\n            const insideElements = [\n                floating,\n                ...portalNodes,\n                startDismissButtonRef.current,\n                endDismissButtonRef.current,\n                orderRef.current.includes(\"reference\") || isUntrappedTypeableCombobox ? domReference : null\n            ].filter((x)=>x != null);\n            const cleanup = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, guards, !guards) : markOthers(insideElements);\n            return ()=>{\n                cleanup();\n            };\n        }\n    }, [\n        disabled,\n        domReference,\n        floating,\n        modal,\n        orderRef,\n        portalContext,\n        isUntrappedTypeableCombobox,\n        guards\n    ]);\n    index(()=>{\n        if (disabled || !floating) return;\n        const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating);\n        const previouslyFocusedElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(doc);\n        // Wait for any layout effect state setters to execute to set `tabIndex`.\n        queueMicrotask(()=>{\n            const focusableElements = getTabbableElements(floating);\n            const initialFocusValue = initialFocusRef.current;\n            const elToFocus = (typeof initialFocusValue === \"number\" ? focusableElements[initialFocusValue] : initialFocusValue.current) || floating;\n            const focusAlreadyInsideFloatingEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, previouslyFocusedElement);\n            if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {\n                enqueueFocus(elToFocus, {\n                    preventScroll: elToFocus === floating\n                });\n            }\n        });\n    }, [\n        disabled,\n        open,\n        floating,\n        ignoreInitialFocus,\n        getTabbableElements,\n        initialFocusRef\n    ]);\n    index(()=>{\n        if (disabled || !floating) return;\n        let preventReturnFocusScroll = false;\n        const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating);\n        const previouslyFocusedElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(doc);\n        const contextData = dataRef.current;\n        addPreviouslyFocusedElement(previouslyFocusedElement);\n        // Dismissing via outside press should always ignore `returnFocus` to\n        // prevent unwanted scrolling.\n        function onOpenChange(_ref) {\n            let { reason, event, nested } = _ref;\n            if (reason === \"escape-key\" && refs.domReference.current) {\n                addPreviouslyFocusedElement(refs.domReference.current);\n            }\n            if (reason === \"hover\" && event.type === \"mouseleave\") {\n                preventReturnFocusRef.current = true;\n            }\n            if (reason !== \"outside-press\") return;\n            if (nested) {\n                preventReturnFocusRef.current = false;\n                preventReturnFocusScroll = true;\n            } else {\n                preventReturnFocusRef.current = !((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualClick)(event) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualPointerEvent)(event));\n            }\n        }\n        events.on(\"openchange\", onOpenChange);\n        return ()=>{\n            events.off(\"openchange\", onOpenChange);\n            const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(doc);\n            const isFocusInsideFloatingTree = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some((node)=>{\n                var _node$context5;\n                return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);\n            });\n            const shouldFocusReference = isFocusInsideFloatingTree || contextData.openEvent && [\n                \"click\",\n                \"mousedown\"\n            ].includes(contextData.openEvent.type);\n            if (shouldFocusReference && refs.domReference.current) {\n                addPreviouslyFocusedElement(refs.domReference.current);\n            }\n            const returnElement = getPreviouslyFocusedElement();\n            if (// eslint-disable-next-line react-hooks/exhaustive-deps\n            returnFocusRef.current && !preventReturnFocusRef.current && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(returnElement) && // If the focus moved somewhere else after mount, avoid returning focus\n            // since it likely entered a different element which should be\n            // respected: https://github.com/floating-ui/floating-ui/issues/2607\n            (returnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)) {\n                enqueueFocus(returnElement, {\n                    // When dismissing nested floating elements, by the time the rAF has\n                    // executed, the menus will all have been unmounted. When they try\n                    // to get focused, the calls get ignored â€” leaving the root\n                    // reference focused as desired.\n                    cancelPrevious: false,\n                    preventScroll: preventReturnFocusScroll\n                });\n            }\n        };\n    }, [\n        disabled,\n        floating,\n        returnFocusRef,\n        dataRef,\n        refs,\n        events,\n        tree,\n        nodeId\n    ]);\n    // Synchronize the `context` & `modal` value to the FloatingPortal context.\n    // It will decide whether or not it needs to render its own guards.\n    index(()=>{\n        if (disabled || !portalContext) return;\n        portalContext.setFocusManagerState({\n            modal,\n            closeOnFocusOut,\n            open,\n            onOpenChange,\n            refs\n        });\n        return ()=>{\n            portalContext.setFocusManagerState(null);\n        };\n    }, [\n        disabled,\n        portalContext,\n        modal,\n        open,\n        onOpenChange,\n        refs,\n        closeOnFocusOut\n    ]);\n    index(()=>{\n        if (disabled || !floating || typeof MutationObserver !== \"function\" || ignoreInitialFocus) {\n            return;\n        }\n        const handleMutation = ()=>{\n            const tabIndex = floating.getAttribute(\"tabindex\");\n            if (orderRef.current.includes(\"floating\") || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating)) !== refs.domReference.current && getTabbableContent().length === 0) {\n                if (tabIndex !== \"0\") {\n                    floating.setAttribute(\"tabindex\", \"0\");\n                }\n            } else if (tabIndex !== \"-1\") {\n                floating.setAttribute(\"tabindex\", \"-1\");\n            }\n        };\n        handleMutation();\n        const observer = new MutationObserver(handleMutation);\n        observer.observe(floating, {\n            childList: true,\n            subtree: true,\n            attributes: true\n        });\n        return ()=>{\n            observer.disconnect();\n        };\n    }, [\n        disabled,\n        floating,\n        refs,\n        orderRef,\n        getTabbableContent,\n        ignoreInitialFocus\n    ]);\n    function renderDismissButton(location) {\n        if (disabled || !visuallyHiddenDismiss || !modal) {\n            return null;\n        }\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(VisuallyHiddenDismiss, {\n            ref: location === \"start\" ? startDismissButtonRef : endDismissButtonRef,\n            onClick: (event)=>onOpenChange(false, event.nativeEvent)\n        }, typeof visuallyHiddenDismiss === \"string\" ? visuallyHiddenDismiss : \"Dismiss\");\n    }\n    const shouldRenderGuards = !disabled && guards && (isInsidePortal || modal);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, shouldRenderGuards && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n        \"data-type\": \"inside\",\n        ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,\n        onFocus: (event)=>{\n            if (modal) {\n                const els = getTabbableElements();\n                enqueueFocus(order[0] === \"reference\" ? els[0] : els[els.length - 1]);\n            } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n                preventReturnFocusRef.current = false;\n                if (isOutsideEvent(event, portalContext.portalNode)) {\n                    const nextTabbable = getNextTabbable() || domReference;\n                    nextTabbable == null || nextTabbable.focus();\n                } else {\n                    var _portalContext$before;\n                    (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();\n                }\n            }\n        }\n    }), !isUntrappedTypeableCombobox && renderDismissButton(\"start\"), children, renderDismissButton(\"end\"), shouldRenderGuards && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n        \"data-type\": \"inside\",\n        ref: portalContext == null ? void 0 : portalContext.afterInsideRef,\n        onFocus: (event)=>{\n            if (modal) {\n                enqueueFocus(getTabbableElements()[0]);\n            } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n                if (closeOnFocusOut) {\n                    preventReturnFocusRef.current = true;\n                }\n                if (isOutsideEvent(event, portalContext.portalNode)) {\n                    const prevTabbable = getPreviousTabbable() || domReference;\n                    prevTabbable == null || prevTabbable.focus();\n                } else {\n                    var _portalContext$afterO;\n                    (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();\n                }\n            }\n        }\n    }));\n}\nconst activeLocks = /*#__PURE__*/ new Set();\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */ const FloatingOverlay = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FloatingOverlay(_ref, ref) {\n    let { lockScroll = false, ...rest } = _ref;\n    const lockId = useId();\n    index(()=>{\n        if (!lockScroll) return;\n        activeLocks.add(lockId);\n        const isIOS = /iP(hone|ad|od)|iOS/.test((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getPlatform)());\n        const bodyStyle = document.body.style;\n        // RTL <body> scrollbar\n        const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n        const paddingProp = scrollbarX ? \"paddingLeft\" : \"paddingRight\";\n        const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n        const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.pageXOffset;\n        const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.pageYOffset;\n        bodyStyle.overflow = \"hidden\";\n        if (scrollbarWidth) {\n            bodyStyle[paddingProp] = scrollbarWidth + \"px\";\n        }\n        // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n        // technique has fewer side effects.\n        if (isIOS) {\n            var _window$visualViewpor, _window$visualViewpor2;\n            // iOS 12 does not support `visualViewport`.\n            const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;\n            const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;\n            Object.assign(bodyStyle, {\n                position: \"fixed\",\n                top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n                left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n                right: \"0\"\n            });\n        }\n        return ()=>{\n            activeLocks.delete(lockId);\n            if (activeLocks.size === 0) {\n                Object.assign(bodyStyle, {\n                    overflow: \"\",\n                    [paddingProp]: \"\"\n                });\n                if (isIOS) {\n                    Object.assign(bodyStyle, {\n                        position: \"\",\n                        top: \"\",\n                        left: \"\",\n                        right: \"\"\n                    });\n                    window.scrollTo(scrollX, scrollY);\n                }\n            }\n        };\n    }, [\n        lockId,\n        lockScroll\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", _extends({\n        ref: ref\n    }, rest, {\n        style: {\n            position: \"fixed\",\n            overflow: \"auto\",\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0,\n            ...rest.style\n        }\n    }));\n});\nfunction isButtonTarget(event) {\n    return (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(event.target) && event.target.tagName === \"BUTTON\";\n}\nfunction isSpaceIgnored(element) {\n    return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableElement)(element);\n}\n/**\n * Opens or closes the floating element when clicking the reference element.\n * @see https://floating-ui.com/docs/useClick\n */ function useClick(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, dataRef, elements: { domReference } } = context;\n    const { enabled = true, event: eventOption = \"click\", toggle = true, ignoreMouse = false, keyboardHandlers = true } = props;\n    const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const didKeyDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) return {};\n        return {\n            reference: {\n                onPointerDown (event) {\n                    pointerTypeRef.current = event.pointerType;\n                },\n                onMouseDown (event) {\n                    // Ignore all buttons except for the \"main\" button.\n                    // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n                    if (event.button !== 0) {\n                        return;\n                    }\n                    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerTypeRef.current, true) && ignoreMouse) {\n                        return;\n                    }\n                    if (eventOption === \"click\") {\n                        return;\n                    }\n                    if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === \"mousedown\" : true)) {\n                        onOpenChange(false, event.nativeEvent, \"click\");\n                    } else {\n                        // Prevent stealing focus from the floating element\n                        event.preventDefault();\n                        onOpenChange(true, event.nativeEvent, \"click\");\n                    }\n                },\n                onClick (event) {\n                    if (eventOption === \"mousedown\" && pointerTypeRef.current) {\n                        pointerTypeRef.current = undefined;\n                        return;\n                    }\n                    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerTypeRef.current, true) && ignoreMouse) {\n                        return;\n                    }\n                    if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === \"click\" : true)) {\n                        onOpenChange(false, event.nativeEvent, \"click\");\n                    } else {\n                        onOpenChange(true, event.nativeEvent, \"click\");\n                    }\n                },\n                onKeyDown (event) {\n                    pointerTypeRef.current = undefined;\n                    if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {\n                        return;\n                    }\n                    if (event.key === \" \" && !isSpaceIgnored(domReference)) {\n                        // Prevent scrolling\n                        event.preventDefault();\n                        didKeyDownRef.current = true;\n                    }\n                    if (event.key === \"Enter\") {\n                        if (open && toggle) {\n                            onOpenChange(false, event.nativeEvent, \"click\");\n                        } else {\n                            onOpenChange(true, event.nativeEvent, \"click\");\n                        }\n                    }\n                },\n                onKeyUp (event) {\n                    if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {\n                        return;\n                    }\n                    if (event.key === \" \" && didKeyDownRef.current) {\n                        didKeyDownRef.current = false;\n                        if (open && toggle) {\n                            onOpenChange(false, event.nativeEvent, \"click\");\n                        } else {\n                            onOpenChange(true, event.nativeEvent, \"click\");\n                        }\n                    }\n                }\n            }\n        };\n    }, [\n        enabled,\n        dataRef,\n        eventOption,\n        ignoreMouse,\n        keyboardHandlers,\n        domReference,\n        toggle,\n        open,\n        onOpenChange\n    ]);\n}\nfunction createVirtualElement(domRef, data) {\n    let offsetX = null;\n    let offsetY = null;\n    let isAutoUpdateEvent = false;\n    return {\n        contextElement: domRef.current || undefined,\n        getBoundingClientRect () {\n            var _domRef$current, _data$dataRef$current;\n            const domRect = ((_domRef$current = domRef.current) == null ? void 0 : _domRef$current.getBoundingClientRect()) || {\n                width: 0,\n                height: 0,\n                x: 0,\n                y: 0\n            };\n            const isXAxis = data.axis === \"x\" || data.axis === \"both\";\n            const isYAxis = data.axis === \"y\" || data.axis === \"both\";\n            const canTrackCursorOnAutoUpdate = [\n                \"mouseenter\",\n                \"mousemove\"\n            ].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || \"\") && data.pointerType !== \"touch\";\n            let width = domRect.width;\n            let height = domRect.height;\n            let x = domRect.x;\n            let y = domRect.y;\n            if (offsetX == null && data.x && isXAxis) {\n                offsetX = domRect.x - data.x;\n            }\n            if (offsetY == null && data.y && isYAxis) {\n                offsetY = domRect.y - data.y;\n            }\n            x -= offsetX || 0;\n            y -= offsetY || 0;\n            width = 0;\n            height = 0;\n            if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {\n                width = data.axis === \"y\" ? domRect.width : 0;\n                height = data.axis === \"x\" ? domRect.height : 0;\n                x = isXAxis && data.x != null ? data.x : x;\n                y = isYAxis && data.y != null ? data.y : y;\n            } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {\n                height = data.axis === \"x\" ? domRect.height : height;\n                width = data.axis === \"y\" ? domRect.width : width;\n            }\n            isAutoUpdateEvent = true;\n            return {\n                width,\n                height,\n                x,\n                y,\n                top: y,\n                right: x + width,\n                bottom: y + height,\n                left: x\n            };\n        }\n    };\n}\nfunction isMouseBasedEvent(event) {\n    return event != null && event.clientX != null;\n}\n/**\n * Positions the floating element relative to a client point (in the viewport),\n * such as the mouse position. By default, it follows the mouse cursor.\n * @see https://floating-ui.com/docs/useClientPoint\n */ function useClientPoint(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, refs, dataRef, elements: { floating } } = context;\n    const { enabled = true, axis = \"both\", x = null, y = null } = props;\n    const initialRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const cleanupListenerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const [pointerType, setPointerType] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const [reactive, setReactive] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);\n    const setReference = useEffectEvent((x, y)=>{\n        if (initialRef.current) return;\n        // Prevent setting if the open event was not a mouse-like one\n        // (e.g. focus to open, then hover over the reference element).\n        // Only apply if the event exists.\n        if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {\n            return;\n        }\n        refs.setPositionReference(createVirtualElement(refs.domReference, {\n            x,\n            y,\n            axis,\n            dataRef,\n            pointerType\n        }));\n    });\n    const handleReferenceEnterOrMove = useEffectEvent((event)=>{\n        if (x != null || y != null) return;\n        if (!open) {\n            setReference(event.clientX, event.clientY);\n        } else if (!cleanupListenerRef.current) {\n            // If there's no cleanup, there's no listener, but we want to ensure\n            // we add the listener if the cursor landed on the floating element and\n            // then back on the reference (i.e. it's interactive).\n            setReactive([]);\n        }\n    });\n    // If the pointer is a mouse-like pointer, we want to continue following the\n    // mouse even if the floating element is transitioning out. On touch\n    // devices, this is undesirable because the floating element will move to\n    // the dismissal touch point.\n    const openCheck = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerType) ? floating : open;\n    const addListener = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        // Explicitly specified `x`/`y` coordinates shouldn't add a listener.\n        if (!openCheck || !enabled || x != null || y != null) return;\n        const win = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getWindow)(refs.floating.current);\n        function handleMouseMove(event) {\n            const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n            if (!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(refs.floating.current, target)) {\n                setReference(event.clientX, event.clientY);\n            } else {\n                win.removeEventListener(\"mousemove\", handleMouseMove);\n                cleanupListenerRef.current = null;\n            }\n        }\n        if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {\n            win.addEventListener(\"mousemove\", handleMouseMove);\n            const cleanup = ()=>{\n                win.removeEventListener(\"mousemove\", handleMouseMove);\n                cleanupListenerRef.current = null;\n            };\n            cleanupListenerRef.current = cleanup;\n            return cleanup;\n        }\n        refs.setPositionReference(refs.domReference.current);\n    }, [\n        dataRef,\n        enabled,\n        openCheck,\n        refs,\n        setReference,\n        x,\n        y\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return addListener();\n    }, [\n        addListener,\n        reactive\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (enabled && !floating) {\n            initialRef.current = false;\n        }\n    }, [\n        enabled,\n        floating\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled && open) {\n            initialRef.current = true;\n        }\n    }, [\n        enabled,\n        open\n    ]);\n    index(()=>{\n        if (enabled && (x != null || y != null)) {\n            initialRef.current = false;\n            setReference(x, y);\n        }\n    }, [\n        enabled,\n        x,\n        y,\n        setReference\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) return {};\n        function setPointerTypeRef(_ref) {\n            let { pointerType } = _ref;\n            setPointerType(pointerType);\n        }\n        return {\n            reference: {\n                onPointerDown: setPointerTypeRef,\n                onPointerEnter: setPointerTypeRef,\n                onMouseMove: handleReferenceEnterOrMove,\n                onMouseEnter: handleReferenceEnterOrMove\n            }\n        };\n    }, [\n        enabled,\n        handleReferenceEnterOrMove\n    ]);\n}\nconst bubbleHandlerKeys = {\n    pointerdown: \"onPointerDown\",\n    mousedown: \"onMouseDown\",\n    click: \"onClick\"\n};\nconst captureHandlerKeys = {\n    pointerdown: \"onPointerDownCapture\",\n    mousedown: \"onMouseDownCapture\",\n    click: \"onClickCapture\"\n};\nconst normalizeProp = (normalizable)=>{\n    var _normalizable$escapeK, _normalizable$outside;\n    return {\n        escapeKey: typeof normalizable === \"boolean\" ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,\n        outsidePress: typeof normalizable === \"boolean\" ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true\n    };\n};\n/**\n * Closes the floating element when a dismissal is requested â€” by default, when\n * the user presses the `escape` key or outside of the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */ function useDismiss(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, nodeId, elements: { reference, domReference, floating }, dataRef } = context;\n    const { enabled = true, escapeKey = true, outsidePress: unstable_outsidePress = true, outsidePressEvent = \"pointerdown\", referencePress = false, referencePressEvent = \"pointerdown\", ancestorScroll = false, bubbles, capture } = props;\n    const tree = useFloatingTree();\n    const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === \"function\" ? unstable_outsidePress : ()=>false);\n    const outsidePress = typeof unstable_outsidePress === \"function\" ? outsidePressFn : unstable_outsidePress;\n    const insideReactTreeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const endedOrStartedInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const { escapeKey: escapeKeyBubbles, outsidePress: outsidePressBubbles } = normalizeProp(bubbles);\n    const { escapeKey: escapeKeyCapture, outsidePress: outsidePressCapture } = normalizeProp(capture);\n    const closeOnEscapeKeyDown = useEffectEvent((event)=>{\n        if (!open || !enabled || !escapeKey || event.key !== \"Escape\") {\n            return;\n        }\n        const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n        if (!escapeKeyBubbles) {\n            event.stopPropagation();\n            if (children.length > 0) {\n                let shouldDismiss = true;\n                children.forEach((child)=>{\n                    var _child$context;\n                    if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n                        shouldDismiss = false;\n                        return;\n                    }\n                });\n                if (!shouldDismiss) {\n                    return;\n                }\n            }\n        }\n        onOpenChange(false, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isReactEvent)(event) ? event.nativeEvent : event, \"escape-key\");\n    });\n    const closeOnEscapeKeyDownCapture = useEffectEvent((event)=>{\n        var _getTarget2;\n        const callback = ()=>{\n            var _getTarget;\n            closeOnEscapeKeyDown(event);\n            (_getTarget = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget.removeEventListener(\"keydown\", callback);\n        };\n        (_getTarget2 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget2.addEventListener(\"keydown\", callback);\n    });\n    const closeOnPressOutside = useEffectEvent((event)=>{\n        // Given developers can stop the propagation of the synthetic event,\n        // we can only be confident with a positive value.\n        const insideReactTree = insideReactTreeRef.current;\n        insideReactTreeRef.current = false;\n        // When click outside is lazy (`click` event), handle dragging.\n        // Don't close if:\n        // - The click started inside the floating element.\n        // - The click ended inside the floating element.\n        const endedOrStartedInside = endedOrStartedInsideRef.current;\n        endedOrStartedInsideRef.current = false;\n        if (outsidePressEvent === \"click\" && endedOrStartedInside) {\n            return;\n        }\n        if (insideReactTree) {\n            return;\n        }\n        if (typeof outsidePress === \"function\" && !outsidePress(event)) {\n            return;\n        }\n        const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n        const inertSelector = \"[\" + createAttribute(\"inert\") + \"]\";\n        const markers = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating).querySelectorAll(inertSelector);\n        let targetRootAncestor = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(target) ? target : null;\n        while(targetRootAncestor && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isLastTraversableNode)(targetRootAncestor)){\n            const nextParent = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getParentNode)(targetRootAncestor);\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isLastTraversableNode)(nextParent) || !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(nextParent)) {\n                break;\n            } else {\n                targetRootAncestor = nextParent;\n            }\n        }\n        // Check if the click occurred on a third-party element injected after the\n        // floating element rendered.\n        if (markers.length && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(target) && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isRootElement)(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).\n        !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(target, floating) && // If the target root element contains none of the markers, then the\n        // element was injected after the floating element rendered.\n        Array.from(markers).every((marker)=>!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(targetRootAncestor, marker))) {\n            return;\n        }\n        // Check if the click occurred on the scrollbar\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(target) && floating) {\n            // In Firefox, `target.scrollWidth > target.clientWidth` for inline\n            // elements.\n            const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;\n            const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;\n            let xCond = canScrollY && event.offsetX > target.clientWidth;\n            // In some browsers it is possible to change the <body> (or window)\n            // scrollbar to the left side, but is very rare and is difficult to\n            // check for. Plus, for modal dialogs with backdrops, it is more\n            // important that the backdrop is checked but not so much the window.\n            if (canScrollY) {\n                const isRTL = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getComputedStyle)(target).direction === \"rtl\";\n                if (isRTL) {\n                    xCond = event.offsetX <= target.offsetWidth - target.clientWidth;\n                }\n            }\n            if (xCond || canScrollX && event.offsetY > target.clientHeight) {\n                return;\n            }\n        }\n        const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some((node)=>{\n            var _node$context;\n            return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isEventTargetWithin)(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);\n        });\n        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isEventTargetWithin)(event, floating) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isEventTargetWithin)(event, domReference) || targetIsInsideChildren) {\n            return;\n        }\n        const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n        if (children.length > 0) {\n            let shouldDismiss = true;\n            children.forEach((child)=>{\n                var _child$context2;\n                if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {\n                    shouldDismiss = false;\n                    return;\n                }\n            });\n            if (!shouldDismiss) {\n                return;\n            }\n        }\n        onOpenChange(false, event, \"outside-press\");\n    });\n    const closeOnPressOutsideCapture = useEffectEvent((event)=>{\n        var _getTarget4;\n        const callback = ()=>{\n            var _getTarget3;\n            closeOnPressOutside(event);\n            (_getTarget3 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);\n        };\n        (_getTarget4 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!open || !enabled) {\n            return;\n        }\n        dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n        dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n        function onScroll(event) {\n            onOpenChange(false, event, \"ancestor-scroll\");\n        }\n        const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating);\n        escapeKey && doc.addEventListener(\"keydown\", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n        outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n        let ancestors = [];\n        if (ancestorScroll) {\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(domReference)) {\n                ancestors = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(domReference);\n            }\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(floating)) {\n                ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(floating));\n            }\n            if (!(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(reference) && reference && reference.contextElement) {\n                ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(reference.contextElement));\n            }\n        }\n        // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n        ancestors = ancestors.filter((ancestor)=>{\n            var _doc$defaultView;\n            return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n        });\n        ancestors.forEach((ancestor)=>{\n            ancestor.addEventListener(\"scroll\", onScroll, {\n                passive: true\n            });\n        });\n        return ()=>{\n            escapeKey && doc.removeEventListener(\"keydown\", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n            outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n            ancestors.forEach((ancestor)=>{\n                ancestor.removeEventListener(\"scroll\", onScroll);\n            });\n        };\n    }, [\n        dataRef,\n        floating,\n        domReference,\n        reference,\n        escapeKey,\n        outsidePress,\n        outsidePressEvent,\n        open,\n        onOpenChange,\n        ancestorScroll,\n        enabled,\n        escapeKeyBubbles,\n        outsidePressBubbles,\n        closeOnEscapeKeyDown,\n        escapeKeyCapture,\n        closeOnEscapeKeyDownCapture,\n        closeOnPressOutside,\n        outsidePressCapture,\n        closeOnPressOutsideCapture\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        insideReactTreeRef.current = false;\n    }, [\n        outsidePress,\n        outsidePressEvent\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        return {\n            reference: {\n                onKeyDown: closeOnEscapeKeyDown,\n                [bubbleHandlerKeys[referencePressEvent]]: (event)=>{\n                    if (referencePress) {\n                        onOpenChange(false, event.nativeEvent, \"reference-press\");\n                    }\n                }\n            },\n            floating: {\n                onKeyDown: closeOnEscapeKeyDown,\n                onMouseDown () {\n                    endedOrStartedInsideRef.current = true;\n                },\n                onMouseUp () {\n                    endedOrStartedInsideRef.current = true;\n                },\n                [captureHandlerKeys[outsidePressEvent]]: ()=>{\n                    insideReactTreeRef.current = true;\n                }\n            }\n        };\n    }, [\n        enabled,\n        referencePress,\n        outsidePressEvent,\n        referencePressEvent,\n        onOpenChange,\n        closeOnEscapeKeyDown\n    ]);\n}\nlet devMessageSet;\nif (true) {\n    devMessageSet = /*#__PURE__*/ new Set();\n}\n/**\n * Provides data to position a floating element and context to add interactions.\n * @see https://floating-ui.com/docs/useFloating\n */ function useFloating(options) {\n    var _options$elements2;\n    if (options === void 0) {\n        options = {};\n    }\n    const { open = false, onOpenChange: unstable_onOpenChange, nodeId } = options;\n    if (true) {\n        var _options$elements;\n        const err = \"Floating UI: Cannot pass a virtual element to the \" + \"`elements.reference` option, as it must be a real DOM element. \" + \"Use `refs.setPositionReference` instead.\";\n        if ((_options$elements = options.elements) != null && _options$elements.reference && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(options.elements.reference)) {\n            var _devMessageSet;\n            if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(err))) {\n                var _devMessageSet2;\n                (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(err);\n                console.error(err);\n            }\n        }\n    }\n    const [_domReference, setDomReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const domReference = ((_options$elements2 = options.elements) == null ? void 0 : _options$elements2.reference) || _domReference;\n    const position = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.useFloating)(options);\n    const tree = useFloatingTree();\n    const nested = useFloatingParentNodeId() != null;\n    const onOpenChange = useEffectEvent((open, event, reason)=>{\n        if (open) {\n            dataRef.current.openEvent = event;\n        }\n        events.emit(\"openchange\", {\n            open,\n            event,\n            reason,\n            nested\n        });\n        unstable_onOpenChange == null || unstable_onOpenChange(open, event, reason);\n    });\n    const domReferenceRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});\n    const events = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>createPubSub())[0];\n    const floatingId = useId();\n    const setPositionReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        const positionReference = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(node) ? {\n            getBoundingClientRect: ()=>node.getBoundingClientRect(),\n            contextElement: node\n        } : node;\n        position.refs.setReference(positionReference);\n    }, [\n        position.refs\n    ]);\n    const setReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(node) || node === null) {\n            domReferenceRef.current = node;\n            setDomReference(node);\n        }\n        // Backwards-compatibility for passing a virtual element to `reference`\n        // after it has set the DOM reference.\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to\n        // `null` to support `positionReference` + an unstable `reference`\n        // callback ref.\n        node !== null && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(node)) {\n            position.refs.setReference(node);\n        }\n    }, [\n        position.refs\n    ]);\n    const refs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position.refs,\n            setReference,\n            setPositionReference,\n            domReference: domReferenceRef\n        }), [\n        position.refs,\n        setReference,\n        setPositionReference\n    ]);\n    const elements = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position.elements,\n            domReference: domReference\n        }), [\n        position.elements,\n        domReference\n    ]);\n    const context = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position,\n            refs,\n            elements,\n            dataRef,\n            nodeId,\n            floatingId,\n            events,\n            open,\n            onOpenChange\n        }), [\n        position,\n        nodeId,\n        floatingId,\n        events,\n        open,\n        onOpenChange,\n        refs,\n        elements\n    ]);\n    index(()=>{\n        const node = tree == null ? void 0 : tree.nodesRef.current.find((node)=>node.id === nodeId);\n        if (node) {\n            node.context = context;\n        }\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position,\n            context,\n            refs,\n            elements\n        }), [\n        position,\n        refs,\n        elements,\n        context\n    ]);\n}\n/**\n * Opens the floating element while the reference element has focus, like CSS\n * `:focus`.\n * @see https://floating-ui.com/docs/useFocus\n */ function useFocus(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, events, refs, elements: { floating, domReference } } = context;\n    const { enabled = true, visibleOnly = true } = props;\n    const blockFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const keyboardModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        const win = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getWindow)(domReference);\n        // If the reference was focused and the user left the tab/window, and the\n        // floating element was not open, the focus should be blocked when they\n        // return to the tab/window.\n        function onBlur() {\n            if (!open && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(domReference) && domReference === (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(domReference))) {\n                blockFocusRef.current = true;\n            }\n        }\n        function onKeyDown() {\n            keyboardModalityRef.current = true;\n        }\n        win.addEventListener(\"blur\", onBlur);\n        win.addEventListener(\"keydown\", onKeyDown, true);\n        return ()=>{\n            win.removeEventListener(\"blur\", onBlur);\n            win.removeEventListener(\"keydown\", onKeyDown, true);\n        };\n    }, [\n        floating,\n        domReference,\n        open,\n        enabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        function onOpenChange(_ref) {\n            let { reason } = _ref;\n            if (reason === \"reference-press\" || reason === \"escape-key\") {\n                blockFocusRef.current = true;\n            }\n        }\n        events.on(\"openchange\", onOpenChange);\n        return ()=>{\n            events.off(\"openchange\", onOpenChange);\n        };\n    }, [\n        events,\n        enabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>{\n            clearTimeout(timeoutRef.current);\n        };\n    }, []);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        return {\n            reference: {\n                onPointerDown (event) {\n                    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualPointerEvent)(event.nativeEvent)) return;\n                    keyboardModalityRef.current = false;\n                },\n                onMouseLeave () {\n                    blockFocusRef.current = false;\n                },\n                onFocus (event) {\n                    if (blockFocusRef.current) return;\n                    const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event.nativeEvent);\n                    if (visibleOnly && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(target)) {\n                        try {\n                            // Mac Safari unreliably matches `:focus-visible` on the reference\n                            // if focus was outside the page initially - use the fallback\n                            // instead.\n                            if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isSafari)() && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMac)()) throw Error();\n                            if (!target.matches(\":focus-visible\")) return;\n                        } catch (e) {\n                            // Old browsers will throw an error when using `:focus-visible`.\n                            if (!keyboardModalityRef.current && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableElement)(target)) {\n                                return;\n                            }\n                        }\n                    }\n                    onOpenChange(true, event.nativeEvent, \"focus\");\n                },\n                onBlur (event) {\n                    blockFocusRef.current = false;\n                    const relatedTarget = event.relatedTarget;\n                    // Hit the non-modal focus management portal guard. Focus will be\n                    // moved into the floating element immediately after.\n                    const movedToFocusGuard = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(relatedTarget) && relatedTarget.hasAttribute(createAttribute(\"focus-guard\")) && relatedTarget.getAttribute(\"data-type\") === \"outside\";\n                    // Wait for the window blur listener to fire.\n                    timeoutRef.current = window.setTimeout(()=>{\n                        const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(domReference ? domReference.ownerDocument : document);\n                        // Focus left the page, keep it open.\n                        if (!relatedTarget && activeEl === domReference) return;\n                        // When focusing the reference element (e.g. regular click), then\n                        // clicking into the floating element, prevent it from hiding.\n                        // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n                        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(refs.floating.current, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(domReference, relatedTarget) || movedToFocusGuard) {\n                            return;\n                        }\n                        onOpenChange(false, event.nativeEvent, \"focus\");\n                    });\n                }\n            }\n        };\n    }, [\n        enabled,\n        visibleOnly,\n        domReference,\n        refs,\n        onOpenChange\n    ]);\n}\nconst ACTIVE_KEY = \"active\";\nconst SELECTED_KEY = \"selected\";\nfunction mergeProps(userProps, propsList, elementKey) {\n    const map = new Map();\n    const isItem = elementKey === \"item\";\n    let domUserProps = userProps;\n    if (isItem && userProps) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { [ACTIVE_KEY]: _, [SELECTED_KEY]: __, ...validProps } = userProps;\n        domUserProps = validProps;\n    }\n    return {\n        ...elementKey === \"floating\" && {\n            tabIndex: -1\n        },\n        ...domUserProps,\n        ...propsList.map((value)=>{\n            const propsOrGetProps = value ? value[elementKey] : null;\n            if (typeof propsOrGetProps === \"function\") {\n                return userProps ? propsOrGetProps(userProps) : null;\n            }\n            return propsOrGetProps;\n        }).concat(userProps).reduce((acc, props)=>{\n            if (!props) {\n                return acc;\n            }\n            Object.entries(props).forEach((_ref)=>{\n                let [key, value] = _ref;\n                if (isItem && [\n                    ACTIVE_KEY,\n                    SELECTED_KEY\n                ].includes(key)) {\n                    return;\n                }\n                if (key.indexOf(\"on\") === 0) {\n                    if (!map.has(key)) {\n                        map.set(key, []);\n                    }\n                    if (typeof value === \"function\") {\n                        var _map$get;\n                        (_map$get = map.get(key)) == null || _map$get.push(value);\n                        acc[key] = function() {\n                            var _map$get2;\n                            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                                args[_key] = arguments[_key];\n                            }\n                            return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn)=>fn(...args)).find((val)=>val !== undefined);\n                        };\n                    }\n                } else {\n                    acc[key] = value;\n                }\n            });\n            return acc;\n        }, {})\n    };\n}\n/**\n * Merges an array of interaction hooks' props into prop getters, allowing\n * event handler functions to be composed together without overwriting one\n * another.\n * @see https://floating-ui.com/docs/useInteractions\n */ function useInteractions(propsList) {\n    if (propsList === void 0) {\n        propsList = [];\n    }\n    // The dependencies are a dynamic array, so we can't use the linter's\n    // suggestion to add it to the deps array.\n    const deps = propsList;\n    const getReferenceProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((userProps)=>mergeProps(userProps, propsList, \"reference\"), // eslint-disable-next-line react-hooks/exhaustive-deps\n    deps);\n    const getFloatingProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((userProps)=>mergeProps(userProps, propsList, \"floating\"), // eslint-disable-next-line react-hooks/exhaustive-deps\n    deps);\n    const getItemProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((userProps)=>mergeProps(userProps, propsList, \"item\"), // Granularly check for `item` changes, because the `getItemProps` getter\n    // should be as referentially stable as possible since it may be passed as\n    // a prop to many components. All `item` key values must therefore be\n    // memoized.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    propsList.map((key)=>key == null ? void 0 : key.item));\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            getReferenceProps,\n            getFloatingProps,\n            getItemProps\n        }), [\n        getReferenceProps,\n        getFloatingProps,\n        getItemProps\n    ]);\n}\nlet isPreventScrollSupported = false;\nfunction doSwitch(orientation, vertical, horizontal) {\n    switch(orientation){\n        case \"vertical\":\n            return vertical;\n        case \"horizontal\":\n            return horizontal;\n        default:\n            return vertical || horizontal;\n    }\n}\nfunction isMainOrientationKey(key, orientation) {\n    const vertical = key === ARROW_UP || key === ARROW_DOWN;\n    const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n    return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n    const vertical = key === ARROW_DOWN;\n    const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n    return doSwitch(orientation, vertical, horizontal) || key === \"Enter\" || key == \" \" || key === \"\";\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n    const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n    const horizontal = key === ARROW_DOWN;\n    return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl) {\n    const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n    const horizontal = key === ARROW_UP;\n    return doSwitch(orientation, vertical, horizontal);\n}\n/**\n * Adds arrow key-based navigation of a list of items, either using real DOM\n * focus or virtual focus.\n * @see https://floating-ui.com/docs/useListNavigation\n */ function useListNavigation(context, props) {\n    const { open, onOpenChange, refs, elements: { domReference, floating } } = context;\n    const { listRef, activeIndex, onNavigate: unstable_onNavigate = ()=>{}, enabled = true, selectedIndex = null, allowEscape = false, loop = false, nested = false, rtl = false, virtual = false, focusItemOnOpen = \"auto\", focusItemOnHover = true, openOnArrowKeyDown = true, disabledIndices = undefined, orientation = \"vertical\", cols = 1, scrollItemIntoView = true, virtualItemRef } = props;\n    if (true) {\n        if (allowEscape) {\n            if (!loop) {\n                console.warn([\n                    \"Floating UI: `useListNavigation` looping must be enabled to allow\",\n                    \"escaping.\"\n                ].join(\" \"));\n            }\n            if (!virtual) {\n                console.warn([\n                    \"Floating UI: `useListNavigation` must be virtual to allow\",\n                    \"escaping.\"\n                ].join(\" \"));\n            }\n        }\n        if (orientation === \"vertical\" && cols > 1) {\n            console.warn([\n                \"Floating UI: In grid list navigation mode (`cols` > 1), the\",\n                '`orientation` should be either \"horizontal\" or \"both\".'\n            ].join(\" \"));\n        }\n    }\n    const parentId = useFloatingParentNodeId();\n    const tree = useFloatingTree();\n    const onNavigate = useEffectEvent(unstable_onNavigate);\n    const focusItemOnOpenRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(focusItemOnOpen);\n    const indexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(selectedIndex != null ? selectedIndex : -1);\n    const keyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const isPointerModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    const previousOnNavigateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onNavigate);\n    const previousMountedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(!!floating);\n    const forceSyncFocus = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const forceScrollIntoViewRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const disabledIndicesRef = useLatestRef(disabledIndices);\n    const latestOpenRef = useLatestRef(open);\n    const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);\n    const [activeId, setActiveId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const [virtualId, setVirtualId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const focusItem = useEffectEvent(function(listRef, indexRef, forceScrollIntoView) {\n        if (forceScrollIntoView === void 0) {\n            forceScrollIntoView = false;\n        }\n        const item = listRef.current[indexRef.current];\n        if (!item) return;\n        if (virtual) {\n            setActiveId(item.id);\n            tree == null || tree.events.emit(\"virtualfocus\", item);\n            if (virtualItemRef) {\n                virtualItemRef.current = item;\n            }\n        } else {\n            enqueueFocus(item, {\n                preventScroll: true,\n                // Mac Safari does not move the virtual cursor unless the focus call\n                // is sync. However, for the very first focus call, we need to wait\n                // for the position to be ready in order to prevent unwanted\n                // scrolling. This means the virtual cursor will not move to the first\n                // item when first opening the floating element, but will on\n                // subsequent calls. `preventScroll` is supported in modern Safari,\n                // so we can use that instead.\n                // iOS Safari must be async or the first item will not be focused.\n                sync: (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMac)() && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isSafari)() ? isPreventScrollSupported || forceSyncFocus.current : false\n            });\n        }\n        requestAnimationFrame(()=>{\n            const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n            const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);\n            if (shouldScrollIntoView) {\n                // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n                // by all browsers.\n                item.scrollIntoView == null || item.scrollIntoView(typeof scrollIntoViewOptions === \"boolean\" ? {\n                    block: \"nearest\",\n                    inline: \"nearest\"\n                } : scrollIntoViewOptions);\n            }\n        });\n    });\n    index(()=>{\n        document.createElement(\"div\").focus({\n            get preventScroll () {\n                isPreventScrollSupported = true;\n                return false;\n            }\n        });\n    }, []);\n    // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n    // element. Also, reset `activeIndex` upon closing the floating element.\n    index(()=>{\n        if (!enabled) {\n            return;\n        }\n        if (open && floating) {\n            if (focusItemOnOpenRef.current && selectedIndex != null) {\n                // Regardless of the pointer modality, we want to ensure the selected\n                // item comes into view when the floating element is opened.\n                forceScrollIntoViewRef.current = true;\n                onNavigate(selectedIndex);\n            }\n        } else if (previousMountedRef.current) {\n            // Since the user can specify `onNavigate` conditionally\n            // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n            // we store and call the previous function.\n            indexRef.current = -1;\n            previousOnNavigateRef.current(null);\n        }\n    }, [\n        enabled,\n        open,\n        floating,\n        selectedIndex,\n        onNavigate\n    ]);\n    // Sync `activeIndex` to be the focused item while the floating element is\n    // open.\n    index(()=>{\n        if (!enabled) {\n            return;\n        }\n        if (open && floating) {\n            if (activeIndex == null) {\n                forceSyncFocus.current = false;\n                if (selectedIndex != null) {\n                    return;\n                }\n                // Reset while the floating element was open (e.g. the list changed).\n                if (previousMountedRef.current) {\n                    indexRef.current = -1;\n                    focusItem(listRef, indexRef);\n                }\n                // Initial sync.\n                if (!previousMountedRef.current && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n                    let runs = 0;\n                    const waitForListPopulated = ()=>{\n                        if (listRef.current[0] == null) {\n                            // Avoid letting the browser paint if possible on the first try,\n                            // otherwise use rAF. Don't try more than twice, since something\n                            // is wrong otherwise.\n                            if (runs < 2) {\n                                const scheduler = runs ? requestAnimationFrame : queueMicrotask;\n                                scheduler(waitForListPopulated);\n                            }\n                            runs++;\n                        } else {\n                            indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n                            keyRef.current = null;\n                            onNavigate(indexRef.current);\n                        }\n                    };\n                    waitForListPopulated();\n                }\n            } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n                indexRef.current = activeIndex;\n                focusItem(listRef, indexRef, forceScrollIntoViewRef.current);\n                forceScrollIntoViewRef.current = false;\n            }\n        }\n    }, [\n        enabled,\n        open,\n        floating,\n        activeIndex,\n        selectedIndex,\n        nested,\n        listRef,\n        orientation,\n        rtl,\n        onNavigate,\n        focusItem,\n        disabledIndicesRef\n    ]);\n    // Ensure the parent floating element has focus when a nested child closes\n    // to allow arrow key navigation to work after the pointer leaves the child.\n    index(()=>{\n        var _nodes$find;\n        if (!enabled || floating || !tree || virtual || !previousMountedRef.current) {\n            return;\n        }\n        const nodes = tree.nodesRef.current;\n        const parent = (_nodes$find = nodes.find((node)=>node.id === parentId)) == null || (_nodes$find = _nodes$find.context) == null ? void 0 : _nodes$find.elements.floating;\n        const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating));\n        const treeContainsActiveEl = nodes.some((node)=>node.context && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(node.context.elements.floating, activeEl));\n        if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {\n            parent.focus({\n                preventScroll: true\n            });\n        }\n    }, [\n        enabled,\n        floating,\n        tree,\n        parentId,\n        virtual\n    ]);\n    index(()=>{\n        if (!enabled || !tree || !virtual || parentId) return;\n        function handleVirtualFocus(item) {\n            setVirtualId(item.id);\n            if (virtualItemRef) {\n                virtualItemRef.current = item;\n            }\n        }\n        tree.events.on(\"virtualfocus\", handleVirtualFocus);\n        return ()=>{\n            tree.events.off(\"virtualfocus\", handleVirtualFocus);\n        };\n    }, [\n        enabled,\n        tree,\n        virtual,\n        parentId,\n        virtualItemRef\n    ]);\n    index(()=>{\n        previousOnNavigateRef.current = onNavigate;\n        previousMountedRef.current = !!floating;\n    });\n    index(()=>{\n        if (!open) {\n            keyRef.current = null;\n        }\n    }, [\n        open\n    ]);\n    const hasActiveIndex = activeIndex != null;\n    const item = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        function syncCurrentTarget(currentTarget) {\n            if (!open) return;\n            const index = listRef.current.indexOf(currentTarget);\n            if (index !== -1) {\n                onNavigate(index);\n            }\n        }\n        const props = {\n            onFocus (_ref) {\n                let { currentTarget } = _ref;\n                syncCurrentTarget(currentTarget);\n            },\n            onClick: (_ref2)=>{\n                let { currentTarget } = _ref2;\n                return currentTarget.focus({\n                    preventScroll: true\n                });\n            },\n            // Safari\n            ...focusItemOnHover && {\n                onMouseMove (_ref3) {\n                    let { currentTarget } = _ref3;\n                    syncCurrentTarget(currentTarget);\n                },\n                onPointerLeave (_ref4) {\n                    let { pointerType } = _ref4;\n                    if (!isPointerModalityRef.current || pointerType === \"touch\") {\n                        return;\n                    }\n                    indexRef.current = -1;\n                    focusItem(listRef, indexRef);\n                    onNavigate(null);\n                    if (!virtual) {\n                        enqueueFocus(refs.floating.current, {\n                            preventScroll: true\n                        });\n                    }\n                }\n            }\n        };\n        return props;\n    }, [\n        open,\n        refs,\n        focusItem,\n        focusItemOnHover,\n        listRef,\n        onNavigate,\n        virtual\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        const disabledIndices = disabledIndicesRef.current;\n        function onKeyDown(event) {\n            isPointerModalityRef.current = false;\n            forceSyncFocus.current = true;\n            // If the floating element is animating out, ignore navigation. Otherwise,\n            // the `activeIndex` gets set to 0 despite not being open so the next time\n            // the user ArrowDowns, the first item won't be focused.\n            if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {\n                return;\n            }\n            if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                onOpenChange(false, event.nativeEvent, \"list-navigation\");\n                if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(domReference) && !virtual) {\n                    domReference.focus();\n                }\n                return;\n            }\n            const currentIndex = indexRef.current;\n            const minIndex = getMinIndex(listRef, disabledIndices);\n            const maxIndex = getMaxIndex(listRef, disabledIndices);\n            if (event.key === \"Home\") {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                indexRef.current = minIndex;\n                onNavigate(indexRef.current);\n            }\n            if (event.key === \"End\") {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                indexRef.current = maxIndex;\n                onNavigate(indexRef.current);\n            }\n            // Grid navigation.\n            if (cols > 1) {\n                indexRef.current = getGridNavigatedIndex(listRef, {\n                    event,\n                    orientation,\n                    loop,\n                    cols,\n                    disabledIndices,\n                    minIndex,\n                    maxIndex,\n                    prevIndex: indexRef.current,\n                    stopEvent: true\n                });\n                onNavigate(indexRef.current);\n                if (orientation === \"both\") {\n                    return;\n                }\n            }\n            if (isMainOrientationKey(event.key, orientation)) {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                // Reset the index if no item is focused.\n                if (open && !virtual && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(event.currentTarget.ownerDocument) === event.currentTarget) {\n                    indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n                    onNavigate(indexRef.current);\n                    return;\n                }\n                if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n                    if (loop) {\n                        indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n                            startingIndex: currentIndex,\n                            disabledIndices\n                        });\n                    } else {\n                        indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n                            startingIndex: currentIndex,\n                            disabledIndices\n                        }));\n                    }\n                } else {\n                    if (loop) {\n                        indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n                            startingIndex: currentIndex,\n                            decrement: true,\n                            disabledIndices\n                        });\n                    } else {\n                        indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n                            startingIndex: currentIndex,\n                            decrement: true,\n                            disabledIndices\n                        }));\n                    }\n                }\n                if (isIndexOutOfBounds(listRef, indexRef.current)) {\n                    onNavigate(null);\n                } else {\n                    onNavigate(indexRef.current);\n                }\n            }\n        }\n        function checkVirtualMouse(event) {\n            if (focusItemOnOpen === \"auto\" && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualClick)(event.nativeEvent)) {\n                focusItemOnOpenRef.current = true;\n            }\n        }\n        function checkVirtualPointer(event) {\n            // `pointerdown` fires first, reset the state then perform the checks.\n            focusItemOnOpenRef.current = focusItemOnOpen;\n            if (focusItemOnOpen === \"auto\" && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualPointerEvent)(event.nativeEvent)) {\n                focusItemOnOpenRef.current = true;\n            }\n        }\n        const ariaActiveDescendantProp = virtual && open && hasActiveIndex && {\n            \"aria-activedescendant\": virtualId || activeId\n        };\n        const activeItem = listRef.current.find((item)=>(item == null ? void 0 : item.id) === activeId);\n        return {\n            reference: {\n                ...ariaActiveDescendantProp,\n                onKeyDown (event) {\n                    isPointerModalityRef.current = false;\n                    const isArrowKey = event.key.indexOf(\"Arrow\") === 0;\n                    const isCrossOpenKey = isCrossOrientationOpenKey(event.key, orientation, rtl);\n                    const isCrossCloseKey = isCrossOrientationCloseKey(event.key, orientation, rtl);\n                    const isMainKey = isMainOrientationKey(event.key, orientation);\n                    const isNavigationKey = (nested ? isCrossOpenKey : isMainKey) || event.key === \"Enter\" || event.key.trim() === \"\";\n                    if (virtual && open) {\n                        const rootNode = tree == null ? void 0 : tree.nodesRef.current.find((node)=>node.parentId == null);\n                        const deepestNode = tree && rootNode ? getDeepestNode(tree.nodesRef.current, rootNode.id) : null;\n                        if (isArrowKey && deepestNode && virtualItemRef) {\n                            const eventObject = new KeyboardEvent(\"keydown\", {\n                                key: event.key,\n                                bubbles: true\n                            });\n                            if (isCrossOpenKey || isCrossCloseKey) {\n                                var _deepestNode$context, _deepestNode$context2;\n                                const isCurrentTarget = ((_deepestNode$context = deepestNode.context) == null ? void 0 : _deepestNode$context.elements.domReference) === event.currentTarget;\n                                const dispatchItem = isCrossCloseKey && !isCurrentTarget ? (_deepestNode$context2 = deepestNode.context) == null ? void 0 : _deepestNode$context2.elements.domReference : isCrossOpenKey ? activeItem : null;\n                                if (dispatchItem) {\n                                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                                    dispatchItem.dispatchEvent(eventObject);\n                                    setVirtualId(undefined);\n                                }\n                            }\n                            if (isMainKey && deepestNode.context) {\n                                if (deepestNode.context.open && deepestNode.parentId && event.currentTarget !== deepestNode.context.elements.domReference) {\n                                    var _deepestNode$context$;\n                                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                                    (_deepestNode$context$ = deepestNode.context.elements.domReference) == null || _deepestNode$context$.dispatchEvent(eventObject);\n                                    return;\n                                }\n                            }\n                        }\n                        return onKeyDown(event);\n                    }\n                    // If a floating element should not open on arrow key down, avoid\n                    // setting `activeIndex` while it's closed.\n                    if (!open && !openOnArrowKeyDown && isArrowKey) {\n                        return;\n                    }\n                    if (isNavigationKey) {\n                        keyRef.current = nested && isMainKey ? null : event.key;\n                    }\n                    if (nested) {\n                        if (isCrossOpenKey) {\n                            (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                            if (open) {\n                                indexRef.current = getMinIndex(listRef, disabledIndices);\n                                onNavigate(indexRef.current);\n                            } else {\n                                onOpenChange(true, event.nativeEvent, \"list-navigation\");\n                            }\n                        }\n                        return;\n                    }\n                    if (isMainKey) {\n                        if (selectedIndex != null) {\n                            indexRef.current = selectedIndex;\n                        }\n                        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                        if (!open && openOnArrowKeyDown) {\n                            onOpenChange(true, event.nativeEvent, \"list-navigation\");\n                        } else {\n                            onKeyDown(event);\n                        }\n                        if (open) {\n                            onNavigate(indexRef.current);\n                        }\n                    }\n                },\n                onFocus () {\n                    if (open) {\n                        onNavigate(null);\n                    }\n                },\n                onPointerDown: checkVirtualPointer,\n                onMouseDown: checkVirtualMouse,\n                onClick: checkVirtualMouse\n            },\n            floating: {\n                \"aria-orientation\": orientation === \"both\" ? undefined : orientation,\n                ...!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableCombobox)(domReference) && ariaActiveDescendantProp,\n                onKeyDown,\n                onPointerMove () {\n                    isPointerModalityRef.current = true;\n                }\n            },\n            item\n        };\n    }, [\n        domReference,\n        refs,\n        activeId,\n        virtualId,\n        disabledIndicesRef,\n        latestOpenRef,\n        listRef,\n        enabled,\n        orientation,\n        rtl,\n        virtual,\n        open,\n        hasActiveIndex,\n        nested,\n        selectedIndex,\n        openOnArrowKeyDown,\n        allowEscape,\n        cols,\n        loop,\n        focusItemOnOpen,\n        onNavigate,\n        onOpenChange,\n        item,\n        tree,\n        virtualItemRef\n    ]);\n}\nconst componentRoleToAriaRoleMap = /*#__PURE__*/ new Map([\n    [\n        \"select\",\n        \"listbox\"\n    ],\n    [\n        \"combobox\",\n        \"listbox\"\n    ],\n    [\n        \"label\",\n        false\n    ]\n]);\n/**\n * Adds base screen reader props to the reference and floating elements for a\n * given floating element `role`.\n * @see https://floating-ui.com/docs/useRole\n */ function useRole(context, props) {\n    var _componentRoleToAriaR;\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, floatingId } = context;\n    const { enabled = true, role = \"dialog\" } = props;\n    const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;\n    const referenceId = useId();\n    const parentId = useFloatingParentNodeId();\n    const isNested = parentId != null;\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) return {};\n        const floatingProps = {\n            id: floatingId,\n            ...ariaRole && {\n                role: ariaRole\n            }\n        };\n        if (ariaRole === \"tooltip\" || role === \"label\") {\n            return {\n                reference: {\n                    [\"aria-\" + (role === \"label\" ? \"labelledby\" : \"describedby\")]: open ? floatingId : undefined\n                },\n                floating: floatingProps\n            };\n        }\n        return {\n            reference: {\n                \"aria-expanded\": open ? \"true\" : \"false\",\n                \"aria-haspopup\": ariaRole === \"alertdialog\" ? \"dialog\" : ariaRole,\n                \"aria-controls\": open ? floatingId : undefined,\n                ...ariaRole === \"listbox\" && {\n                    role: \"combobox\"\n                },\n                ...ariaRole === \"menu\" && {\n                    id: referenceId\n                },\n                ...ariaRole === \"menu\" && isNested && {\n                    role: \"menuitem\"\n                },\n                ...role === \"select\" && {\n                    \"aria-autocomplete\": \"none\"\n                },\n                ...role === \"combobox\" && {\n                    \"aria-autocomplete\": \"list\"\n                }\n            },\n            floating: {\n                ...floatingProps,\n                ...ariaRole === \"menu\" && {\n                    \"aria-labelledby\": referenceId\n                }\n            },\n            item (_ref) {\n                let { active, selected } = _ref;\n                const commonProps = {\n                    role: \"option\",\n                    ...active && {\n                        id: floatingId + \"-option\"\n                    }\n                };\n                // For `menu`, we are unable to tell if the item is a `menuitemradio`\n                // or `menuitemcheckbox`. For backwards-compatibility reasons, also\n                // avoid defaulting to `menuitem` as it may overwrite custom role props.\n                switch(role){\n                    case \"select\":\n                        return {\n                            ...commonProps,\n                            \"aria-selected\": active && selected\n                        };\n                    case \"combobox\":\n                        {\n                            return {\n                                ...commonProps,\n                                ...active && {\n                                    \"aria-selected\": true\n                                }\n                            };\n                        }\n                }\n                return {};\n            }\n        };\n    }, [\n        enabled,\n        role,\n        ariaRole,\n        open,\n        floatingId,\n        referenceId,\n        isNested\n    ]);\n}\n// Converts a JS style key like `backgroundColor` to a CSS transition-property\n// like `background-color`.\nconst camelCaseToKebabCase = (str)=>str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs)=>(ofs ? \"-\" : \"\") + $.toLowerCase());\nfunction execWithArgsOrReturn(valueOrFn, args) {\n    return typeof valueOrFn === \"function\" ? valueOrFn(args) : valueOrFn;\n}\nfunction useDelayUnmount(open, durationMs) {\n    const [isMounted, setIsMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(open);\n    if (open && !isMounted) {\n        setIsMounted(true);\n    }\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!open) {\n            const timeout = setTimeout(()=>setIsMounted(false), durationMs);\n            return ()=>clearTimeout(timeout);\n        }\n    }, [\n        open,\n        durationMs\n    ]);\n    return isMounted;\n}\n/**\n * Provides a status string to apply CSS transitions to a floating element,\n * correctly handling placement-aware transitions.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\n */ function useTransitionStatus(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, elements: { floating } } = context;\n    const { duration = 250 } = props;\n    const isNumberDuration = typeof duration === \"number\";\n    const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n    const [initiated, setInitiated] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [status, setStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\"unmounted\");\n    const isMounted = useDelayUnmount(open, closeDuration);\n    // `initiated` check prevents this `setState` call from breaking\n    // <FloatingPortal />. This call is necessary to ensure subsequent opens\n    // after the initial one allows the correct side animation to play when the\n    // placement has changed.\n    index(()=>{\n        if (initiated && !isMounted) {\n            setStatus(\"unmounted\");\n        }\n    }, [\n        initiated,\n        isMounted\n    ]);\n    index(()=>{\n        if (!floating) return;\n        if (open) {\n            setStatus(\"initial\");\n            const frame = requestAnimationFrame(()=>{\n                setStatus(\"open\");\n            });\n            return ()=>{\n                cancelAnimationFrame(frame);\n            };\n        } else {\n            setInitiated(true);\n            setStatus(\"close\");\n        }\n    }, [\n        open,\n        floating\n    ]);\n    return {\n        isMounted,\n        status\n    };\n}\n/**\n * Provides styles to apply CSS transitions to a floating element, correctly\n * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\n */ function useTransitionStyles(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { initial: unstable_initial = {\n        opacity: 0\n    }, open: unstable_open, close: unstable_close, common: unstable_common, duration = 250 } = props;\n    const placement = context.placement;\n    const side = placement.split(\"-\")[0];\n    const fnArgs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            side,\n            placement\n        }), [\n        side,\n        placement\n    ]);\n    const isNumberDuration = typeof duration === \"number\";\n    const openDuration = (isNumberDuration ? duration : duration.open) || 0;\n    const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n    const [styles, setStyles] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>({\n            ...execWithArgsOrReturn(unstable_common, fnArgs),\n            ...execWithArgsOrReturn(unstable_initial, fnArgs)\n        }));\n    const { isMounted, status } = useTransitionStatus(context, {\n        duration\n    });\n    const initialRef = useLatestRef(unstable_initial);\n    const openRef = useLatestRef(unstable_open);\n    const closeRef = useLatestRef(unstable_close);\n    const commonRef = useLatestRef(unstable_common);\n    index(()=>{\n        const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);\n        const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);\n        const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);\n        const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key)=>{\n            acc[key] = \"\";\n            return acc;\n        }, {});\n        if (status === \"initial\") {\n            setStyles((styles)=>({\n                    transitionProperty: styles.transitionProperty,\n                    ...commonStyles,\n                    ...initialStyles\n                }));\n        }\n        if (status === \"open\") {\n            setStyles({\n                transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(\",\"),\n                transitionDuration: openDuration + \"ms\",\n                ...commonStyles,\n                ...openStyles\n            });\n        }\n        if (status === \"close\") {\n            const styles = closeStyles || initialStyles;\n            setStyles({\n                transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(\",\"),\n                transitionDuration: closeDuration + \"ms\",\n                ...commonStyles,\n                ...styles\n            });\n        }\n    }, [\n        closeDuration,\n        closeRef,\n        initialRef,\n        openRef,\n        commonRef,\n        openDuration,\n        status,\n        fnArgs\n    ]);\n    return {\n        isMounted,\n        styles\n    };\n}\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */ function useTypeahead(context, props) {\n    var _ref;\n    const { open, dataRef } = context;\n    const { listRef, activeIndex, onMatch: unstable_onMatch, onTypingChange: unstable_onTypingChange, enabled = true, findMatch = null, resetMs = 750, ignoreKeys = [], selectedIndex = null } = props;\n    const timeoutIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const stringRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(\"\");\n    const prevIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);\n    const matchIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const onMatch = useEffectEvent(unstable_onMatch);\n    const onTypingChange = useEffectEvent(unstable_onTypingChange);\n    const findMatchRef = useLatestRef(findMatch);\n    const ignoreKeysRef = useLatestRef(ignoreKeys);\n    index(()=>{\n        if (open) {\n            clearTimeout(timeoutIdRef.current);\n            matchIndexRef.current = null;\n            stringRef.current = \"\";\n        }\n    }, [\n        open\n    ]);\n    index(()=>{\n        // Sync arrow key navigation but not typeahead navigation.\n        if (open && stringRef.current === \"\") {\n            var _ref2;\n            prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;\n        }\n    }, [\n        open,\n        selectedIndex,\n        activeIndex\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        function setTypingChange(value) {\n            if (value) {\n                if (!dataRef.current.typing) {\n                    dataRef.current.typing = value;\n                    onTypingChange(value);\n                }\n            } else {\n                if (dataRef.current.typing) {\n                    dataRef.current.typing = value;\n                    onTypingChange(value);\n                }\n            }\n        }\n        function getMatchingIndex(list, orderedList, string) {\n            const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find((text)=>(text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);\n            return str ? list.indexOf(str) : -1;\n        }\n        function onKeyDown(event) {\n            const listContent = listRef.current;\n            if (stringRef.current.length > 0 && stringRef.current[0] !== \" \") {\n                if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {\n                    setTypingChange(false);\n                } else if (event.key === \" \") {\n                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                }\n            }\n            if (listContent == null || ignoreKeysRef.current.includes(event.key) || // Character key.\n            event.key.length !== 1 || // Modifier key.\n            event.ctrlKey || event.metaKey || event.altKey) {\n                return;\n            }\n            if (open && event.key !== \" \") {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                setTypingChange(true);\n            }\n            // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n            // allow it in this case, too.\n            const allowRapidSuccessionOfFirstLetter = listContent.every((text)=>{\n                var _text$, _text$2;\n                return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n            });\n            // Allows the user to cycle through items that start with the same letter\n            // in rapid succession.\n            if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n                stringRef.current = \"\";\n                prevIndexRef.current = matchIndexRef.current;\n            }\n            stringRef.current += event.key;\n            clearTimeout(timeoutIdRef.current);\n            timeoutIdRef.current = setTimeout(()=>{\n                stringRef.current = \"\";\n                prevIndexRef.current = matchIndexRef.current;\n                setTypingChange(false);\n            }, resetMs);\n            const prevIndex = prevIndexRef.current;\n            const index = getMatchingIndex(listContent, [\n                ...listContent.slice((prevIndex || 0) + 1),\n                ...listContent.slice(0, (prevIndex || 0) + 1)\n            ], stringRef.current);\n            if (index !== -1) {\n                onMatch(index);\n                matchIndexRef.current = index;\n            } else if (event.key !== \" \") {\n                stringRef.current = \"\";\n                setTypingChange(false);\n            }\n        }\n        return {\n            reference: {\n                onKeyDown\n            },\n            floating: {\n                onKeyDown,\n                onKeyUp (event) {\n                    if (event.key === \" \") {\n                        setTypingChange(false);\n                    }\n                }\n            }\n        };\n    }, [\n        enabled,\n        open,\n        dataRef,\n        listRef,\n        resetMs,\n        ignoreKeysRef,\n        findMatchRef,\n        onMatch,\n        onTypingChange\n    ]);\n}\nfunction getArgsWithCustomFloatingHeight(state, height) {\n    return {\n        ...state,\n        rects: {\n            ...state.rects,\n            floating: {\n                ...state.rects.floating,\n                height\n            }\n        }\n    };\n}\n/**\n * Positions the floating element such that an inner element inside\n * of it is anchored to the reference element.\n * @see https://floating-ui.com/docs/inner\n */ const inner = (props)=>({\n        name: \"inner\",\n        options: props,\n        async fn (state) {\n            const { listRef, overflowRef, onFallbackChange, offset: innerOffset = 0, index = 0, minItemsVisible = 4, referenceOverflowThreshold = 0, scrollRef, ...detectOverflowOptions } = props;\n            const { rects, elements: { floating } } = state;\n            const item = listRef.current[index];\n            if (true) {\n                if (!state.placement.startsWith(\"bottom\")) {\n                    console.warn([\n                        'Floating UI: `placement` side must be \"bottom\" when using the',\n                        \"`inner` middleware.\"\n                    ].join(\" \"));\n                }\n            }\n            if (!item) {\n                return {};\n            }\n            const nextArgs = {\n                ...state,\n                ...await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.offset)(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state)\n            };\n            const el = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n            const overflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.detectOverflow)(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);\n            const refOverflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.detectOverflow)(nextArgs, {\n                ...detectOverflowOptions,\n                elementContext: \"reference\"\n            });\n            const diffY = Math.max(0, overflow.top);\n            const nextY = nextArgs.y + diffY;\n            const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));\n            el.style.maxHeight = maxHeight + \"px\";\n            el.scrollTop = diffY;\n            // There is not enough space, fallback to standard anchored positioning\n            if (onFallbackChange) {\n                if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {\n                    (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.flushSync)(()=>onFallbackChange(true));\n                } else {\n                    (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.flushSync)(()=>onFallbackChange(false));\n                }\n            }\n            if (overflowRef) {\n                overflowRef.current = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.detectOverflow)(getArgsWithCustomFloatingHeight({\n                    ...nextArgs,\n                    y: nextY\n                }, el.offsetHeight), detectOverflowOptions);\n            }\n            return {\n                y: nextY\n            };\n        }\n    });\n/**\n * Changes the `inner` middleware's `offset` upon a `wheel` event to\n * expand the floating element's height, revealing more list items.\n * @see https://floating-ui.com/docs/inner\n */ function useInnerOffset(context, props) {\n    const { open, elements } = context;\n    const { enabled = true, overflowRef, scrollRef, onChange: unstable_onChange } = props;\n    const onChange = useEffectEvent(unstable_onChange);\n    const controlledScrollingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const prevScrollTopRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const initialOverflowRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        function onWheel(e) {\n            if (e.ctrlKey || !el || overflowRef.current == null) {\n                return;\n            }\n            const dY = e.deltaY;\n            const isAtTop = overflowRef.current.top >= -0.5;\n            const isAtBottom = overflowRef.current.bottom >= -0.5;\n            const remainingScroll = el.scrollHeight - el.clientHeight;\n            const sign = dY < 0 ? -1 : 1;\n            const method = dY < 0 ? \"max\" : \"min\";\n            if (el.scrollHeight <= el.clientHeight) {\n                return;\n            }\n            if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n                e.preventDefault();\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.flushSync)(()=>{\n                    onChange((d)=>d + Math[method](dY, remainingScroll * sign));\n                });\n            } else if (/firefox/i.test((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getUserAgent)())) {\n                // Needed to propagate scrolling during momentum scrolling phase once\n                // it gets limited by the boundary. UX improvement, not critical.\n                el.scrollTop += dY;\n            }\n        }\n        const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n        if (open && el) {\n            el.addEventListener(\"wheel\", onWheel);\n            // Wait for the position to be ready.\n            requestAnimationFrame(()=>{\n                prevScrollTopRef.current = el.scrollTop;\n                if (overflowRef.current != null) {\n                    initialOverflowRef.current = {\n                        ...overflowRef.current\n                    };\n                }\n            });\n            return ()=>{\n                prevScrollTopRef.current = null;\n                initialOverflowRef.current = null;\n                el.removeEventListener(\"wheel\", onWheel);\n            };\n        }\n    }, [\n        enabled,\n        open,\n        elements.floating,\n        overflowRef,\n        scrollRef,\n        onChange\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        return {\n            floating: {\n                onKeyDown () {\n                    controlledScrollingRef.current = true;\n                },\n                onWheel () {\n                    controlledScrollingRef.current = false;\n                },\n                onPointerMove () {\n                    controlledScrollingRef.current = false;\n                },\n                onScroll () {\n                    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n                    if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n                        return;\n                    }\n                    if (prevScrollTopRef.current !== null) {\n                        const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n                        if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n                            (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.flushSync)(()=>onChange((d)=>d + scrollDiff));\n                        }\n                    }\n                    // [Firefox] Wait for the height change to have been applied.\n                    requestAnimationFrame(()=>{\n                        prevScrollTopRef.current = el.scrollTop;\n                    });\n                }\n            }\n        };\n    }, [\n        enabled,\n        overflowRef,\n        elements.floating,\n        scrollRef,\n        onChange\n    ]);\n}\nfunction isPointInPolygon(point, polygon) {\n    const [x, y] = point;\n    let isInside = false;\n    const length = polygon.length;\n    for(let i = 0, j = length - 1; i < length; j = i++){\n        const [xi, yi] = polygon[i] || [\n            0,\n            0\n        ];\n        const [xj, yj] = polygon[j] || [\n            0,\n            0\n        ];\n        const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\nfunction isInside(point, rect) {\n    return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n}\n/**\n * Generates a safe polygon area that the user can traverse without closing the\n * floating element once leaving the reference element.\n * @see https://floating-ui.com/docs/useHover#safePolygon\n */ function safePolygon(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { buffer = 0.5, blockPointerEvents = false, requireIntent = true } = options;\n    let timeoutId;\n    let hasLanded = false;\n    let lastX = null;\n    let lastY = null;\n    let lastCursorTime = performance.now();\n    function getCursorSpeed(x, y) {\n        const currentTime = performance.now();\n        const elapsedTime = currentTime - lastCursorTime;\n        if (lastX === null || lastY === null || elapsedTime === 0) {\n            lastX = x;\n            lastY = y;\n            lastCursorTime = currentTime;\n            return null;\n        }\n        const deltaX = x - lastX;\n        const deltaY = y - lastY;\n        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n        const speed = distance / elapsedTime; // px / ms\n        lastX = x;\n        lastY = y;\n        lastCursorTime = currentTime;\n        return speed;\n    }\n    const fn = (_ref)=>{\n        let { x, y, placement, elements, onClose, nodeId, tree } = _ref;\n        return function onMouseMove(event) {\n            function close() {\n                clearTimeout(timeoutId);\n                onClose();\n            }\n            clearTimeout(timeoutId);\n            if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n                return;\n            }\n            const { clientX, clientY } = event;\n            const clientPoint = [\n                clientX,\n                clientY\n            ];\n            const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n            const isLeave = event.type === \"mouseleave\";\n            const isOverFloatingEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(elements.floating, target);\n            const isOverReferenceEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(elements.domReference, target);\n            const refRect = elements.domReference.getBoundingClientRect();\n            const rect = elements.floating.getBoundingClientRect();\n            const side = placement.split(\"-\")[0];\n            const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n            const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n            const isOverReferenceRect = isInside(clientPoint, refRect);\n            const isFloatingWider = rect.width > refRect.width;\n            const isFloatingTaller = rect.height > refRect.height;\n            const left = (isFloatingWider ? refRect : rect).left;\n            const right = (isFloatingWider ? refRect : rect).right;\n            const top = (isFloatingTaller ? refRect : rect).top;\n            const bottom = (isFloatingTaller ? refRect : rect).bottom;\n            if (isOverFloatingEl) {\n                hasLanded = true;\n                if (!isLeave) {\n                    return;\n                }\n            }\n            if (isOverReferenceEl) {\n                hasLanded = false;\n            }\n            if (isOverReferenceEl && !isLeave) {\n                hasLanded = true;\n                return;\n            }\n            // Prevent overlapping floating element from being stuck in an open-close\n            // loop: https://github.com/floating-ui/floating-ui/issues/1910\n            if (isLeave && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(event.relatedTarget) && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(elements.floating, event.relatedTarget)) {\n                return;\n            }\n            // If any nested child is open, abort.\n            if (tree && getChildren(tree.nodesRef.current, nodeId).some((_ref2)=>{\n                let { context } = _ref2;\n                return context == null ? void 0 : context.open;\n            })) {\n                return;\n            }\n            // If the pointer is leaving from the opposite side, the \"buffer\" logic\n            // creates a point where the floating element remains open, but should be\n            // ignored.\n            // A constant of 1 handles floating point rounding errors.\n            if (side === \"top\" && y >= refRect.bottom - 1 || side === \"bottom\" && y <= refRect.top + 1 || side === \"left\" && x >= refRect.right - 1 || side === \"right\" && x <= refRect.left + 1) {\n                return close();\n            }\n            // Ignore when the cursor is within the rectangular trough between the\n            // two elements. Since the triangle is created from the cursor point,\n            // which can start beyond the ref element's edge, traversing back and\n            // forth from the ref to the floating element can cause it to close. This\n            // ensures it always remains open in that case.\n            let rectPoly = [];\n            switch(side){\n                case \"top\":\n                    rectPoly = [\n                        [\n                            left,\n                            refRect.top + 1\n                        ],\n                        [\n                            left,\n                            rect.bottom - 1\n                        ],\n                        [\n                            right,\n                            rect.bottom - 1\n                        ],\n                        [\n                            right,\n                            refRect.top + 1\n                        ]\n                    ];\n                    break;\n                case \"bottom\":\n                    rectPoly = [\n                        [\n                            left,\n                            rect.top + 1\n                        ],\n                        [\n                            left,\n                            refRect.bottom - 1\n                        ],\n                        [\n                            right,\n                            refRect.bottom - 1\n                        ],\n                        [\n                            right,\n                            rect.top + 1\n                        ]\n                    ];\n                    break;\n                case \"left\":\n                    rectPoly = [\n                        [\n                            rect.right - 1,\n                            bottom\n                        ],\n                        [\n                            rect.right - 1,\n                            top\n                        ],\n                        [\n                            refRect.left + 1,\n                            top\n                        ],\n                        [\n                            refRect.left + 1,\n                            bottom\n                        ]\n                    ];\n                    break;\n                case \"right\":\n                    rectPoly = [\n                        [\n                            refRect.right - 1,\n                            bottom\n                        ],\n                        [\n                            refRect.right - 1,\n                            top\n                        ],\n                        [\n                            rect.left + 1,\n                            top\n                        ],\n                        [\n                            rect.left + 1,\n                            bottom\n                        ]\n                    ];\n                    break;\n            }\n            function getPolygon(_ref3) {\n                let [x, y] = _ref3;\n                switch(side){\n                    case \"top\":\n                        {\n                            const cursorPointOne = [\n                                isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y + buffer + 1\n                            ];\n                            const cursorPointTwo = [\n                                isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y + buffer + 1\n                            ];\n                            const commonPoints = [\n                                [\n                                    rect.left,\n                                    cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top\n                                ],\n                                [\n                                    rect.right,\n                                    cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer\n                                ]\n                            ];\n                            return [\n                                cursorPointOne,\n                                cursorPointTwo,\n                                ...commonPoints\n                            ];\n                        }\n                    case \"bottom\":\n                        {\n                            const cursorPointOne = [\n                                isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y - buffer\n                            ];\n                            const cursorPointTwo = [\n                                isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y - buffer\n                            ];\n                            const commonPoints = [\n                                [\n                                    rect.left,\n                                    cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom\n                                ],\n                                [\n                                    rect.right,\n                                    cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer\n                                ]\n                            ];\n                            return [\n                                cursorPointOne,\n                                cursorPointTwo,\n                                ...commonPoints\n                            ];\n                        }\n                    case \"left\":\n                        {\n                            const cursorPointOne = [\n                                x + buffer + 1,\n                                isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const cursorPointTwo = [\n                                x + buffer + 1,\n                                isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const commonPoints = [\n                                [\n                                    cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left,\n                                    rect.top\n                                ],\n                                [\n                                    cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer,\n                                    rect.bottom\n                                ]\n                            ];\n                            return [\n                                ...commonPoints,\n                                cursorPointOne,\n                                cursorPointTwo\n                            ];\n                        }\n                    case \"right\":\n                        {\n                            const cursorPointOne = [\n                                x - buffer,\n                                isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const cursorPointTwo = [\n                                x - buffer,\n                                isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const commonPoints = [\n                                [\n                                    cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right,\n                                    rect.top\n                                ],\n                                [\n                                    cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer,\n                                    rect.bottom\n                                ]\n                            ];\n                            return [\n                                cursorPointOne,\n                                cursorPointTwo,\n                                ...commonPoints\n                            ];\n                        }\n                }\n            }\n            if (isPointInPolygon([\n                clientX,\n                clientY\n            ], rectPoly)) {\n                return;\n            } else if (hasLanded && !isOverReferenceRect) {\n                return close();\n            }\n            if (!isLeave && requireIntent) {\n                const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);\n                const cursorSpeedThreshold = 0.1;\n                if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {\n                    return close();\n                }\n            }\n            if (!isPointInPolygon([\n                clientX,\n                clientY\n            ], getPolygon([\n                x,\n                y\n            ]))) {\n                close();\n            } else if (!hasLanded && requireIntent) {\n                timeoutId = window.setTimeout(close, 40);\n            }\n        };\n    };\n    fn.__options = {\n        blockPointerEvents\n    };\n    return fn;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDNEI7QUFDK087QUFDL1A7QUFDbUY7QUFDa0U7QUFDOUM7QUFDOUc7QUFDZ0I7QUFFcEQ7OztDQUdDLEdBQ0QsU0FBU2dELGFBQWFDLElBQUk7SUFDeEIsT0FBT2pELDBDQUFhLENBQUM7UUFDbkIsSUFBSWlELEtBQUtFLEtBQUssQ0FBQ0MsQ0FBQUEsTUFBT0EsT0FBTyxPQUFPO1lBQ2xDLE9BQU87UUFDVDtRQUNBLE9BQU9DLENBQUFBO1lBQ0xKLEtBQUtLLE9BQU8sQ0FBQ0YsQ0FBQUE7Z0JBQ1gsSUFBSSxPQUFPQSxRQUFRLFlBQVk7b0JBQzdCQSxJQUFJQztnQkFDTixPQUFPLElBQUlELE9BQU8sTUFBTTtvQkFDdEJBLElBQUlHLE9BQU8sR0FBR0Y7Z0JBQ2hCO1lBQ0Y7UUFDRjtJQUNBLHVEQUF1RDtJQUN6RCxHQUFHSjtBQUNMO0FBRUEsNkZBQTZGO0FBQzdGLE1BQU1PLHFCQUFxQnhELHlMQUFLLENBQUMsV0FBVyxHQUFFLHFCQUFxQnlELFFBQVEsR0FBRztBQUM5RSxNQUFNQyx5QkFBeUJGLHNCQUF1QkcsQ0FBQUEsQ0FBQUEsS0FBTUEsSUFBRztBQUMvRCxTQUFTQyxlQUFlQyxRQUFRO0lBQzlCLE1BQU1ULE1BQU1wRCx5Q0FBWSxDQUFDO1FBQ3ZCLElBQUk4RCxJQUFxQyxFQUFFO1lBQ3pDLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtJQUNGO0lBQ0FMLHVCQUF1QjtRQUNyQk4sSUFBSUcsT0FBTyxHQUFHTTtJQUNoQjtJQUNBLE9BQU83RCw4Q0FBaUIsQ0FBQztRQUN2QixJQUFLLElBQUlpRSxPQUFPQyxVQUFVQyxNQUFNLEVBQUVDLE9BQU8sSUFBSUMsTUFBTUosT0FBT0ssT0FBTyxH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SzNxQixLQUFLLEdBQUcycUIsS0FBSzdxQixJQUFJLEdBQUcrcUI7b0NBQVFGLEtBQUs1cUIsTUFBTTtpQ0FBQzs2QkFBQzs0QkFDbFAsT0FBTztnQ0FBQ3lzQjtnQ0FBZ0JDO21DQUFtQkM7NkJBQWE7d0JBQzFEO2dCQUNKO1lBQ0Y7WUFDQSxJQUFJekMsaUJBQWlCO2dCQUFDN2tCO2dCQUFTQzthQUFRLEVBQUVpbkIsV0FBVztnQkFDbEQ7WUFDRixPQUFPLElBQUl2QixhQUFhLENBQUNvQixxQkFBcUI7Z0JBQzVDLE9BQU8za0I7WUFDVDtZQUNBLElBQUksQ0FBQ3FrQixXQUFXZixlQUFlO2dCQUM3QixNQUFNNkIsY0FBY3RCLGVBQWU5MUIsTUFBTTZQLE9BQU8sRUFBRTdQLE1BQU04UCxPQUFPO2dCQUMvRCxNQUFNdW5CLHVCQUF1QjtnQkFDN0IsSUFBSUQsZ0JBQWdCLFFBQVFBLGNBQWNDLHNCQUFzQjtvQkFDOUQsT0FBT3BsQjtnQkFDVDtZQUNGO1lBQ0EsSUFBSSxDQUFDeWlCLGlCQUFpQjtnQkFBQzdrQjtnQkFBU0M7YUFBUSxFQUFFa25CLFdBQVc7Z0JBQUMvc0I7Z0JBQUdFO2FBQUUsSUFBSTtnQkFDN0Q4SDtZQUNGLE9BQU8sSUFBSSxDQUFDdWpCLGFBQWFELGVBQWU7Z0JBQ3RDMWQsWUFBWXpGLE9BQU9qRCxVQUFVLENBQUM4QyxPQUFPO1lBQ3ZDO1FBQ0Y7SUFDRjtJQUNBelUsR0FBRzZTLFNBQVMsR0FBRztRQUNiQztJQUNGO0lBQ0EsT0FBTzlTO0FBQ1Q7QUFFbWhCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmVuZ2dyaS5naXRodWIuaW8vLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QubWpzPzY2Y2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHN0b3BFdmVudCwgZ2V0RG9jdW1lbnQsIGlzTW91c2VMaWtlUG9pbnRlclR5cGUsIGNvbnRhaW5zLCBhY3RpdmVFbGVtZW50LCBpc1NhZmFyaSwgaXNUeXBlYWJsZUNvbWJvYm94LCBpc1ZpcnR1YWxDbGljaywgaXNWaXJ0dWFsUG9pbnRlckV2ZW50LCBnZXRUYXJnZXQsIGdldFBsYXRmb3JtLCBpc1R5cGVhYmxlRWxlbWVudCwgaXNSZWFjdEV2ZW50LCBpc1Jvb3RFbGVtZW50LCBpc0V2ZW50VGFyZ2V0V2l0aGluLCBpc01hYywgZ2V0VXNlckFnZW50IH0gZnJvbSAnQGZsb2F0aW5nLXVpL3JlYWN0L3V0aWxzJztcbmltcG9ydCB7IGZsb29yIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcbmltcG9ydCB7IHBsYXRmb3JtLCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgdXNlRmxvYXRpbmcgYXMgdXNlRmxvYXRpbmckMSwgb2Zmc2V0LCBkZXRlY3RPdmVyZmxvdyB9IGZyb20gJ0BmbG9hdGluZy11aS9yZWFjdC1kb20nO1xuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGF1dG9VcGRhdGUsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgcGxhdGZvcm0sIHNoaWZ0LCBzaXplIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGdldE5vZGVOYW1lLCBnZXRXaW5kb3csIGlzTGFzdFRyYXZlcnNhYmxlTm9kZSwgZ2V0UGFyZW50Tm9kZSwgZ2V0Q29tcHV0ZWRTdHlsZSB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuaW1wb3J0IHsgdGFiYmFibGUgfSBmcm9tICd0YWJiYWJsZSc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwsIGZsdXNoU3luYyB9IGZyb20gJ3JlYWN0LWRvbSc7XG5cbi8qKlxuICogTWVyZ2VzIGFuIGFycmF5IG9mIHJlZnMgaW50byBhIHNpbmdsZSBtZW1vaXplZCBjYWxsYmFjayByZWYgb3IgYG51bGxgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZU1lcmdlUmVmc1xuICovXG5mdW5jdGlvbiB1c2VNZXJnZVJlZnMocmVmcykge1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHJlZnMuZXZlcnkocmVmID0+IHJlZiA9PSBudWxsKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA9PiB7XG4gICAgICByZWZzLmZvckVhY2gocmVmID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZWYodmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIHJlZnMpO1xufVxuXG4vLyBgdG9TdHJpbmcoKWAgcHJldmVudHMgYnVuZGxlcnMgZnJvbSB0cnlpbmcgdG8gYGltcG9ydCB7IHVzZUluc2VydGlvbkVmZmVjdCB9IGZyb20gJ3JlYWN0J2BcbmNvbnN0IHVzZUluc2VydGlvbkVmZmVjdCA9IFJlYWN0Wy8qI19fUFVSRV9fKi8ndXNlSW5zZXJ0aW9uRWZmZWN0Jy50b1N0cmluZygpXTtcbmNvbnN0IHVzZVNhZmVJbnNlcnRpb25FZmZlY3QgPSB1c2VJbnNlcnRpb25FZmZlY3QgfHwgKGZuID0+IGZuKCkpO1xuZnVuY3Rpb24gdXNlRWZmZWN0RXZlbnQoY2FsbGJhY2spIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKCgpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxsIGFuIGV2ZW50IGhhbmRsZXIgd2hpbGUgcmVuZGVyaW5nLicpO1xuICAgIH1cbiAgfSk7XG4gIHVzZVNhZmVJbnNlcnRpb25FZmZlY3QoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gY2FsbGJhY2s7XG4gIH0pO1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50ID09IG51bGwgPyB2b2lkIDAgOiByZWYuY3VycmVudCguLi5hcmdzKTtcbiAgfSwgW10pO1xufVxuXG5jb25zdCBBUlJPV19VUCA9ICdBcnJvd1VwJztcbmNvbnN0IEFSUk9XX0RPV04gPSAnQXJyb3dEb3duJztcbmNvbnN0IEFSUk9XX0xFRlQgPSAnQXJyb3dMZWZ0JztcbmNvbnN0IEFSUk9XX1JJR0hUID0gJ0Fycm93UmlnaHQnO1xuZnVuY3Rpb24gaXNEaWZmZXJlbnRSb3coaW5kZXgsIGNvbHMsIHByZXZSb3cpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoaW5kZXggLyBjb2xzKSAhPT0gcHJldlJvdztcbn1cbmZ1bmN0aW9uIGlzSW5kZXhPdXRPZkJvdW5kcyhsaXN0UmVmLCBpbmRleCkge1xuICByZXR1cm4gaW5kZXggPCAwIHx8IGluZGV4ID49IGxpc3RSZWYuY3VycmVudC5sZW5ndGg7XG59XG5mdW5jdGlvbiBnZXRNaW5JbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXMpIHtcbiAgcmV0dXJuIGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICBkaXNhYmxlZEluZGljZXNcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRNYXhJbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXMpIHtcbiAgcmV0dXJuIGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICBkZWNyZW1lbnQ6IHRydWUsXG4gICAgc3RhcnRpbmdJbmRleDogbGlzdFJlZi5jdXJyZW50Lmxlbmd0aCxcbiAgICBkaXNhYmxlZEluZGljZXNcbiAgfSk7XG59XG5mdW5jdGlvbiBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCBfdGVtcCkge1xuICBsZXQge1xuICAgIHN0YXJ0aW5nSW5kZXggPSAtMSxcbiAgICBkZWNyZW1lbnQgPSBmYWxzZSxcbiAgICBkaXNhYmxlZEluZGljZXMsXG4gICAgYW1vdW50ID0gMVxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNvbnN0IGxpc3QgPSBsaXN0UmVmLmN1cnJlbnQ7XG4gIGNvbnN0IGlzRGlzYWJsZWRJbmRleCA9IGRpc2FibGVkSW5kaWNlcyA/IGluZGV4ID0+IGRpc2FibGVkSW5kaWNlcy5pbmNsdWRlcyhpbmRleCkgOiBpbmRleCA9PiB7XG4gICAgY29uc3QgZWxlbWVudCA9IGxpc3RbaW5kZXhdO1xuICAgIHJldHVybiBlbGVtZW50ID09IG51bGwgfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnKSA9PT0gJ3RydWUnO1xuICB9O1xuICBsZXQgaW5kZXggPSBzdGFydGluZ0luZGV4O1xuICBkbyB7XG4gICAgaW5kZXggKz0gZGVjcmVtZW50ID8gLWFtb3VudCA6IGFtb3VudDtcbiAgfSB3aGlsZSAoaW5kZXggPj0gMCAmJiBpbmRleCA8PSBsaXN0Lmxlbmd0aCAtIDEgJiYgaXNEaXNhYmxlZEluZGV4KGluZGV4KSk7XG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIGdldEdyaWROYXZpZ2F0ZWRJbmRleChlbGVtZW50c1JlZiwgX3JlZikge1xuICBsZXQge1xuICAgIGV2ZW50LFxuICAgIG9yaWVudGF0aW9uLFxuICAgIGxvb3AsXG4gICAgY29scyxcbiAgICBkaXNhYmxlZEluZGljZXMsXG4gICAgbWluSW5kZXgsXG4gICAgbWF4SW5kZXgsXG4gICAgcHJldkluZGV4LFxuICAgIHN0b3BFdmVudDogc3RvcCA9IGZhbHNlXG4gIH0gPSBfcmVmO1xuICBsZXQgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuICBpZiAoZXZlbnQua2V5ID09PSBBUlJPV19VUCkge1xuICAgIHN0b3AgJiYgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICBpZiAocHJldkluZGV4ID09PSAtMSkge1xuICAgICAgbmV4dEluZGV4ID0gbWF4SW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgIHN0YXJ0aW5nSW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgYW1vdW50OiBjb2xzLFxuICAgICAgICBkZWNyZW1lbnQ6IHRydWUsXG4gICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgfSk7XG4gICAgICBpZiAobG9vcCAmJiAocHJldkluZGV4IC0gY29scyA8IG1pbkluZGV4IHx8IG5leHRJbmRleCA8IDApKSB7XG4gICAgICAgIGNvbnN0IGNvbCA9IHByZXZJbmRleCAlIGNvbHM7XG4gICAgICAgIGNvbnN0IG1heENvbCA9IG1heEluZGV4ICUgY29scztcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbWF4SW5kZXggLSAobWF4Q29sIC0gY29sKTtcbiAgICAgICAgaWYgKG1heENvbCA9PT0gY29sKSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gbWF4SW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gbWF4Q29sID4gY29sID8gb2Zmc2V0IDogb2Zmc2V0IC0gY29scztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNJbmRleE91dE9mQm91bmRzKGVsZW1lbnRzUmVmLCBuZXh0SW5kZXgpKSB7XG4gICAgICBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgfVxuICB9XG4gIGlmIChldmVudC5rZXkgPT09IEFSUk9XX0RPV04pIHtcbiAgICBzdG9wICYmIHN0b3BFdmVudChldmVudCk7XG4gICAgaWYgKHByZXZJbmRleCA9PT0gLTEpIHtcbiAgICAgIG5leHRJbmRleCA9IG1pbkluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXgsXG4gICAgICAgIGFtb3VudDogY29scyxcbiAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICB9KTtcbiAgICAgIGlmIChsb29wICYmIHByZXZJbmRleCArIGNvbHMgPiBtYXhJbmRleCkge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCAlIGNvbHMgLSBjb2xzLFxuICAgICAgICAgIGFtb3VudDogY29scyxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0luZGV4T3V0T2ZCb3VuZHMoZWxlbWVudHNSZWYsIG5leHRJbmRleCkpIHtcbiAgICAgIG5leHRJbmRleCA9IHByZXZJbmRleDtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1haW5zIG9uIHRoZSBzYW1lIHJvdy9jb2x1bW4uXG4gIGlmIChvcmllbnRhdGlvbiA9PT0gJ2JvdGgnKSB7XG4gICAgY29uc3QgcHJldlJvdyA9IGZsb29yKHByZXZJbmRleCAvIGNvbHMpO1xuICAgIGlmIChldmVudC5rZXkgPT09IEFSUk9XX1JJR0hUKSB7XG4gICAgICBzdG9wICYmIHN0b3BFdmVudChldmVudCk7XG4gICAgICBpZiAocHJldkluZGV4ICUgY29scyAhPT0gY29scyAtIDEpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXgsXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobG9vcCAmJiBpc0RpZmZlcmVudFJvdyhuZXh0SW5kZXgsIGNvbHMsIHByZXZSb3cpKSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCAtIHByZXZJbmRleCAlIGNvbHMgLSAxLFxuICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobG9vcCkge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCAtIHByZXZJbmRleCAlIGNvbHMgLSAxLFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RpZmZlcmVudFJvdyhuZXh0SW5kZXgsIGNvbHMsIHByZXZSb3cpKSB7XG4gICAgICAgIG5leHRJbmRleCA9IHByZXZJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gQVJST1dfTEVGVCkge1xuICAgICAgc3RvcCAmJiBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgaWYgKHByZXZJbmRleCAlIGNvbHMgIT09IDApIHtcbiAgICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXgsXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzLFxuICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxvb3AgJiYgaXNEaWZmZXJlbnRSb3cobmV4dEluZGV4LCBjb2xzLCBwcmV2Um93KSkge1xuICAgICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXggKyAoY29scyAtIHByZXZJbmRleCAlIGNvbHMpLFxuICAgICAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobG9vcCkge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCArIChjb2xzIC0gcHJldkluZGV4ICUgY29scyksXG4gICAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RpZmZlcmVudFJvdyhuZXh0SW5kZXgsIGNvbHMsIHByZXZSb3cpKSB7XG4gICAgICAgIG5leHRJbmRleCA9IHByZXZJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGFzdFJvdyA9IGZsb29yKG1heEluZGV4IC8gY29scykgPT09IHByZXZSb3c7XG4gICAgaWYgKGlzSW5kZXhPdXRPZkJvdW5kcyhlbGVtZW50c1JlZiwgbmV4dEluZGV4KSkge1xuICAgICAgaWYgKGxvb3AgJiYgbGFzdFJvdykge1xuICAgICAgICBuZXh0SW5kZXggPSBldmVudC5rZXkgPT09IEFSUk9XX0xFRlQgPyBtYXhJbmRleCA6IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4IC0gcHJldkluZGV4ICUgY29scyAtIDEsXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV4dEluZGV4O1xufVxuXG5sZXQgcmFmSWQgPSAwO1xuZnVuY3Rpb24gZW5xdWV1ZUZvY3VzKGVsLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIHByZXZlbnRTY3JvbGwgPSBmYWxzZSxcbiAgICBjYW5jZWxQcmV2aW91cyA9IHRydWUsXG4gICAgc3luYyA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjYW5jZWxQcmV2aW91cyAmJiBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJZCk7XG4gIGNvbnN0IGV4ZWMgPSAoKSA9PiBlbCA9PSBudWxsID8gdm9pZCAwIDogZWwuZm9jdXMoe1xuICAgIHByZXZlbnRTY3JvbGxcbiAgfSk7XG4gIGlmIChzeW5jKSB7XG4gICAgZXhlYygpO1xuICB9IGVsc2Uge1xuICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGV4ZWMpO1xuICB9XG59XG5cbnZhciBpbmRleCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbmZ1bmN0aW9uIHNvcnRCeURvY3VtZW50UG9zaXRpb24oYSwgYikge1xuICBjb25zdCBwb3NpdGlvbiA9IGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYik7XG4gIGlmIChwb3NpdGlvbiAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HIHx8IHBvc2l0aW9uICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHBvc2l0aW9uICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcgfHwgcG9zaXRpb24gJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5TKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBhcmVNYXBzRXF1YWwobWFwMSwgbWFwMikge1xuICBpZiAobWFwMS5zaXplICE9PSBtYXAyLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbWFwMS5lbnRyaWVzKCkpIHtcbiAgICBpZiAodmFsdWUgIT09IG1hcDIuZ2V0KGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBGbG9hdGluZ0xpc3RDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICByZWdpc3RlcjogKCkgPT4ge30sXG4gIHVucmVnaXN0ZXI6ICgpID0+IHt9LFxuICBtYXA6IC8qI19fUFVSRV9fKi9uZXcgTWFwKCksXG4gIGVsZW1lbnRzUmVmOiB7XG4gICAgY3VycmVudDogW11cbiAgfVxufSk7XG4vKipcbiAqIFByb3ZpZGVzIGNvbnRleHQgZm9yIGEgbGlzdCBvZiBpdGVtcyB3aXRoaW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdMaXN0XG4gKi9cbmZ1bmN0aW9uIEZsb2F0aW5nTGlzdChfcmVmKSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZWxlbWVudHNSZWYsXG4gICAgbGFiZWxzUmVmXG4gIH0gPSBfcmVmO1xuICBjb25zdCBbbWFwLCBzZXRNYXBdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gbmV3IE1hcCgpKTtcbiAgY29uc3QgcmVnaXN0ZXIgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBzZXRNYXAocHJldk1hcCA9PiBuZXcgTWFwKHByZXZNYXApLnNldChub2RlLCBudWxsKSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgdW5yZWdpc3RlciA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIHNldE1hcChwcmV2TWFwID0+IHtcbiAgICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAocHJldk1hcCk7XG4gICAgICBtYXAuZGVsZXRlKG5vZGUpO1xuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9KTtcbiAgfSwgW10pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3QgbmV3TWFwID0gbmV3IE1hcChtYXApO1xuICAgIGNvbnN0IG5vZGVzID0gQXJyYXkuZnJvbShuZXdNYXAua2V5cygpKS5zb3J0KHNvcnRCeURvY3VtZW50UG9zaXRpb24pO1xuICAgIG5vZGVzLmZvckVhY2goKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgICBuZXdNYXAuc2V0KG5vZGUsIGluZGV4KTtcbiAgICB9KTtcbiAgICBpZiAoIWFyZU1hcHNFcXVhbChtYXAsIG5ld01hcCkpIHtcbiAgICAgIHNldE1hcChuZXdNYXApO1xuICAgIH1cbiAgfSwgW21hcF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdMaXN0Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICByZWdpc3RlcixcbiAgICAgIHVucmVnaXN0ZXIsXG4gICAgICBtYXAsXG4gICAgICBlbGVtZW50c1JlZixcbiAgICAgIGxhYmVsc1JlZlxuICAgIH0pLCBbcmVnaXN0ZXIsIHVucmVnaXN0ZXIsIG1hcCwgZWxlbWVudHNSZWYsIGxhYmVsc1JlZl0pXG4gIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIHVzZUxpc3RJdGVtKF90ZW1wKSB7XG4gIGxldCB7XG4gICAgbGFiZWxcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBjb25zdCBbaW5kZXgkMSwgc2V0SW5kZXhdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IGNvbXBvbmVudFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qge1xuICAgIHJlZ2lzdGVyLFxuICAgIHVucmVnaXN0ZXIsXG4gICAgbWFwLFxuICAgIGVsZW1lbnRzUmVmLFxuICAgIGxhYmVsc1JlZlxuICB9ID0gUmVhY3QudXNlQ29udGV4dChGbG9hdGluZ0xpc3RDb250ZXh0KTtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgY29tcG9uZW50UmVmLmN1cnJlbnQgPSBub2RlO1xuICAgIGlmIChpbmRleCQxICE9PSBudWxsKSB7XG4gICAgICBlbGVtZW50c1JlZi5jdXJyZW50W2luZGV4JDFdID0gbm9kZTtcbiAgICAgIGlmIChsYWJlbHNSZWYpIHtcbiAgICAgICAgdmFyIF9ub2RlJHRleHRDb250ZW50O1xuICAgICAgICBjb25zdCBpc0xhYmVsRGVmaW5lZCA9IGxhYmVsICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGxhYmVsc1JlZi5jdXJyZW50W2luZGV4JDFdID0gaXNMYWJlbERlZmluZWQgPyBsYWJlbCA6IChfbm9kZSR0ZXh0Q29udGVudCA9IG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUudGV4dENvbnRlbnQpICE9IG51bGwgPyBfbm9kZSR0ZXh0Q29udGVudCA6IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCBbaW5kZXgkMSwgZWxlbWVudHNSZWYsIGxhYmVsc1JlZiwgbGFiZWxdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSBjb21wb25lbnRSZWYuY3VycmVudDtcbiAgICBpZiAobm9kZSkge1xuICAgICAgcmVnaXN0ZXIobm9kZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB1bnJlZ2lzdGVyKG5vZGUpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtyZWdpc3RlciwgdW5yZWdpc3Rlcl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBjb21wb25lbnRSZWYuY3VycmVudCA/IG1hcC5nZXQoY29tcG9uZW50UmVmLmN1cnJlbnQpIDogbnVsbDtcbiAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgc2V0SW5kZXgoaW5kZXgpO1xuICAgIH1cbiAgfSwgW21hcF0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZixcbiAgICBpbmRleDogaW5kZXgkMSA9PSBudWxsID8gLTEgOiBpbmRleCQxXG4gIH0pLCBbaW5kZXgkMSwgcmVmXSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckpzeChyZW5kZXIsIGNvbXB1dGVkUHJvcHMpIHtcbiAgaWYgKHR5cGVvZiByZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcmVuZGVyKGNvbXB1dGVkUHJvcHMpO1xuICB9IGVsc2UgaWYgKHJlbmRlcikge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KHJlbmRlciwgY29tcHV0ZWRQcm9wcyk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIGNvbXB1dGVkUHJvcHMpO1xufVxuY29uc3QgQ29tcG9zaXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgYWN0aXZlSW5kZXg6IDAsXG4gIG9uTmF2aWdhdGU6ICgpID0+IHt9XG59KTtcbmNvbnN0IGhvcml6b250YWxLZXlzID0gW0FSUk9XX0xFRlQsIEFSUk9XX1JJR0hUXTtcbmNvbnN0IHZlcnRpY2FsS2V5cyA9IFtBUlJPV19VUCwgQVJST1dfRE9XTl07XG5jb25zdCBhbGxLZXlzID0gWy4uLmhvcml6b250YWxLZXlzLCAuLi52ZXJ0aWNhbEtleXNdO1xuY29uc3QgQ29tcG9zaXRlID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gQ29tcG9zaXRlKF9yZWYsIGZvcndhcmRlZFJlZikge1xuICBsZXQge1xuICAgIHJlbmRlcixcbiAgICBvcmllbnRhdGlvbiA9ICdib3RoJyxcbiAgICBsb29wID0gdHJ1ZSxcbiAgICBjb2xzID0gMSxcbiAgICBkaXNhYmxlZEluZGljZXMsXG4gICAgYWN0aXZlSW5kZXg6IGV4dGVybmFsQWN0aXZlSW5kZXgsXG4gICAgb25OYXZpZ2F0ZTogZXh0ZXJuYWxTZXRBY3RpdmVJbmRleCxcbiAgICAuLi5wcm9wc1xuICB9ID0gX3JlZjtcbiAgY29uc3QgW2ludGVybmFsQWN0aXZlSW5kZXgsIGludGVybmFsU2V0QWN0aXZlSW5kZXhdID0gUmVhY3QudXNlU3RhdGUoMCk7XG4gIGNvbnN0IGFjdGl2ZUluZGV4ID0gZXh0ZXJuYWxBY3RpdmVJbmRleCAhPSBudWxsID8gZXh0ZXJuYWxBY3RpdmVJbmRleCA6IGludGVybmFsQWN0aXZlSW5kZXg7XG4gIGNvbnN0IG9uTmF2aWdhdGUgPSB1c2VFZmZlY3RFdmVudChleHRlcm5hbFNldEFjdGl2ZUluZGV4ICE9IG51bGwgPyBleHRlcm5hbFNldEFjdGl2ZUluZGV4IDogaW50ZXJuYWxTZXRBY3RpdmVJbmRleCk7XG4gIGNvbnN0IGVsZW1lbnRzUmVmID0gUmVhY3QudXNlUmVmKFtdKTtcbiAgY29uc3QgcmVuZGVyRWxlbWVudFByb3BzID0gcmVuZGVyICYmIHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicgPyByZW5kZXIucHJvcHMgOiB7fTtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIGFjdGl2ZUluZGV4LFxuICAgIG9uTmF2aWdhdGVcbiAgfSksIFthY3RpdmVJbmRleCwgb25OYXZpZ2F0ZV0pO1xuICBjb25zdCBpc0dyaWQgPSBjb2xzID4gMTtcbiAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgIGlmICghYWxsS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpKSByZXR1cm47XG4gICAgY29uc3QgbWluSW5kZXggPSBnZXRNaW5JbmRleChlbGVtZW50c1JlZiwgZGlzYWJsZWRJbmRpY2VzKTtcbiAgICBjb25zdCBtYXhJbmRleCA9IGdldE1heEluZGV4KGVsZW1lbnRzUmVmLCBkaXNhYmxlZEluZGljZXMpO1xuICAgIGNvbnN0IHByZXZJbmRleCA9IGFjdGl2ZUluZGV4O1xuICAgIGxldCBuZXh0SW5kZXggPSBhY3RpdmVJbmRleDtcbiAgICBpZiAoaXNHcmlkKSB7XG4gICAgICBuZXh0SW5kZXggPSBnZXRHcmlkTmF2aWdhdGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBsb29wLFxuICAgICAgICBjb2xzLFxuICAgICAgICBkaXNhYmxlZEluZGljZXMsXG4gICAgICAgIG1pbkluZGV4LFxuICAgICAgICBtYXhJbmRleCxcbiAgICAgICAgcHJldkluZGV4XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdG9FbmRLZXlzID0ge1xuICAgICAgaG9yaXpvbnRhbDogW0FSUk9XX1JJR0hUXSxcbiAgICAgIHZlcnRpY2FsOiBbQVJST1dfRE9XTl0sXG4gICAgICBib3RoOiBbQVJST1dfUklHSFQsIEFSUk9XX0RPV05dXG4gICAgfVtvcmllbnRhdGlvbl07XG4gICAgY29uc3QgdG9TdGFydEtleXMgPSB7XG4gICAgICBob3Jpem9udGFsOiBbQVJST1dfTEVGVF0sXG4gICAgICB2ZXJ0aWNhbDogW0FSUk9XX1VQXSxcbiAgICAgIGJvdGg6IFtBUlJPV19MRUZULCBBUlJPV19VUF1cbiAgICB9W29yaWVudGF0aW9uXTtcbiAgICBjb25zdCBwcmV2ZW50ZWRLZXlzID0gaXNHcmlkID8gYWxsS2V5cyA6IHtcbiAgICAgIGhvcml6b250YWw6IGhvcml6b250YWxLZXlzLFxuICAgICAgdmVydGljYWw6IHZlcnRpY2FsS2V5cyxcbiAgICAgIGJvdGg6IGFsbEtleXNcbiAgICB9W29yaWVudGF0aW9uXTtcbiAgICBpZiAobmV4dEluZGV4ID09PSBhY3RpdmVJbmRleCAmJiBbLi4udG9FbmRLZXlzLCAuLi50b1N0YXJ0S2V5c10uaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgaWYgKGxvb3AgJiYgbmV4dEluZGV4ID09PSBtYXhJbmRleCAmJiB0b0VuZEtleXMuaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICBuZXh0SW5kZXggPSBtaW5JbmRleDtcbiAgICAgIH0gZWxzZSBpZiAobG9vcCAmJiBuZXh0SW5kZXggPT09IG1pbkluZGV4ICYmIHRvU3RhcnRLZXlzLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gbWF4SW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgICBkZWNyZW1lbnQ6IHRvU3RhcnRLZXlzLmluY2x1ZGVzKGV2ZW50LmtleSksXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV4dEluZGV4ICE9PSBhY3RpdmVJbmRleCAmJiAhaXNJbmRleE91dE9mQm91bmRzKGVsZW1lbnRzUmVmLCBuZXh0SW5kZXgpKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGlmIChwcmV2ZW50ZWRLZXlzLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIG9uTmF2aWdhdGUobmV4dEluZGV4KTtcblxuICAgICAgLy8gV2FpdCBmb3IgRm9jdXNNYW5hZ2VyIGByZXR1cm5Gb2N1c2AgdG8gZXhlY3V0ZS5cbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKGVsZW1lbnRzUmVmLmN1cnJlbnRbbmV4dEluZGV4XSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY29tcHV0ZWRQcm9wcyA9IHtcbiAgICAuLi5wcm9wcyxcbiAgICAuLi5yZW5kZXJFbGVtZW50UHJvcHMsXG4gICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgJ2FyaWEtb3JpZW50YXRpb24nOiBvcmllbnRhdGlvbiA9PT0gJ2JvdGgnID8gdW5kZWZpbmVkIDogb3JpZW50YXRpb24sXG4gICAgb25LZXlEb3duKGUpIHtcbiAgICAgIHByb3BzLm9uS2V5RG93biA9PSBudWxsIHx8IHByb3BzLm9uS2V5RG93bihlKTtcbiAgICAgIHJlbmRlckVsZW1lbnRQcm9wcy5vbktleURvd24gPT0gbnVsbCB8fCByZW5kZXJFbGVtZW50UHJvcHMub25LZXlEb3duKGUpO1xuICAgICAgaGFuZGxlS2V5RG93bihlKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb3NpdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRWYWx1ZVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGbG9hdGluZ0xpc3QsIHtcbiAgICBlbGVtZW50c1JlZjogZWxlbWVudHNSZWZcbiAgfSwgcmVuZGVySnN4KHJlbmRlciwgY29tcHV0ZWRQcm9wcykpKTtcbn0pO1xuY29uc3QgQ29tcG9zaXRlSXRlbSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIENvbXBvc2l0ZUl0ZW0oX3JlZjIsIGZvcndhcmRlZFJlZikge1xuICBsZXQge1xuICAgIHJlbmRlcixcbiAgICAuLi5wcm9wc1xuICB9ID0gX3JlZjI7XG4gIGNvbnN0IHJlbmRlckVsZW1lbnRQcm9wcyA9IHJlbmRlciAmJiB0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nID8gcmVuZGVyLnByb3BzIDoge307XG4gIGNvbnN0IHtcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvbk5hdmlnYXRlXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KENvbXBvc2l0ZUNvbnRleHQpO1xuICBjb25zdCB7XG4gICAgcmVmLFxuICAgIGluZGV4XG4gIH0gPSB1c2VMaXN0SXRlbSgpO1xuICBjb25zdCBtZXJnZWRSZWYgPSB1c2VNZXJnZVJlZnMoW3JlZiwgZm9yd2FyZGVkUmVmLCByZW5kZXJFbGVtZW50UHJvcHMucmVmXSk7XG4gIGNvbnN0IGlzQWN0aXZlID0gYWN0aXZlSW5kZXggPT09IGluZGV4O1xuICBjb25zdCBjb21wdXRlZFByb3BzID0ge1xuICAgIC4uLnByb3BzLFxuICAgIC4uLnJlbmRlckVsZW1lbnRQcm9wcyxcbiAgICByZWY6IG1lcmdlZFJlZixcbiAgICB0YWJJbmRleDogaXNBY3RpdmUgPyAwIDogLTEsXG4gICAgJ2RhdGEtYWN0aXZlJzogaXNBY3RpdmUgPyAnJyA6IHVuZGVmaW5lZCxcbiAgICBvbkZvY3VzKGUpIHtcbiAgICAgIHByb3BzLm9uRm9jdXMgPT0gbnVsbCB8fCBwcm9wcy5vbkZvY3VzKGUpO1xuICAgICAgcmVuZGVyRWxlbWVudFByb3BzLm9uRm9jdXMgPT0gbnVsbCB8fCByZW5kZXJFbGVtZW50UHJvcHMub25Gb2N1cyhlKTtcbiAgICAgIG9uTmF2aWdhdGUoaW5kZXgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHJlbmRlckpzeChyZW5kZXIsIGNvbXB1dGVkUHJvcHMpO1xufSk7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5sZXQgc2VydmVySGFuZG9mZkNvbXBsZXRlID0gZmFsc2U7XG5sZXQgY291bnQgPSAwO1xuY29uc3QgZ2VuSWQgPSAoKSA9PiBcImZsb2F0aW5nLXVpLVwiICsgY291bnQrKztcbmZ1bmN0aW9uIHVzZUZsb2F0aW5nSWQoKSB7XG4gIGNvbnN0IFtpZCwgc2V0SWRdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gc2VydmVySGFuZG9mZkNvbXBsZXRlID8gZ2VuSWQoKSA6IHVuZGVmaW5lZCk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgc2V0SWQoZ2VuSWQoKSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc2VydmVySGFuZG9mZkNvbXBsZXRlKSB7XG4gICAgICBzZXJ2ZXJIYW5kb2ZmQ29tcGxldGUgPSB0cnVlO1xuICAgIH1cbiAgfSwgW10pO1xuICByZXR1cm4gaWQ7XG59XG5cbi8vIGB0b1N0cmluZygpYCBwcmV2ZW50cyBidW5kbGVycyBmcm9tIHRyeWluZyB0byBgaW1wb3J0IHsgdXNlSWQgfSBmcm9tICdyZWFjdCdgXG5jb25zdCB1c2VSZWFjdElkID0gUmVhY3RbLyojX19QVVJFX18qLyd1c2VJZCcudG9TdHJpbmcoKV07XG5cbi8qKlxuICogVXNlcyBSZWFjdCAxOCdzIGJ1aWx0LWluIGB1c2VJZCgpYCB3aGVuIGF2YWlsYWJsZSwgb3IgZmFsbHMgYmFjayB0byBhXG4gKiBzbGlnaHRseSBsZXNzIHBlcmZvcm1hbnQgKHJlcXVpcmluZyBhIGRvdWJsZSByZW5kZXIpIGltcGxlbWVudGF0aW9uIGZvclxuICogZWFybGllciBSZWFjdCB2ZXJzaW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VJZFxuICovXG5jb25zdCB1c2VJZCA9IHVzZVJlYWN0SWQgfHwgdXNlRmxvYXRpbmdJZDtcblxuLyoqXG4gKiBSZW5kZXJzIGEgcG9pbnRpbmcgYXJyb3cgdHJpYW5nbGUuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdBcnJvd1xuICovXG5jb25zdCBGbG9hdGluZ0Fycm93ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gRmxvYXRpbmdBcnJvdyhfcmVmLCByZWYpIHtcbiAgbGV0IHtcbiAgICBjb250ZXh0OiB7XG4gICAgICBwbGFjZW1lbnQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBmbG9hdGluZ1xuICAgICAgfSxcbiAgICAgIG1pZGRsZXdhcmVEYXRhOiB7XG4gICAgICAgIGFycm93XG4gICAgICB9XG4gICAgfSxcbiAgICB3aWR0aCA9IDE0LFxuICAgIGhlaWdodCA9IDcsXG4gICAgdGlwUmFkaXVzID0gMCxcbiAgICBzdHJva2VXaWR0aCA9IDAsXG4gICAgc3RhdGljT2Zmc2V0LFxuICAgIHN0cm9rZSxcbiAgICBkLFxuICAgIHN0eWxlOiB7XG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICAuLi5yZXN0U3R5bGVcbiAgICB9ID0ge30sXG4gICAgLi4ucmVzdFxuICB9ID0gX3JlZjtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghcmVmKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Zsb2F0aW5nIFVJOiBUaGUgYHJlZmAgcHJvcCBpcyByZXF1aXJlZCBmb3IgdGhlIGBGbG9hdGluZ0Fycm93YCcsICdjb21wb25lbnQuJyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNsaXBQYXRoSWQgPSB1c2VJZCgpO1xuICBpZiAoIWZsb2F0aW5nKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBTdHJva2VzIG11c3QgYmUgZG91YmxlIHRoZSBib3JkZXIgd2lkdGgsIHRoaXMgZW5zdXJlcyB0aGUgc3Ryb2tlJ3Mgd2lkdGhcbiAgLy8gd29ya3MgYXMgeW91J2QgZXhwZWN0LlxuICBzdHJva2VXaWR0aCAqPSAyO1xuICBjb25zdCBoYWxmU3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aCAvIDI7XG4gIGNvbnN0IHN2Z1ggPSB3aWR0aCAvIDIgKiAodGlwUmFkaXVzIC8gLTggKyAxKTtcbiAgY29uc3Qgc3ZnWSA9IGhlaWdodCAvIDIgKiB0aXBSYWRpdXMgLyA0O1xuICBjb25zdCBbc2lkZSwgYWxpZ25tZW50XSA9IHBsYWNlbWVudC5zcGxpdCgnLScpO1xuICBjb25zdCBpc1JUTCA9IHBsYXRmb3JtLmlzUlRMKGZsb2F0aW5nKTtcbiAgY29uc3QgaXNDdXN0b21TaGFwZSA9ICEhZDtcbiAgY29uc3QgaXNWZXJ0aWNhbFNpZGUgPSBzaWRlID09PSAndG9wJyB8fCBzaWRlID09PSAnYm90dG9tJztcbiAgY29uc3QgeU9mZnNldFByb3AgPSBzdGF0aWNPZmZzZXQgJiYgYWxpZ25tZW50ID09PSAnZW5kJyA/ICdib3R0b20nIDogJ3RvcCc7XG4gIGxldCB4T2Zmc2V0UHJvcCA9IHN0YXRpY09mZnNldCAmJiBhbGlnbm1lbnQgPT09ICdlbmQnID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgaWYgKHN0YXRpY09mZnNldCAmJiBpc1JUTCkge1xuICAgIHhPZmZzZXRQcm9wID0gYWxpZ25tZW50ID09PSAnZW5kJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIH1cbiAgY29uc3QgYXJyb3dYID0gKGFycm93ID09IG51bGwgPyB2b2lkIDAgOiBhcnJvdy54KSAhPSBudWxsID8gc3RhdGljT2Zmc2V0IHx8IGFycm93LnggOiAnJztcbiAgY29uc3QgYXJyb3dZID0gKGFycm93ID09IG51bGwgPyB2b2lkIDAgOiBhcnJvdy55KSAhPSBudWxsID8gc3RhdGljT2Zmc2V0IHx8IGFycm93LnkgOiAnJztcbiAgY29uc3QgZFZhbHVlID0gZCB8fCAnTTAsMCcgKyAoXCIgSFwiICsgd2lkdGgpICsgKFwiIExcIiArICh3aWR0aCAtIHN2Z1gpICsgXCIsXCIgKyAoaGVpZ2h0IC0gc3ZnWSkpICsgKFwiIFFcIiArIHdpZHRoIC8gMiArIFwiLFwiICsgaGVpZ2h0ICsgXCIgXCIgKyBzdmdYICsgXCIsXCIgKyAoaGVpZ2h0IC0gc3ZnWSkpICsgJyBaJztcbiAgY29uc3Qgcm90YXRpb24gPSB7XG4gICAgdG9wOiBpc0N1c3RvbVNoYXBlID8gJ3JvdGF0ZSgxODBkZWcpJyA6ICcnLFxuICAgIGxlZnQ6IGlzQ3VzdG9tU2hhcGUgPyAncm90YXRlKDkwZGVnKScgOiAncm90YXRlKC05MGRlZyknLFxuICAgIGJvdHRvbTogaXNDdXN0b21TaGFwZSA/ICcnIDogJ3JvdGF0ZSgxODBkZWcpJyxcbiAgICByaWdodDogaXNDdXN0b21TaGFwZSA/ICdyb3RhdGUoLTkwZGVnKScgOiAncm90YXRlKDkwZGVnKSdcbiAgfVtzaWRlXTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgXCJhcmlhLWhpZGRlblwiOiB0cnVlLFxuICAgIHJlZjogcmVmLFxuICAgIHdpZHRoOiBpc0N1c3RvbVNoYXBlID8gd2lkdGggOiB3aWR0aCArIHN0cm9rZVdpZHRoLFxuICAgIGhlaWdodDogd2lkdGgsXG4gICAgdmlld0JveDogXCIwIDAgXCIgKyB3aWR0aCArIFwiIFwiICsgKGhlaWdodCA+IHdpZHRoID8gaGVpZ2h0IDogd2lkdGgpLFxuICAgIHN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgIFt4T2Zmc2V0UHJvcF06IGFycm93WCxcbiAgICAgIFt5T2Zmc2V0UHJvcF06IGFycm93WSxcbiAgICAgIFtzaWRlXTogaXNWZXJ0aWNhbFNpZGUgfHwgaXNDdXN0b21TaGFwZSA/ICcxMDAlJyA6IFwiY2FsYygxMDAlIC0gXCIgKyBzdHJva2VXaWR0aCAvIDIgKyBcInB4KVwiLFxuICAgICAgdHJhbnNmb3JtOiBcIlwiICsgcm90YXRpb24gKyAodHJhbnNmb3JtICE9IG51bGwgPyB0cmFuc2Zvcm0gOiAnJyksXG4gICAgICAuLi5yZXN0U3R5bGVcbiAgICB9XG4gIH0pLCBzdHJva2VXaWR0aCA+IDAgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBjbGlwUGF0aDogXCJ1cmwoI1wiICsgY2xpcFBhdGhJZCArIFwiKVwiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHN0cm9rZTogc3Ryb2tlXG4gICAgLy8gQWNjb3VudCBmb3IgdGhlIHN0cm9rZSBvbiB0aGUgZmlsbCBwYXRoIHJlbmRlcmVkIGJlbG93LlxuICAgICxcbiAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGggKyAoZCA/IDAgOiAxKSxcbiAgICBkOiBkVmFsdWVcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgc3Ryb2tlOiBzdHJva2VXaWR0aCAmJiAhZCA/IHJlc3QuZmlsbCA6ICdub25lJyxcbiAgICBkOiBkVmFsdWVcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIiwge1xuICAgIGlkOiBjbGlwUGF0aElkXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgeDogLWhhbGZTdHJva2VXaWR0aCxcbiAgICB5OiBoYWxmU3Ryb2tlV2lkdGggKiAoaXNDdXN0b21TaGFwZSA/IC0xIDogMSksXG4gICAgd2lkdGg6IHdpZHRoICsgc3Ryb2tlV2lkdGgsXG4gICAgaGVpZ2h0OiB3aWR0aFxuICB9KSkpO1xufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVB1YlN1YigpIHtcbiAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICByZXR1cm4ge1xuICAgIGVtaXQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfbWFwJGdldDtcbiAgICAgIChfbWFwJGdldCA9IG1hcC5nZXQoZXZlbnQpKSA9PSBudWxsIHx8IF9tYXAkZ2V0LmZvckVhY2goaGFuZGxlciA9PiBoYW5kbGVyKGRhdGEpKTtcbiAgICB9LFxuICAgIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgbWFwLnNldChldmVudCwgWy4uLihtYXAuZ2V0KGV2ZW50KSB8fCBbXSksIGxpc3RlbmVyXSk7XG4gICAgfSxcbiAgICBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgX21hcCRnZXQyO1xuICAgICAgbWFwLnNldChldmVudCwgKChfbWFwJGdldDIgPSBtYXAuZ2V0KGV2ZW50KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYXAkZ2V0Mi5maWx0ZXIobCA9PiBsICE9PSBsaXN0ZW5lcikpIHx8IFtdKTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IEZsb2F0aW5nTm9kZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IEZsb2F0aW5nVHJlZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkID0gKCkgPT4ge1xuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQ7XG4gIHJldHVybiAoKF9SZWFjdCR1c2VDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChGbG9hdGluZ05vZGVDb250ZXh0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9SZWFjdCR1c2VDb250ZXh0LmlkKSB8fCBudWxsO1xufTtcbmNvbnN0IHVzZUZsb2F0aW5nVHJlZSA9ICgpID0+IFJlYWN0LnVzZUNvbnRleHQoRmxvYXRpbmdUcmVlQ29udGV4dCk7XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgbm9kZSBpbnRvIHRoZSBmbG9hdGluZyB0cmVlLCByZXR1cm5pbmcgaXRzIGlkLlxuICovXG5mdW5jdGlvbiB1c2VGbG9hdGluZ05vZGVJZChjdXN0b21QYXJlbnRJZCkge1xuICBjb25zdCBpZCA9IHVzZUlkKCk7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3QgcmVhY3RQYXJlbnRJZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCk7XG4gIGNvbnN0IHBhcmVudElkID0gY3VzdG9tUGFyZW50SWQgfHwgcmVhY3RQYXJlbnRJZDtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICBpZCxcbiAgICAgIHBhcmVudElkXG4gICAgfTtcbiAgICB0cmVlID09IG51bGwgfHwgdHJlZS5hZGROb2RlKG5vZGUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0cmVlID09IG51bGwgfHwgdHJlZS5yZW1vdmVOb2RlKG5vZGUpO1xuICAgIH07XG4gIH0sIFt0cmVlLCBpZCwgcGFyZW50SWRdKTtcbiAgcmV0dXJuIGlkO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIHBhcmVudCBub2RlIGNvbnRleHQgZm9yIG5lc3RlZCBmbG9hdGluZyBlbGVtZW50cy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ1RyZWVcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdOb2RlKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlbixcbiAgICBpZFxuICB9ID0gX3JlZjtcbiAgY29uc3QgcGFyZW50SWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdOb2RlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICBpZCxcbiAgICAgIHBhcmVudElkXG4gICAgfSksIFtpZCwgcGFyZW50SWRdKVxuICB9LCBjaGlsZHJlbik7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgY29udGV4dCBmb3IgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzIHdoZW4gdGhleSBhcmUgbm90IGNoaWxkcmVuIG9mXG4gKiBlYWNoIG90aGVyIG9uIHRoZSBET00gKGkuZS4gcG9ydGFsbGVkIHRvIGEgY29tbW9uIG5vZGUsIHJhdGhlciB0aGFuIHRoZWlyXG4gKiByZXNwZWN0aXZlIHBhcmVudCkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdUcmVlXG4gKi9cbmZ1bmN0aW9uIEZsb2F0aW5nVHJlZShfcmVmMikge1xuICBsZXQge1xuICAgIGNoaWxkcmVuXG4gIH0gPSBfcmVmMjtcbiAgY29uc3Qgbm9kZXNSZWYgPSBSZWFjdC51c2VSZWYoW10pO1xuICBjb25zdCBhZGROb2RlID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgbm9kZXNSZWYuY3VycmVudCA9IFsuLi5ub2Rlc1JlZi5jdXJyZW50LCBub2RlXTtcbiAgfSwgW10pO1xuICBjb25zdCByZW1vdmVOb2RlID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgbm9kZXNSZWYuY3VycmVudCA9IG5vZGVzUmVmLmN1cnJlbnQuZmlsdGVyKG4gPT4gbiAhPT0gbm9kZSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgZXZlbnRzID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gY3JlYXRlUHViU3ViKCkpWzBdO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdUcmVlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICBub2Rlc1JlZixcbiAgICAgIGFkZE5vZGUsXG4gICAgICByZW1vdmVOb2RlLFxuICAgICAgZXZlbnRzXG4gICAgfSksIFtub2Rlc1JlZiwgYWRkTm9kZSwgcmVtb3ZlTm9kZSwgZXZlbnRzXSlcbiAgfSwgY2hpbGRyZW4pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBdHRyaWJ1dGUobmFtZSkge1xuICByZXR1cm4gXCJkYXRhLWZsb2F0aW5nLXVpLVwiICsgbmFtZTtcbn1cblxuZnVuY3Rpb24gdXNlTGF0ZXN0UmVmKHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZih2YWx1ZSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlZjtcbn1cblxuY29uc3Qgc2FmZVBvbHlnb25JZGVudGlmaWVyID0gLyojX19QVVJFX18qL2NyZWF0ZUF0dHJpYnV0ZSgnc2FmZS1wb2x5Z29uJyk7XG5mdW5jdGlvbiBnZXREZWxheSh2YWx1ZSwgcHJvcCwgcG9pbnRlclR5cGUpIHtcbiAgaWYgKHBvaW50ZXJUeXBlICYmICFpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWVbcHJvcF07XG59XG4vKipcbiAqIE9wZW5zIHRoZSBmbG9hdGluZyBlbGVtZW50IHdoaWxlIGhvdmVyaW5nIG92ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50LCBsaWtlXG4gKiBDU1MgYDpob3ZlcmAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlSG92ZXJcbiAqL1xuZnVuY3Rpb24gdXNlSG92ZXIoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBkYXRhUmVmLFxuICAgIGV2ZW50cyxcbiAgICBlbGVtZW50czoge1xuICAgICAgZG9tUmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmdcbiAgICB9LFxuICAgIHJlZnNcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBkZWxheSA9IDAsXG4gICAgaGFuZGxlQ2xvc2UgPSBudWxsLFxuICAgIG1vdXNlT25seSA9IGZhbHNlLFxuICAgIHJlc3RNcyA9IDAsXG4gICAgbW92ZSA9IHRydWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCB0cmVlID0gdXNlRmxvYXRpbmdUcmVlKCk7XG4gIGNvbnN0IHBhcmVudElkID0gdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQoKTtcbiAgY29uc3QgaGFuZGxlQ2xvc2VSZWYgPSB1c2VMYXRlc3RSZWYoaGFuZGxlQ2xvc2UpO1xuICBjb25zdCBkZWxheVJlZiA9IHVzZUxhdGVzdFJlZihkZWxheSk7XG4gIGNvbnN0IHBvaW50ZXJUeXBlUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IHRpbWVvdXRSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3QgaGFuZGxlclJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCByZXN0VGltZW91dFJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBibG9ja01vdXNlTW92ZVJlZiA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgY29uc3QgcGVyZm9ybWVkUG9pbnRlckV2ZW50c011dGF0aW9uUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgdW5iaW5kTW91c2VNb3ZlUmVmID0gUmVhY3QudXNlUmVmKCgpID0+IHt9KTtcbiAgY29uc3QgaXNIb3Zlck9wZW4gPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgdmFyIF9kYXRhUmVmJGN1cnJlbnQkb3BlbjtcbiAgICBjb25zdCB0eXBlID0gKF9kYXRhUmVmJGN1cnJlbnQkb3BlbiA9IGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YVJlZiRjdXJyZW50JG9wZW4udHlwZTtcbiAgICByZXR1cm4gKHR5cGUgPT0gbnVsbCA/IHZvaWQgMCA6IHR5cGUuaW5jbHVkZXMoJ21vdXNlJykpICYmIHR5cGUgIT09ICdtb3VzZWRvd24nO1xuICB9LCBbZGF0YVJlZl0pO1xuXG4gIC8vIFdoZW4gY2xvc2luZyBiZWZvcmUgb3BlbmluZywgY2xlYXIgdGhlIGRlbGF5IHRpbWVvdXRzIHRvIGNhbmNlbCBpdFxuICAvLyBmcm9tIHNob3dpbmcuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uT3BlbkNoYW5nZShfcmVmKSB7XG4gICAgICBsZXQge1xuICAgICAgICBvcGVuXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGlmICghb3Blbikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlc3RUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgICBibG9ja01vdXNlTW92ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXZlbnRzLm9uKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZXZlbnRzLm9mZignb3BlbmNoYW5nZScsIG9uT3BlbkNoYW5nZSk7XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIGV2ZW50c10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCB8fCAhaGFuZGxlQ2xvc2VSZWYuY3VycmVudCB8fCAhb3Blbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkxlYXZlKGV2ZW50KSB7XG4gICAgICBpZiAoaXNIb3Zlck9wZW4oKSkge1xuICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50LCAnaG92ZXInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50KGZsb2F0aW5nKS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25MZWF2ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGh0bWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uTGVhdmUpO1xuICAgIH07XG4gIH0sIFtmbG9hdGluZywgb3Blbiwgb25PcGVuQ2hhbmdlLCBlbmFibGVkLCBoYW5kbGVDbG9zZVJlZiwgZGF0YVJlZiwgaXNIb3Zlck9wZW5dKTtcbiAgY29uc3QgY2xvc2VXaXRoRGVsYXkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQsIHJ1bkVsc2VCcmFuY2gsIHJlYXNvbikge1xuICAgIGlmIChydW5FbHNlQnJhbmNoID09PSB2b2lkIDApIHtcbiAgICAgIHJ1bkVsc2VCcmFuY2ggPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocmVhc29uID09PSB2b2lkIDApIHtcbiAgICAgIHJlYXNvbiA9ICdob3Zlcic7XG4gICAgfVxuICAgIGNvbnN0IGNsb3NlRGVsYXkgPSBnZXREZWxheShkZWxheVJlZi5jdXJyZW50LCAnY2xvc2UnLCBwb2ludGVyVHlwZVJlZi5jdXJyZW50KTtcbiAgICBpZiAoY2xvc2VEZWxheSAmJiAhaGFuZGxlclJlZi5jdXJyZW50KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4gb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCwgcmVhc29uKSwgY2xvc2VEZWxheSk7XG4gICAgfSBlbHNlIGlmIChydW5FbHNlQnJhbmNoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQsIHJlYXNvbik7XG4gICAgfVxuICB9LCBbZGVsYXlSZWYsIG9uT3BlbkNoYW5nZV0pO1xuICBjb25zdCBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlciA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICB1bmJpbmRNb3VzZU1vdmVSZWYuY3VycmVudCgpO1xuICAgIGhhbmRsZXJSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgfSwgW10pO1xuICBjb25zdCBjbGVhclBvaW50ZXJFdmVudHMgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKHBlcmZvcm1lZFBvaW50ZXJFdmVudHNNdXRhdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICBjb25zdCBib2R5ID0gZ2V0RG9jdW1lbnQocmVmcy5mbG9hdGluZy5jdXJyZW50KS5ib2R5O1xuICAgICAgYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XG4gICAgICBib2R5LnJlbW92ZUF0dHJpYnV0ZShzYWZlUG9seWdvbklkZW50aWZpZXIpO1xuICAgICAgcGVyZm9ybWVkUG9pbnRlckV2ZW50c011dGF0aW9uUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9XG4gIH0sIFtyZWZzXSk7XG5cbiAgLy8gUmVnaXN0ZXJpbmcgdGhlIG1vdXNlIGV2ZW50cyBvbiB0aGUgcmVmZXJlbmNlIGRpcmVjdGx5IHRvIGJ5cGFzcyBSZWFjdCdzXG4gIC8vIGRlbGVnYXRpb24gc3lzdGVtLiBJZiB0aGUgY3Vyc29yIHdhcyBvbiBhIGRpc2FibGVkIGVsZW1lbnQgYW5kIHRoZW4gZW50ZXJlZFxuICAvLyB0aGUgcmVmZXJlbmNlIChubyBnYXApLCBgbW91c2VlbnRlcmAgZG9lc24ndCBmaXJlIGluIHRoZSBkZWxlZ2F0aW9uIHN5c3RlbS5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNDbGlja0xpa2VPcGVuRXZlbnQoKSB7XG4gICAgICByZXR1cm4gZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA/IFsnY2xpY2snLCAnbW91c2Vkb3duJ10uaW5jbHVkZXMoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudC50eXBlKSA6IGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlRW50ZXIoZXZlbnQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgYmxvY2tNb3VzZU1vdmVSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgaWYgKG1vdXNlT25seSAmJiAhaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZVJlZi5jdXJyZW50KSB8fCByZXN0TXMgPiAwICYmIGdldERlbGF5KGRlbGF5UmVmLmN1cnJlbnQsICdvcGVuJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3BlbkRlbGF5ID0gZ2V0RGVsYXkoZGVsYXlSZWYuY3VycmVudCwgJ29wZW4nLCBwb2ludGVyVHlwZVJlZi5jdXJyZW50KTtcbiAgICAgIGlmIChvcGVuRGVsYXkpIHtcbiAgICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50LCAnaG92ZXInKTtcbiAgICAgICAgfSwgb3BlbkRlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudCwgJ2hvdmVyJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VMZWF2ZShldmVudCkge1xuICAgICAgaWYgKGlzQ2xpY2tMaWtlT3BlbkV2ZW50KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdW5iaW5kTW91c2VNb3ZlUmVmLmN1cnJlbnQoKTtcbiAgICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGZsb2F0aW5nKTtcbiAgICAgIGNsZWFyVGltZW91dChyZXN0VGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIGlmIChoYW5kbGVDbG9zZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIC8vIFByZXZlbnQgY2xlYXJpbmcgYG9uU2Nyb2xsTW91c2VMZWF2ZWAgdGltZW91dC5cbiAgICAgICAgaWYgKCFvcGVuKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlclJlZi5jdXJyZW50ID0gaGFuZGxlQ2xvc2VSZWYuY3VycmVudCh7XG4gICAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgICB0cmVlLFxuICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICAgICAgICBvbkNsb3NlKCkge1xuICAgICAgICAgICAgY2xlYXJQb2ludGVyRXZlbnRzKCk7XG4gICAgICAgICAgICBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgICAgICAgY2xvc2VXaXRoRGVsYXkoZXZlbnQsIHRydWUsICdzYWZlLXBvbHlnb24nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlclJlZi5jdXJyZW50O1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlcik7XG4gICAgICAgIHVuYmluZE1vdXNlTW92ZVJlZi5jdXJyZW50ID0gKCkgPT4ge1xuICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGxvdyBpbnRlcmFjdGl2aXR5IHdpdGhvdXQgYHNhZmVQb2x5Z29uYCBvbiB0b3VjaCBkZXZpY2VzLiBXaXRoIGFcbiAgICAgIC8vIHBvaW50ZXIsIGEgc2hvcnQgY2xvc2UgZGVsYXkgaXMgYW4gYWx0ZXJuYXRpdmUsIHNvIGl0IHNob3VsZCB3b3JrXG4gICAgICAvLyBjb25zaXN0ZW50bHkuXG4gICAgICBjb25zdCBzaG91bGRDbG9zZSA9IHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPT09ICd0b3VjaCcgPyAhY29udGFpbnMoZmxvYXRpbmcsIGV2ZW50LnJlbGF0ZWRUYXJnZXQpIDogdHJ1ZTtcbiAgICAgIGlmIChzaG91bGRDbG9zZSkge1xuICAgICAgICBjbG9zZVdpdGhEZWxheShldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoZSBmbG9hdGluZyBlbGVtZW50IGNsb3NlcyBhZnRlciBzY3JvbGxpbmcgZXZlbiBpZiB0aGUgcG9pbnRlclxuICAgIC8vIGRpZCBub3QgbW92ZS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvZGlzY3Vzc2lvbnMvMTY5MlxuICAgIGZ1bmN0aW9uIG9uU2Nyb2xsTW91c2VMZWF2ZShldmVudCkge1xuICAgICAgaWYgKGlzQ2xpY2tMaWtlT3BlbkV2ZW50KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaGFuZGxlQ2xvc2VSZWYuY3VycmVudCA9PSBudWxsIHx8IGhhbmRsZUNsb3NlUmVmLmN1cnJlbnQoe1xuICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICB0cmVlLFxuICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICB5OiBldmVudC5jbGllbnRZLFxuICAgICAgICBvbkNsb3NlKCkge1xuICAgICAgICAgIGNsZWFyUG9pbnRlckV2ZW50cygpO1xuICAgICAgICAgIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICAgICAgY2xvc2VXaXRoRGVsYXkoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KShldmVudCk7XG4gICAgfVxuICAgIGlmIChpc0VsZW1lbnQoZG9tUmVmZXJlbmNlKSkge1xuICAgICAgY29uc3QgcmVmID0gZG9tUmVmZXJlbmNlO1xuICAgICAgb3BlbiAmJiByZWYuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uU2Nyb2xsTW91c2VMZWF2ZSk7XG4gICAgICBmbG9hdGluZyA9PSBudWxsIHx8IGZsb2F0aW5nLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvblNjcm9sbE1vdXNlTGVhdmUpO1xuICAgICAgbW92ZSAmJiByZWYuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZUVudGVyLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVmLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBvbk1vdXNlRW50ZXIpO1xuICAgICAgcmVmLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvbk1vdXNlTGVhdmUpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgb3BlbiAmJiByZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uU2Nyb2xsTW91c2VMZWF2ZSk7XG4gICAgICAgIGZsb2F0aW5nID09IG51bGwgfHwgZmxvYXRpbmcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uU2Nyb2xsTW91c2VMZWF2ZSk7XG4gICAgICAgIG1vdmUgJiYgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VFbnRlcik7XG4gICAgICAgIHJlZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgb25Nb3VzZUVudGVyKTtcbiAgICAgICAgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvbk1vdXNlTGVhdmUpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtkb21SZWZlcmVuY2UsIGZsb2F0aW5nLCBlbmFibGVkLCBjb250ZXh0LCBtb3VzZU9ubHksIHJlc3RNcywgbW92ZSwgY2xvc2VXaXRoRGVsYXksIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyLCBjbGVhclBvaW50ZXJFdmVudHMsIG9uT3BlbkNoYW5nZSwgb3BlbiwgdHJlZSwgZGVsYXlSZWYsIGhhbmRsZUNsb3NlUmVmLCBkYXRhUmVmXSk7XG5cbiAgLy8gQmxvY2sgcG9pbnRlci1ldmVudHMgb2YgZXZlcnkgZWxlbWVudCBvdGhlciB0aGFuIHRoZSByZWZlcmVuY2UgYW5kIGZsb2F0aW5nXG4gIC8vIHdoaWxlIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzIG9wZW4gYW5kIGhhcyBhIGBoYW5kbGVDbG9zZWAgaGFuZGxlci4gQWxzb1xuICAvLyBoYW5kbGVzIG5lc3RlZCBmbG9hdGluZyBlbGVtZW50cy5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8xNzIyXG4gIGluZGV4KCgpID0+IHtcbiAgICB2YXIgX2hhbmRsZUNsb3NlUmVmJGN1cnJlO1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3BlbiAmJiAoX2hhbmRsZUNsb3NlUmVmJGN1cnJlID0gaGFuZGxlQ2xvc2VSZWYuY3VycmVudCkgIT0gbnVsbCAmJiBfaGFuZGxlQ2xvc2VSZWYkY3VycmUuX19vcHRpb25zLmJsb2NrUG9pbnRlckV2ZW50cyAmJiBpc0hvdmVyT3BlbigpKSB7XG4gICAgICBjb25zdCBib2R5ID0gZ2V0RG9jdW1lbnQoZmxvYXRpbmcpLmJvZHk7XG4gICAgICBib2R5LnNldEF0dHJpYnV0ZShzYWZlUG9seWdvbklkZW50aWZpZXIsICcnKTtcbiAgICAgIGJvZHkuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgIHBlcmZvcm1lZFBvaW50ZXJFdmVudHNNdXRhdGlvblJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGlmIChpc0VsZW1lbnQoZG9tUmVmZXJlbmNlKSAmJiBmbG9hdGluZykge1xuICAgICAgICB2YXIgX3RyZWUkbm9kZXNSZWYkY3VycmVuO1xuICAgICAgICBjb25zdCByZWYgPSBkb21SZWZlcmVuY2U7XG4gICAgICAgIGNvbnN0IHBhcmVudEZsb2F0aW5nID0gdHJlZSA9PSBudWxsIHx8IChfdHJlZSRub2Rlc1JlZiRjdXJyZW4gPSB0cmVlLm5vZGVzUmVmLmN1cnJlbnQuZmluZChub2RlID0+IG5vZGUuaWQgPT09IHBhcmVudElkKSkgPT0gbnVsbCB8fCAoX3RyZWUkbm9kZXNSZWYkY3VycmVuID0gX3RyZWUkbm9kZXNSZWYkY3VycmVuLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfdHJlZSRub2Rlc1JlZiRjdXJyZW4uZWxlbWVudHMuZmxvYXRpbmc7XG4gICAgICAgIGlmIChwYXJlbnRGbG9hdGluZykge1xuICAgICAgICAgIHBhcmVudEZsb2F0aW5nLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgICAgfVxuICAgICAgICByZWYuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcbiAgICAgICAgZmxvYXRpbmcuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICByZWYuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgICAgIGZsb2F0aW5nLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBwYXJlbnRJZCwgZmxvYXRpbmcsIGRvbVJlZmVyZW5jZSwgdHJlZSwgaGFuZGxlQ2xvc2VSZWYsIGRhdGFSZWYsIGlzSG92ZXJPcGVuXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIW9wZW4pIHtcbiAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgY2xlYXJQb2ludGVyRXZlbnRzKCk7XG4gICAgfVxuICB9LCBbb3BlbiwgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIsIGNsZWFyUG9pbnRlckV2ZW50c10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICBjbGVhclRpbWVvdXQocmVzdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICBjbGVhclBvaW50ZXJFdmVudHMoKTtcbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgZG9tUmVmZXJlbmNlLCBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlciwgY2xlYXJQb2ludGVyRXZlbnRzXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0UG9pbnRlclJlZihldmVudCkge1xuICAgICAgcG9pbnRlclR5cGVSZWYuY3VycmVudCA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgIG9uUG9pbnRlckRvd246IHNldFBvaW50ZXJSZWYsXG4gICAgICAgIG9uUG9pbnRlckVudGVyOiBzZXRQb2ludGVyUmVmLFxuICAgICAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICAgIGlmIChvcGVuIHx8IHJlc3RNcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGVhclRpbWVvdXQocmVzdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgICAgcmVzdFRpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFibG9ja01vdXNlTW92ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2hvdmVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzdE1zKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZsb2F0aW5nOiB7XG4gICAgICAgIG9uTW91c2VFbnRlcigpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZUxlYXZlKGV2ZW50KSB7XG4gICAgICAgICAgY2xvc2VXaXRoRGVsYXkoZXZlbnQubmF0aXZlRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCByZXN0TXMsIG9wZW4sIG9uT3BlbkNoYW5nZSwgY2xvc2VXaXRoRGVsYXldKTtcbn1cblxuY29uc3QgRmxvYXRpbmdEZWxheUdyb3VwQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgZGVsYXk6IDAsXG4gIGluaXRpYWxEZWxheTogMCxcbiAgdGltZW91dE1zOiAwLFxuICBjdXJyZW50SWQ6IG51bGwsXG4gIHNldEN1cnJlbnRJZDogKCkgPT4ge30sXG4gIHNldFN0YXRlOiAoKSA9PiB7fSxcbiAgaXNJbnN0YW50UGhhc2U6IGZhbHNlXG59KTtcbmNvbnN0IHVzZURlbGF5R3JvdXBDb250ZXh0ID0gKCkgPT4gUmVhY3QudXNlQ29udGV4dChGbG9hdGluZ0RlbGF5R3JvdXBDb250ZXh0KTtcbi8qKlxuICogUHJvdmlkZXMgY29udGV4dCBmb3IgYSBncm91cCBvZiBmbG9hdGluZyBlbGVtZW50cyB0aGF0IHNob3VsZCBzaGFyZSBhXG4gKiBgZGVsYXlgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nRGVsYXlHcm91cFxuICovXG5jb25zdCBGbG9hdGluZ0RlbGF5R3JvdXAgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlbixcbiAgICBkZWxheSxcbiAgICB0aW1lb3V0TXMgPSAwXG4gIH0gPSBfcmVmO1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVJlZHVjZXIoKHByZXYsIG5leHQpID0+ICh7XG4gICAgLi4ucHJldixcbiAgICAuLi5uZXh0XG4gIH0pLCB7XG4gICAgZGVsYXksXG4gICAgdGltZW91dE1zLFxuICAgIGluaXRpYWxEZWxheTogZGVsYXksXG4gICAgY3VycmVudElkOiBudWxsLFxuICAgIGlzSW5zdGFudFBoYXNlOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgaW5pdGlhbEN1cnJlbnRJZFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qgc2V0Q3VycmVudElkID0gUmVhY3QudXNlQ2FsbGJhY2soY3VycmVudElkID0+IHtcbiAgICBzZXRTdGF0ZSh7XG4gICAgICBjdXJyZW50SWRcbiAgICB9KTtcbiAgfSwgW10pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKHN0YXRlLmN1cnJlbnRJZCkge1xuICAgICAgaWYgKGluaXRpYWxDdXJyZW50SWRSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICBpbml0aWFsQ3VycmVudElkUmVmLmN1cnJlbnQgPSBzdGF0ZS5jdXJyZW50SWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgaXNJbnN0YW50UGhhc2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgaXNJbnN0YW50UGhhc2U6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGluaXRpYWxDdXJyZW50SWRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbc3RhdGUuY3VycmVudElkXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGbG9hdGluZ0RlbGF5R3JvdXBDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgc2V0U3RhdGUsXG4gICAgICBzZXRDdXJyZW50SWRcbiAgICB9KSwgW3N0YXRlLCBzZXRTdGF0ZSwgc2V0Q3VycmVudElkXSlcbiAgfSwgY2hpbGRyZW4pO1xufTtcbmNvbnN0IHVzZURlbGF5R3JvdXAgPSAoX3JlZjIsIF9yZWYzKSA9PiB7XG4gIGxldCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2VcbiAgfSA9IF9yZWYyO1xuICBsZXQge1xuICAgIGlkXG4gIH0gPSBfcmVmMztcbiAgY29uc3Qge1xuICAgIGN1cnJlbnRJZCxcbiAgICBzZXRDdXJyZW50SWQsXG4gICAgaW5pdGlhbERlbGF5LFxuICAgIHNldFN0YXRlLFxuICAgIHRpbWVvdXRNc1xuICB9ID0gdXNlRGVsYXlHcm91cENvbnRleHQoKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChjdXJyZW50SWQpIHtcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgZGVsYXk6IHtcbiAgICAgICAgICBvcGVuOiAxLFxuICAgICAgICAgIGNsb3NlOiBnZXREZWxheShpbml0aWFsRGVsYXksICdjbG9zZScpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGN1cnJlbnRJZCAhPT0gaWQpIHtcbiAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtpZCwgb25PcGVuQ2hhbmdlLCBzZXRTdGF0ZSwgY3VycmVudElkLCBpbml0aWFsRGVsYXldKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHVuc2V0KCkge1xuICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgZGVsYXk6IGluaXRpYWxEZWxheSxcbiAgICAgICAgY3VycmVudElkOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFvcGVuICYmIGN1cnJlbnRJZCA9PT0gaWQpIHtcbiAgICAgIGlmICh0aW1lb3V0TXMpIHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KHVuc2V0LCB0aW1lb3V0TXMpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuc2V0KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbb3Blbiwgc2V0U3RhdGUsIGN1cnJlbnRJZCwgaWQsIG9uT3BlbkNoYW5nZSwgaW5pdGlhbERlbGF5LCB0aW1lb3V0TXNdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBzZXRDdXJyZW50SWQoaWQpO1xuICAgIH1cbiAgfSwgW29wZW4sIHNldEN1cnJlbnRJZCwgaWRdKTtcbn07XG5cbmZ1bmN0aW9uIGdldEFuY2VzdG9ycyhub2RlcywgaWQpIHtcbiAgdmFyIF9ub2RlcyRmaW5kO1xuICBsZXQgYWxsQW5jZXN0b3JzID0gW107XG4gIGxldCBjdXJyZW50UGFyZW50SWQgPSAoX25vZGVzJGZpbmQgPSBub2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGVzJGZpbmQucGFyZW50SWQ7XG4gIHdoaWxlIChjdXJyZW50UGFyZW50SWQpIHtcbiAgICBjb25zdCBjdXJyZW50Tm9kZSA9IG5vZGVzLmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBjdXJyZW50UGFyZW50SWQpO1xuICAgIGN1cnJlbnRQYXJlbnRJZCA9IGN1cnJlbnROb2RlID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50Tm9kZS5wYXJlbnRJZDtcbiAgICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICAgIGFsbEFuY2VzdG9ycyA9IGFsbEFuY2VzdG9ycy5jb25jYXQoY3VycmVudE5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWxsQW5jZXN0b3JzO1xufVxuXG5mdW5jdGlvbiBnZXRDaGlsZHJlbihub2RlcywgaWQpIHtcbiAgbGV0IGFsbENoaWxkcmVuID0gbm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgIHZhciBfbm9kZSRjb250ZXh0O1xuICAgIHJldHVybiBub2RlLnBhcmVudElkID09PSBpZCAmJiAoKF9ub2RlJGNvbnRleHQgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Lm9wZW4pO1xuICB9KTtcbiAgbGV0IGN1cnJlbnRDaGlsZHJlbiA9IGFsbENoaWxkcmVuO1xuICB3aGlsZSAoY3VycmVudENoaWxkcmVuLmxlbmd0aCkge1xuICAgIGN1cnJlbnRDaGlsZHJlbiA9IG5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICAgIHZhciBfY3VycmVudENoaWxkcmVuO1xuICAgICAgcmV0dXJuIChfY3VycmVudENoaWxkcmVuID0gY3VycmVudENoaWxkcmVuKSA9PSBudWxsID8gdm9pZCAwIDogX2N1cnJlbnRDaGlsZHJlbi5zb21lKG4gPT4ge1xuICAgICAgICB2YXIgX25vZGUkY29udGV4dDI7XG4gICAgICAgIHJldHVybiBub2RlLnBhcmVudElkID09PSBuLmlkICYmICgoX25vZGUkY29udGV4dDIgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Mi5vcGVuKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGFsbENoaWxkcmVuID0gYWxsQ2hpbGRyZW4uY29uY2F0KGN1cnJlbnRDaGlsZHJlbik7XG4gIH1cbiAgcmV0dXJuIGFsbENoaWxkcmVuO1xufVxuZnVuY3Rpb24gZ2V0RGVlcGVzdE5vZGUobm9kZXMsIGlkKSB7XG4gIGxldCBkZWVwZXN0Tm9kZUlkO1xuICBsZXQgbWF4RGVwdGggPSAtMTtcbiAgZnVuY3Rpb24gZmluZERlZXBlc3Qobm9kZUlkLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA+IG1heERlcHRoKSB7XG4gICAgICBkZWVwZXN0Tm9kZUlkID0gbm9kZUlkO1xuICAgICAgbWF4RGVwdGggPSBkZXB0aDtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbihub2Rlcywgbm9kZUlkKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGZpbmREZWVwZXN0KGNoaWxkLmlkLCBkZXB0aCArIDEpO1xuICAgIH0pO1xuICB9XG4gIGZpbmREZWVwZXN0KGlkLCAwKTtcbiAgcmV0dXJuIG5vZGVzLmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBkZWVwZXN0Tm9kZUlkKTtcbn1cblxuLy8gTW9kaWZpZWQgdG8gYWRkIGNvbmRpdGlvbmFsIGBhcmlhLWhpZGRlbmAgc3VwcG9ydDpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVLYXNoZXkvYXJpYS1oaWRkZW4vYmxvYi85MjIwYzhmNGE0ZmQzNWY2M2JlZTU1MTBhOWY0MWEzNzI2NDM4MmQ0L3NyYy9pbmRleC50c1xubGV0IGNvdW50ZXJNYXAgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbmxldCB1bmNvbnRyb2xsZWRFbGVtZW50c1NldCA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha1NldCgpO1xubGV0IG1hcmtlck1hcCA9IHt9O1xubGV0IGxvY2tDb3VudCA9IDA7XG5jb25zdCBzdXBwb3J0c0luZXJ0ID0gKCkgPT4gdHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAnaW5lcnQnIGluIEhUTUxFbGVtZW50LnByb3RvdHlwZTtcbmNvbnN0IHVud3JhcEhvc3QgPSBub2RlID0+IG5vZGUgJiYgKG5vZGUuaG9zdCB8fCB1bndyYXBIb3N0KG5vZGUucGFyZW50Tm9kZSkpO1xuY29uc3QgY29ycmVjdEVsZW1lbnRzID0gKHBhcmVudCwgdGFyZ2V0cykgPT4gdGFyZ2V0cy5tYXAodGFyZ2V0ID0+IHtcbiAgaWYgKHBhcmVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBjb25zdCBjb3JyZWN0ZWRUYXJnZXQgPSB1bndyYXBIb3N0KHRhcmdldCk7XG4gIGlmIChwYXJlbnQuY29udGFpbnMoY29ycmVjdGVkVGFyZ2V0KSkge1xuICAgIHJldHVybiBjb3JyZWN0ZWRUYXJnZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59KS5maWx0ZXIoeCA9PiB4ICE9IG51bGwpO1xuZnVuY3Rpb24gYXBwbHlBdHRyaWJ1dGVUb090aGVycyh1bmNvcnJlY3RlZEF2b2lkRWxlbWVudHMsIGJvZHksIGFyaWFIaWRkZW4sIGluZXJ0KSB7XG4gIGNvbnN0IG1hcmtlck5hbWUgPSAnZGF0YS1mbG9hdGluZy11aS1pbmVydCc7XG4gIGNvbnN0IGNvbnRyb2xBdHRyaWJ1dGUgPSBpbmVydCA/ICdpbmVydCcgOiBhcmlhSGlkZGVuID8gJ2FyaWEtaGlkZGVuJyA6IG51bGw7XG4gIGNvbnN0IGF2b2lkRWxlbWVudHMgPSBjb3JyZWN0RWxlbWVudHMoYm9keSwgdW5jb3JyZWN0ZWRBdm9pZEVsZW1lbnRzKTtcbiAgY29uc3QgZWxlbWVudHNUb0tlZXAgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGVsZW1lbnRzVG9TdG9wID0gbmV3IFNldChhdm9pZEVsZW1lbnRzKTtcbiAgY29uc3QgaGlkZGVuRWxlbWVudHMgPSBbXTtcbiAgaWYgKCFtYXJrZXJNYXBbbWFya2VyTmFtZV0pIHtcbiAgICBtYXJrZXJNYXBbbWFya2VyTmFtZV0gPSBuZXcgV2Vha01hcCgpO1xuICB9XG4gIGNvbnN0IG1hcmtlckNvdW50ZXIgPSBtYXJrZXJNYXBbbWFya2VyTmFtZV07XG4gIGF2b2lkRWxlbWVudHMuZm9yRWFjaChrZWVwKTtcbiAgZGVlcChib2R5KTtcbiAgZWxlbWVudHNUb0tlZXAuY2xlYXIoKTtcbiAgZnVuY3Rpb24ga2VlcChlbCkge1xuICAgIGlmICghZWwgfHwgZWxlbWVudHNUb0tlZXAuaGFzKGVsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbGVtZW50c1RvS2VlcC5hZGQoZWwpO1xuICAgIGVsLnBhcmVudE5vZGUgJiYga2VlcChlbC5wYXJlbnROb2RlKTtcbiAgfVxuICBmdW5jdGlvbiBkZWVwKHBhcmVudCkge1xuICAgIGlmICghcGFyZW50IHx8IGVsZW1lbnRzVG9TdG9wLmhhcyhwYXJlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwocGFyZW50LmNoaWxkcmVuLCBub2RlID0+IHtcbiAgICAgIGlmIChlbGVtZW50c1RvS2VlcC5oYXMobm9kZSkpIHtcbiAgICAgICAgZGVlcChub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGF0dHIgPSBjb250cm9sQXR0cmlidXRlID8gbm9kZS5nZXRBdHRyaWJ1dGUoY29udHJvbEF0dHJpYnV0ZSkgOiBudWxsO1xuICAgICAgICBjb25zdCBhbHJlYWR5SGlkZGVuID0gYXR0ciAhPT0gbnVsbCAmJiBhdHRyICE9PSAnZmFsc2UnO1xuICAgICAgICBjb25zdCBjb3VudGVyVmFsdWUgPSAoY291bnRlck1hcC5nZXQobm9kZSkgfHwgMCkgKyAxO1xuICAgICAgICBjb25zdCBtYXJrZXJWYWx1ZSA9IChtYXJrZXJDb3VudGVyLmdldChub2RlKSB8fCAwKSArIDE7XG4gICAgICAgIGNvdW50ZXJNYXAuc2V0KG5vZGUsIGNvdW50ZXJWYWx1ZSk7XG4gICAgICAgIG1hcmtlckNvdW50ZXIuc2V0KG5vZGUsIG1hcmtlclZhbHVlKTtcbiAgICAgICAgaGlkZGVuRWxlbWVudHMucHVzaChub2RlKTtcbiAgICAgICAgaWYgKGNvdW50ZXJWYWx1ZSA9PT0gMSAmJiBhbHJlYWR5SGlkZGVuKSB7XG4gICAgICAgICAgdW5jb250cm9sbGVkRWxlbWVudHNTZXQuYWRkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZXJWYWx1ZSA9PT0gMSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG1hcmtlck5hbWUsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFscmVhZHlIaWRkZW4gJiYgY29udHJvbEF0dHJpYnV0ZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGNvbnRyb2xBdHRyaWJ1dGUsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsb2NrQ291bnQrKztcbiAgcmV0dXJuICgpID0+IHtcbiAgICBoaWRkZW5FbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgY291bnRlclZhbHVlID0gKGNvdW50ZXJNYXAuZ2V0KGVsZW1lbnQpIHx8IDApIC0gMTtcbiAgICAgIGNvbnN0IG1hcmtlclZhbHVlID0gKG1hcmtlckNvdW50ZXIuZ2V0KGVsZW1lbnQpIHx8IDApIC0gMTtcbiAgICAgIGNvdW50ZXJNYXAuc2V0KGVsZW1lbnQsIGNvdW50ZXJWYWx1ZSk7XG4gICAgICBtYXJrZXJDb3VudGVyLnNldChlbGVtZW50LCBtYXJrZXJWYWx1ZSk7XG4gICAgICBpZiAoIWNvdW50ZXJWYWx1ZSkge1xuICAgICAgICBpZiAoIXVuY29udHJvbGxlZEVsZW1lbnRzU2V0LmhhcyhlbGVtZW50KSAmJiBjb250cm9sQXR0cmlidXRlKSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoY29udHJvbEF0dHJpYnV0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdW5jb250cm9sbGVkRWxlbWVudHNTZXQuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXJrZXJWYWx1ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShtYXJrZXJOYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsb2NrQ291bnQtLTtcbiAgICBpZiAoIWxvY2tDb3VudCkge1xuICAgICAgY291bnRlck1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICBjb3VudGVyTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgIHVuY29udHJvbGxlZEVsZW1lbnRzU2V0ID0gbmV3IFdlYWtTZXQoKTtcbiAgICAgIG1hcmtlck1hcCA9IHt9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1hcmtPdGhlcnMoYXZvaWRFbGVtZW50cywgYXJpYUhpZGRlbiwgaW5lcnQpIHtcbiAgaWYgKGFyaWFIaWRkZW4gPT09IHZvaWQgMCkge1xuICAgIGFyaWFIaWRkZW4gPSBmYWxzZTtcbiAgfVxuICBpZiAoaW5lcnQgPT09IHZvaWQgMCkge1xuICAgIGluZXJ0ID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgYm9keSA9IGdldERvY3VtZW50KGF2b2lkRWxlbWVudHNbMF0pLmJvZHk7XG4gIHJldHVybiBhcHBseUF0dHJpYnV0ZVRvT3RoZXJzKGF2b2lkRWxlbWVudHMuY29uY2F0KEFycmF5LmZyb20oYm9keS5xdWVyeVNlbGVjdG9yQWxsKCdbYXJpYS1saXZlXScpKSksIGJvZHksIGFyaWFIaWRkZW4sIGluZXJ0KTtcbn1cblxuY29uc3QgZ2V0VGFiYmFibGVPcHRpb25zID0gKCkgPT4gKHtcbiAgZ2V0U2hhZG93Um9vdDogdHJ1ZSxcbiAgZGlzcGxheUNoZWNrOlxuICAvLyBKU0RPTSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBgdGFiYmFibGVgIGxpYnJhcnkuIFRvIHNvbHZlIHRoaXMgd2UgY2FuXG4gIC8vIGNoZWNrIGlmIGBSZXNpemVPYnNlcnZlcmAgaXMgYSByZWFsIGZ1bmN0aW9uIChub3QgcG9seWZpbGxlZCksIHdoaWNoXG4gIC8vIGRldGVybWluZXMgaWYgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgaXMgSlNET00tbGlrZS5cbiAgdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAnZnVuY3Rpb24nICYmIFJlc2l6ZU9ic2VydmVyLnRvU3RyaW5nKCkuaW5jbHVkZXMoJ1tuYXRpdmUgY29kZV0nKSA/ICdmdWxsJyA6ICdub25lJ1xufSk7XG5mdW5jdGlvbiBnZXRUYWJiYWJsZUluKGNvbnRhaW5lciwgZGlyZWN0aW9uKSB7XG4gIGNvbnN0IGFsbFRhYmJhYmxlID0gdGFiYmFibGUoY29udGFpbmVyLCBnZXRUYWJiYWJsZU9wdGlvbnMoKSk7XG4gIGlmIChkaXJlY3Rpb24gPT09ICdwcmV2Jykge1xuICAgIGFsbFRhYmJhYmxlLnJldmVyc2UoKTtcbiAgfVxuICBjb25zdCBhY3RpdmVJbmRleCA9IGFsbFRhYmJhYmxlLmluZGV4T2YoYWN0aXZlRWxlbWVudChnZXREb2N1bWVudChjb250YWluZXIpKSk7XG4gIGNvbnN0IG5leHRUYWJiYWJsZUVsZW1lbnRzID0gYWxsVGFiYmFibGUuc2xpY2UoYWN0aXZlSW5kZXggKyAxKTtcbiAgcmV0dXJuIG5leHRUYWJiYWJsZUVsZW1lbnRzWzBdO1xufVxuZnVuY3Rpb24gZ2V0TmV4dFRhYmJhYmxlKCkge1xuICByZXR1cm4gZ2V0VGFiYmFibGVJbihkb2N1bWVudC5ib2R5LCAnbmV4dCcpO1xufVxuZnVuY3Rpb24gZ2V0UHJldmlvdXNUYWJiYWJsZSgpIHtcbiAgcmV0dXJuIGdldFRhYmJhYmxlSW4oZG9jdW1lbnQuYm9keSwgJ3ByZXYnKTtcbn1cbmZ1bmN0aW9uIGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBjb250YWluZXIpIHtcbiAgY29uc3QgY29udGFpbmVyRWxlbWVudCA9IGNvbnRhaW5lciB8fCBldmVudC5jdXJyZW50VGFyZ2V0O1xuICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgcmV0dXJuICFyZWxhdGVkVGFyZ2V0IHx8ICFjb250YWlucyhjb250YWluZXJFbGVtZW50LCByZWxhdGVkVGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGRpc2FibGVGb2N1c0luc2lkZShjb250YWluZXIpIHtcbiAgY29uc3QgdGFiYmFibGVFbGVtZW50cyA9IHRhYmJhYmxlKGNvbnRhaW5lciwgZ2V0VGFiYmFibGVPcHRpb25zKCkpO1xuICB0YWJiYWJsZUVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgZWxlbWVudC5kYXRhc2V0LnRhYmluZGV4ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgfHwgJyc7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZW5hYmxlRm9jdXNJbnNpZGUoY29udGFpbmVyKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXRhYmluZGV4XScpO1xuICBlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgIGNvbnN0IHRhYmluZGV4ID0gZWxlbWVudC5kYXRhc2V0LnRhYmluZGV4O1xuICAgIGRlbGV0ZSBlbGVtZW50LmRhdGFzZXQudGFiaW5kZXg7XG4gICAgaWYgKHRhYmluZGV4KSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0YWJpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIFNlZSBEaWVnbyBIYXoncyBTYW5kYm94IGZvciBtYWtpbmcgdGhpcyBsb2dpYyB3b3JrIHdlbGwgb24gU2FmYXJpL2lPUzpcbi8vIGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy90YWJiYWJsZS1wb3J0YWwtZjR0bmc/ZmlsZT0vc3JjL0ZvY3VzVHJhcC50c3hcblxuY29uc3QgSElEREVOX1NUWUxFUyA9IHtcbiAgYm9yZGVyOiAwLFxuICBjbGlwOiAncmVjdCgwIDAgMCAwKScsXG4gIGhlaWdodDogJzFweCcsXG4gIG1hcmdpbjogJy0xcHgnLFxuICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gIHBhZGRpbmc6IDAsXG4gIHBvc2l0aW9uOiAnZml4ZWQnLFxuICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgd2lkdGg6ICcxcHgnLFxuICB0b3A6IDAsXG4gIGxlZnQ6IDBcbn07XG5sZXQgdGltZW91dElkO1xuZnVuY3Rpb24gc2V0QWN0aXZlRWxlbWVudE9uVGFiKGV2ZW50KSB7XG4gIGlmIChldmVudC5rZXkgPT09ICdUYWInKSB7XG4gICAgZXZlbnQudGFyZ2V0O1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICB9XG59XG5jb25zdCBGb2N1c0d1YXJkID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gRm9jdXNHdWFyZChwcm9wcywgcmVmKSB7XG4gIGNvbnN0IFtyb2xlLCBzZXRSb2xlXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoaXNTYWZhcmkoKSkge1xuICAgICAgLy8gVW5saWtlIG90aGVyIHNjcmVlbiByZWFkZXJzIHN1Y2ggYXMgTlZEQSBhbmQgSkFXUywgdGhlIHZpcnR1YWwgY3Vyc29yXG4gICAgICAvLyBvbiBWb2ljZU92ZXIgZG9lcyB0cmlnZ2VyIHRoZSBvbkZvY3VzIGV2ZW50LCBzbyB3ZSBjYW4gdXNlIHRoZSBmb2N1c1xuICAgICAgLy8gdHJhcCBlbGVtZW50LiBPbiBTYWZhcmksIG9ubHkgYnV0dG9ucyB0cmlnZ2VyIHRoZSBvbkZvY3VzIGV2ZW50LlxuICAgICAgLy8gTkI6IFwiZ3JvdXBcIiByb2xlIGluIHRoZSBTYW5kYm94IG5vIGxvbmdlciBhcHBlYXJzIHRvIHdvcmssIG11c3QgYmUgYVxuICAgICAgLy8gYnV0dG9uIHJvbGUuXG4gICAgICBzZXRSb2xlKCdidXR0b24nKTtcbiAgICB9XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHNldEFjdGl2ZUVsZW1lbnRPblRhYik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBzZXRBY3RpdmVFbGVtZW50T25UYWIpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVzdFByb3BzID0ge1xuICAgIHJlZixcbiAgICB0YWJJbmRleDogMCxcbiAgICAvLyBSb2xlIGlzIG9ubHkgZm9yIFZvaWNlT3ZlclxuICAgIHJvbGUsXG4gICAgJ2FyaWEtaGlkZGVuJzogcm9sZSA/IHVuZGVmaW5lZCA6IHRydWUsXG4gICAgW2NyZWF0ZUF0dHJpYnV0ZSgnZm9jdXMtZ3VhcmQnKV06ICcnLFxuICAgIHN0eWxlOiBISURERU5fU1RZTEVTXG4gIH07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgX2V4dGVuZHMoe30sIHByb3BzLCByZXN0UHJvcHMpKTtcbn0pO1xuXG5jb25zdCBQb3J0YWxDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5mdW5jdGlvbiB1c2VGbG9hdGluZ1BvcnRhbE5vZGUoX3RlbXApIHtcbiAgbGV0IHtcbiAgICBpZCxcbiAgICByb290XG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgY29uc3QgW3BvcnRhbE5vZGUsIHNldFBvcnRhbE5vZGVdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHVuaXF1ZUlkID0gdXNlSWQoKTtcbiAgY29uc3QgcG9ydGFsQ29udGV4dCA9IHVzZVBvcnRhbENvbnRleHQoKTtcbiAgY29uc3QgZGF0YSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBpZCxcbiAgICByb290LFxuICAgIHBvcnRhbENvbnRleHQsXG4gICAgdW5pcXVlSWRcbiAgfSksIFtpZCwgcm9vdCwgcG9ydGFsQ29udGV4dCwgdW5pcXVlSWRdKTtcbiAgY29uc3QgZGF0YVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBvcnRhbE5vZGUgPT0gbnVsbCB8fCBwb3J0YWxOb2RlLnJlbW92ZSgpO1xuICAgIH07XG4gIH0sIFtwb3J0YWxOb2RlLCBkYXRhXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZGF0YVJlZi5jdXJyZW50ID09PSBkYXRhKSByZXR1cm47XG4gICAgZGF0YVJlZi5jdXJyZW50ID0gZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIHJvb3QsXG4gICAgICBwb3J0YWxDb250ZXh0LFxuICAgICAgdW5pcXVlSWRcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCBleGlzdGluZ0lkUm9vdCA9IGlkID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogbnVsbDtcbiAgICBjb25zdCBhdHRyID0gY3JlYXRlQXR0cmlidXRlKCdwb3J0YWwnKTtcbiAgICBpZiAoZXhpc3RpbmdJZFJvb3QpIHtcbiAgICAgIGNvbnN0IHN1YlJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHN1YlJvb3QuaWQgPSB1bmlxdWVJZDtcbiAgICAgIHN1YlJvb3Quc2V0QXR0cmlidXRlKGF0dHIsICcnKTtcbiAgICAgIGV4aXN0aW5nSWRSb290LmFwcGVuZENoaWxkKHN1YlJvb3QpO1xuICAgICAgc2V0UG9ydGFsTm9kZShzdWJSb290KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNvbnRhaW5lciA9IHJvb3QgfHwgKHBvcnRhbENvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSk7XG4gICAgICBpZiAoY29udGFpbmVyICYmICFpc0VsZW1lbnQoY29udGFpbmVyKSkgY29udGFpbmVyID0gY29udGFpbmVyLmN1cnJlbnQ7XG4gICAgICBjb250YWluZXIgPSBjb250YWluZXIgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgIGxldCBpZFdyYXBwZXIgPSBudWxsO1xuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIGlkV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBpZFdyYXBwZXIuaWQgPSBpZDtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGlkV3JhcHBlcik7XG4gICAgICB9XG4gICAgICBjb25zdCBzdWJSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzdWJSb290LmlkID0gdW5pcXVlSWQ7XG4gICAgICBzdWJSb290LnNldEF0dHJpYnV0ZShhdHRyLCAnJyk7XG4gICAgICBjb250YWluZXIgPSBpZFdyYXBwZXIgfHwgY29udGFpbmVyO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHN1YlJvb3QpO1xuICAgICAgc2V0UG9ydGFsTm9kZShzdWJSb290KTtcbiAgICB9XG4gIH0sIFtkYXRhXSk7XG4gIHJldHVybiBwb3J0YWxOb2RlO1xufVxuLyoqXG4gKiBQb3J0YWxzIHRoZSBmbG9hdGluZyBlbGVtZW50IGludG8gYSBnaXZlbiBjb250YWluZXIgZWxlbWVudCDigJQgYnkgZGVmYXVsdCxcbiAqIG91dHNpZGUgb2YgdGhlIGFwcCByb290IGFuZCBpbnRvIHRoZSBib2R5LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nUG9ydGFsXG4gKi9cbmZ1bmN0aW9uIEZsb2F0aW5nUG9ydGFsKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlbixcbiAgICBpZCxcbiAgICByb290ID0gbnVsbCxcbiAgICBwcmVzZXJ2ZVRhYk9yZGVyID0gdHJ1ZVxuICB9ID0gX3JlZjtcbiAgY29uc3QgcG9ydGFsTm9kZSA9IHVzZUZsb2F0aW5nUG9ydGFsTm9kZSh7XG4gICAgaWQsXG4gICAgcm9vdFxuICB9KTtcbiAgY29uc3QgW2ZvY3VzTWFuYWdlclN0YXRlLCBzZXRGb2N1c01hbmFnZXJTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgYmVmb3JlT3V0c2lkZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgYWZ0ZXJPdXRzaWRlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBiZWZvcmVJbnNpZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGFmdGVySW5zaWRlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBzaG91bGRSZW5kZXJHdWFyZHMgPVxuICAvLyBUaGUgRm9jdXNNYW5hZ2VyIGFuZCB0aGVyZWZvcmUgZmxvYXRpbmcgZWxlbWVudCBhcmUgY3VycmVudGx5IG9wZW4vXG4gIC8vIHJlbmRlcmVkLlxuICAhIWZvY3VzTWFuYWdlclN0YXRlICYmXG4gIC8vIEd1YXJkcyBhcmUgb25seSBmb3Igbm9uLW1vZGFsIGZvY3VzIG1hbmFnZW1lbnQuXG4gICFmb2N1c01hbmFnZXJTdGF0ZS5tb2RhbCAmJlxuICAvLyBEb24ndCByZW5kZXIgaWYgdW5tb3VudCBpcyB0cmFuc2l0aW9uaW5nLlxuICBmb2N1c01hbmFnZXJTdGF0ZS5vcGVuICYmIHByZXNlcnZlVGFiT3JkZXIgJiYgISEocm9vdCB8fCBwb3J0YWxOb2RlKTtcblxuICAvLyBodHRwczovL2NvZGVzYW5kYm94LmlvL3MvdGFiYmFibGUtcG9ydGFsLWY0dG5nP2ZpbGU9L3NyYy9UYWJiYWJsZVBvcnRhbC50c3hcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXBvcnRhbE5vZGUgfHwgIXByZXNlcnZlVGFiT3JkZXIgfHwgZm9jdXNNYW5hZ2VyU3RhdGUgIT0gbnVsbCAmJiBmb2N1c01hbmFnZXJTdGF0ZS5tb2RhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBlbGVtZW50cyBpbnNpZGUgdGhlIHBvcnRhbCBlbGVtZW50IGFyZSB0YWJiYWJsZSBvbmx5IHdoZW4gdGhlXG4gICAgLy8gcG9ydGFsIGhhcyBhbHJlYWR5IGJlZW4gZm9jdXNlZCwgZWl0aGVyIGJ5IHRhYmJpbmcgaW50byBhIGZvY3VzIHRyYXBcbiAgICAvLyBlbGVtZW50IG91dHNpZGUgb3IgdXNpbmcgdGhlIG1vdXNlLlxuICAgIGZ1bmN0aW9uIG9uRm9jdXMoZXZlbnQpIHtcbiAgICAgIGlmIChwb3J0YWxOb2RlICYmIGlzT3V0c2lkZUV2ZW50KGV2ZW50KSkge1xuICAgICAgICBjb25zdCBmb2N1c2luZyA9IGV2ZW50LnR5cGUgPT09ICdmb2N1c2luJztcbiAgICAgICAgY29uc3QgbWFuYWdlRm9jdXMgPSBmb2N1c2luZyA/IGVuYWJsZUZvY3VzSW5zaWRlIDogZGlzYWJsZUZvY3VzSW5zaWRlO1xuICAgICAgICBtYW5hZ2VGb2N1cyhwb3J0YWxOb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTGlzdGVuIHRvIHRoZSBldmVudCBvbiB0aGUgY2FwdHVyZSBwaGFzZSBzbyB0aGV5IHJ1biBiZWZvcmUgdGhlIGZvY3VzXG4gICAgLy8gdHJhcCBlbGVtZW50cyBvbkZvY3VzIHByb3AgaXMgY2FsbGVkLlxuICAgIHBvcnRhbE5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIG9uRm9jdXMsIHRydWUpO1xuICAgIHBvcnRhbE5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBvbkZvY3VzLCB0cnVlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcG9ydGFsTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgb25Gb2N1cywgdHJ1ZSk7XG4gICAgICBwb3J0YWxOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0Jywgb25Gb2N1cywgdHJ1ZSk7XG4gICAgfTtcbiAgfSwgW3BvcnRhbE5vZGUsIHByZXNlcnZlVGFiT3JkZXIsIGZvY3VzTWFuYWdlclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c01hbmFnZXJTdGF0ZS5tb2RhbF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUG9ydGFsQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICBwcmVzZXJ2ZVRhYk9yZGVyLFxuICAgICAgYmVmb3JlT3V0c2lkZVJlZixcbiAgICAgIGFmdGVyT3V0c2lkZVJlZixcbiAgICAgIGJlZm9yZUluc2lkZVJlZixcbiAgICAgIGFmdGVySW5zaWRlUmVmLFxuICAgICAgcG9ydGFsTm9kZSxcbiAgICAgIHNldEZvY3VzTWFuYWdlclN0YXRlXG4gICAgfSksIFtwcmVzZXJ2ZVRhYk9yZGVyLCBwb3J0YWxOb2RlXSlcbiAgfSwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIHBvcnRhbE5vZGUgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9jdXNHdWFyZCwge1xuICAgIFwiZGF0YS10eXBlXCI6IFwib3V0c2lkZVwiLFxuICAgIHJlZjogYmVmb3JlT3V0c2lkZVJlZixcbiAgICBvbkZvY3VzOiBldmVudCA9PiB7XG4gICAgICBpZiAoaXNPdXRzaWRlRXZlbnQoZXZlbnQsIHBvcnRhbE5vZGUpKSB7XG4gICAgICAgIHZhciBfYmVmb3JlSW5zaWRlUmVmJGN1cnI7XG4gICAgICAgIChfYmVmb3JlSW5zaWRlUmVmJGN1cnIgPSBiZWZvcmVJbnNpZGVSZWYuY3VycmVudCkgPT0gbnVsbCB8fCBfYmVmb3JlSW5zaWRlUmVmJGN1cnIuZm9jdXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHByZXZUYWJiYWJsZSA9IGdldFByZXZpb3VzVGFiYmFibGUoKSB8fCAoZm9jdXNNYW5hZ2VyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzTWFuYWdlclN0YXRlLnJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQpO1xuICAgICAgICBwcmV2VGFiYmFibGUgPT0gbnVsbCB8fCBwcmV2VGFiYmFibGUuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pLCBzaG91bGRSZW5kZXJHdWFyZHMgJiYgcG9ydGFsTm9kZSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIFwiYXJpYS1vd25zXCI6IHBvcnRhbE5vZGUuaWQsXG4gICAgc3R5bGU6IEhJRERFTl9TVFlMRVNcbiAgfSksIHBvcnRhbE5vZGUgJiYgLyojX19QVVJFX18qL2NyZWF0ZVBvcnRhbChjaGlsZHJlbiwgcG9ydGFsTm9kZSksIHNob3VsZFJlbmRlckd1YXJkcyAmJiBwb3J0YWxOb2RlICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzR3VhcmQsIHtcbiAgICBcImRhdGEtdHlwZVwiOiBcIm91dHNpZGVcIixcbiAgICByZWY6IGFmdGVyT3V0c2lkZVJlZixcbiAgICBvbkZvY3VzOiBldmVudCA9PiB7XG4gICAgICBpZiAoaXNPdXRzaWRlRXZlbnQoZXZlbnQsIHBvcnRhbE5vZGUpKSB7XG4gICAgICAgIHZhciBfYWZ0ZXJJbnNpZGVSZWYkY3VycmU7XG4gICAgICAgIChfYWZ0ZXJJbnNpZGVSZWYkY3VycmUgPSBhZnRlckluc2lkZVJlZi5jdXJyZW50KSA9PSBudWxsIHx8IF9hZnRlckluc2lkZVJlZiRjdXJyZS5mb2N1cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbmV4dFRhYmJhYmxlID0gZ2V0TmV4dFRhYmJhYmxlKCkgfHwgKGZvY3VzTWFuYWdlclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c01hbmFnZXJTdGF0ZS5yZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KTtcbiAgICAgICAgbmV4dFRhYmJhYmxlID09IG51bGwgfHwgbmV4dFRhYmJhYmxlLmZvY3VzKCk7XG4gICAgICAgIChmb2N1c01hbmFnZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNNYW5hZ2VyU3RhdGUuY2xvc2VPbkZvY3VzT3V0KSAmJiAoZm9jdXNNYW5hZ2VyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzTWFuYWdlclN0YXRlLm9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pKTtcbn1cbmNvbnN0IHVzZVBvcnRhbENvbnRleHQgPSAoKSA9PiBSZWFjdC51c2VDb250ZXh0KFBvcnRhbENvbnRleHQpO1xuXG5jb25zdCBMSVNUX0xJTUlUID0gMjA7XG5sZXQgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cyA9IFtdO1xuZnVuY3Rpb24gYWRkUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KGVsZW1lbnQpIHtcbiAgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cyA9IHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMuZmlsdGVyKGVsID0+IGVsLmlzQ29ubmVjdGVkKTtcbiAgaWYgKGVsZW1lbnQgJiYgZ2V0Tm9kZU5hbWUoZWxlbWVudCkgIT09ICdib2R5Jykge1xuICAgIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICBpZiAocHJldmlvdXNseUZvY3VzZWRFbGVtZW50cy5sZW5ndGggPiBMSVNUX0xJTUlUKSB7XG4gICAgICBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzID0gcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cy5zbGljZSgtTElTVF9MSU1JVCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQoKSB7XG4gIHJldHVybiBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzLnNsaWNlKCkucmV2ZXJzZSgpLmZpbmQoZWwgPT4gZWwuaXNDb25uZWN0ZWQpO1xufVxuY29uc3QgVmlzdWFsbHlIaWRkZW5EaXNtaXNzID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gVmlzdWFsbHlIaWRkZW5EaXNtaXNzKHByb3BzLCByZWYpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgcmVmOiByZWYsXG4gICAgdGFiSW5kZXg6IC0xLFxuICAgIHN0eWxlOiBISURERU5fU1RZTEVTXG4gIH0pKTtcbn0pO1xuLyoqXG4gKiBQcm92aWRlcyBmb2N1cyBtYW5hZ2VtZW50IGZvciB0aGUgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0ZvY3VzTWFuYWdlclxuICovXG5mdW5jdGlvbiBGbG9hdGluZ0ZvY3VzTWFuYWdlcihwcm9wcykge1xuICBjb25zdCB7XG4gICAgY29udGV4dCxcbiAgICBjaGlsZHJlbixcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgIG9yZGVyID0gWydjb250ZW50J10sXG4gICAgZ3VhcmRzOiBfZ3VhcmRzID0gdHJ1ZSxcbiAgICBpbml0aWFsRm9jdXMgPSAwLFxuICAgIHJldHVybkZvY3VzID0gdHJ1ZSxcbiAgICBtb2RhbCA9IHRydWUsXG4gICAgdmlzdWFsbHlIaWRkZW5EaXNtaXNzID0gZmFsc2UsXG4gICAgY2xvc2VPbkZvY3VzT3V0ID0gdHJ1ZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIHJlZnMsXG4gICAgbm9kZUlkLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBldmVudHMsXG4gICAgZGF0YVJlZixcbiAgICBlbGVtZW50czoge1xuICAgICAgZG9tUmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmdcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCBpZ25vcmVJbml0aWFsRm9jdXMgPSB0eXBlb2YgaW5pdGlhbEZvY3VzID09PSAnbnVtYmVyJyAmJiBpbml0aWFsRm9jdXMgPCAwO1xuICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIGEgY29tYm9ib3ggYW5kIGlzIHR5cGVhYmxlIChlLmcuIGlucHV0L3RleHRhcmVhKSxcbiAgLy8gdGhlcmUgYXJlIGRpZmZlcmVudCBmb2N1cyBzZW1hbnRpY3MuIFRoZSBndWFyZHMgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCwgYnV0XG4gIC8vIGFyaWEtaGlkZGVuIHNob3VsZCBiZSBhcHBsaWVkIHRvIGFsbCBub2RlcyBzdGlsbC4gRnVydGhlciwgdGhlIHZpc3VhbGx5XG4gIC8vIGhpZGRlbiBkaXNtaXNzIGJ1dHRvbiBzaG91bGQgb25seSBhcHBlYXIgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCwgbm90IHRoZVxuICAvLyBzdGFydC5cbiAgY29uc3QgaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94ID0gaXNUeXBlYWJsZUNvbWJvYm94KGRvbVJlZmVyZW5jZSkgJiYgaWdub3JlSW5pdGlhbEZvY3VzO1xuXG4gIC8vIEZvcmNlIHRoZSBndWFyZHMgdG8gYmUgcmVuZGVyZWQgaWYgdGhlIGBpbmVydGAgYXR0cmlidXRlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gIGNvbnN0IGd1YXJkcyA9IHN1cHBvcnRzSW5lcnQoKSA/IF9ndWFyZHMgOiB0cnVlO1xuICBjb25zdCBvcmRlclJlZiA9IHVzZUxhdGVzdFJlZihvcmRlcik7XG4gIGNvbnN0IGluaXRpYWxGb2N1c1JlZiA9IHVzZUxhdGVzdFJlZihpbml0aWFsRm9jdXMpO1xuICBjb25zdCByZXR1cm5Gb2N1c1JlZiA9IHVzZUxhdGVzdFJlZihyZXR1cm5Gb2N1cyk7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3QgcG9ydGFsQ29udGV4dCA9IHVzZVBvcnRhbENvbnRleHQoKTtcbiAgY29uc3Qgc3RhcnREaXNtaXNzQnV0dG9uUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBlbmREaXNtaXNzQnV0dG9uUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBwcmV2ZW50UmV0dXJuRm9jdXNSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBpc1BvaW50ZXJEb3duUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgaXNJbnNpZGVQb3J0YWwgPSBwb3J0YWxDb250ZXh0ICE9IG51bGw7XG4gIGNvbnN0IGdldFRhYmJhYmxlQ29udGVudCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICBpZiAoY29udGFpbmVyID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnRhaW5lciA9IGZsb2F0aW5nO1xuICAgIH1cbiAgICByZXR1cm4gY29udGFpbmVyID8gdGFiYmFibGUoY29udGFpbmVyLCBnZXRUYWJiYWJsZU9wdGlvbnMoKSkgOiBbXTtcbiAgfSwgW2Zsb2F0aW5nXSk7XG4gIGNvbnN0IGdldFRhYmJhYmxlRWxlbWVudHMgPSBSZWFjdC51c2VDYWxsYmFjayhjb250YWluZXIgPT4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBnZXRUYWJiYWJsZUNvbnRlbnQoY29udGFpbmVyKTtcbiAgICByZXR1cm4gb3JkZXJSZWYuY3VycmVudC5tYXAodHlwZSA9PiB7XG4gICAgICBpZiAoZG9tUmVmZXJlbmNlICYmIHR5cGUgPT09ICdyZWZlcmVuY2UnKSB7XG4gICAgICAgIHJldHVybiBkb21SZWZlcmVuY2U7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgJiYgdHlwZSA9PT0gJ2Zsb2F0aW5nJykge1xuICAgICAgICByZXR1cm4gZmxvYXRpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5maWx0ZXIoQm9vbGVhbikuZmxhdCgpO1xuICB9LCBbZG9tUmVmZXJlbmNlLCBmbG9hdGluZywgb3JkZXJSZWYsIGdldFRhYmJhYmxlQ29udGVudF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhbW9kYWwpIHJldHVybjtcbiAgICBmdW5jdGlvbiBvbktleURvd24oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5rZXkgPT09ICdUYWInKSB7XG4gICAgICAgIC8vIFRoZSBmb2N1cyBndWFyZHMgaGF2ZSBub3RoaW5nIHRvIGZvY3VzLCBzbyB3ZSBuZWVkIHRvIHN0b3AgdGhlIGV2ZW50LlxuICAgICAgICBpZiAoY29udGFpbnMoZmxvYXRpbmcsIGFjdGl2ZUVsZW1lbnQoZ2V0RG9jdW1lbnQoZmxvYXRpbmcpKSkgJiYgZ2V0VGFiYmFibGVDb250ZW50KCkubGVuZ3RoID09PSAwICYmICFpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3gpIHtcbiAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVscyA9IGdldFRhYmJhYmxlRWxlbWVudHMoKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgaWYgKG9yZGVyUmVmLmN1cnJlbnRbMF0gPT09ICdyZWZlcmVuY2UnICYmIHRhcmdldCA9PT0gZG9tUmVmZXJlbmNlKSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIGVucXVldWVGb2N1cyhlbHNbZWxzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW5xdWV1ZUZvY3VzKGVsc1sxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcmRlclJlZi5jdXJyZW50WzFdID09PSAnZmxvYXRpbmcnICYmIHRhcmdldCA9PT0gZmxvYXRpbmcgJiYgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIGVucXVldWVGb2N1cyhlbHNbMF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGZsb2F0aW5nKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5RG93bik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXlEb3duKTtcbiAgICB9O1xuICB9LCBbZGlzYWJsZWQsIGRvbVJlZmVyZW5jZSwgZmxvYXRpbmcsIG1vZGFsLCBvcmRlclJlZiwgcmVmcywgaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94LCBnZXRUYWJiYWJsZUNvbnRlbnQsIGdldFRhYmJhYmxlRWxlbWVudHNdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIWNsb3NlT25Gb2N1c091dCkgcmV0dXJuO1xuXG4gICAgLy8gSW4gU2FmYXJpLCBidXR0b25zIGxvc2UgZm9jdXMgd2hlbiBwcmVzc2luZyB0aGVtLlxuICAgIGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJEb3duKCkge1xuICAgICAgaXNQb2ludGVyRG93blJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpc1BvaW50ZXJEb3duUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVGb2N1c091dHNpZGUoZXZlbnQpIHtcbiAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBjb25zdCBtb3ZlZFRvVW5yZWxhdGVkTm9kZSA9ICEoY29udGFpbnMoZG9tUmVmZXJlbmNlLCByZWxhdGVkVGFyZ2V0KSB8fCBjb250YWlucyhmbG9hdGluZywgcmVsYXRlZFRhcmdldCkgfHwgY29udGFpbnMocmVsYXRlZFRhcmdldCwgZmxvYXRpbmcpIHx8IGNvbnRhaW5zKHBvcnRhbENvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSwgcmVsYXRlZFRhcmdldCkgfHwgcmVsYXRlZFRhcmdldCAhPSBudWxsICYmIHJlbGF0ZWRUYXJnZXQuaGFzQXR0cmlidXRlKGNyZWF0ZUF0dHJpYnV0ZSgnZm9jdXMtZ3VhcmQnKSkgfHwgdHJlZSAmJiAoZ2V0Q2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpLmZpbmQobm9kZSA9PiB7XG4gICAgICAgICAgdmFyIF9ub2RlJGNvbnRleHQsIF9ub2RlJGNvbnRleHQyO1xuICAgICAgICAgIHJldHVybiBjb250YWlucygoX25vZGUkY29udGV4dCA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQuZWxlbWVudHMuZmxvYXRpbmcsIHJlbGF0ZWRUYXJnZXQpIHx8IGNvbnRhaW5zKChfbm9kZSRjb250ZXh0MiA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQyLmVsZW1lbnRzLmRvbVJlZmVyZW5jZSwgcmVsYXRlZFRhcmdldCk7XG4gICAgICAgIH0pIHx8IGdldEFuY2VzdG9ycyh0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkuZmluZChub2RlID0+IHtcbiAgICAgICAgICB2YXIgX25vZGUkY29udGV4dDMsIF9ub2RlJGNvbnRleHQ0O1xuICAgICAgICAgIHJldHVybiAoKF9ub2RlJGNvbnRleHQzID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dDMuZWxlbWVudHMuZmxvYXRpbmcpID09PSByZWxhdGVkVGFyZ2V0IHx8ICgoX25vZGUkY29udGV4dDQgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0NC5lbGVtZW50cy5kb21SZWZlcmVuY2UpID09PSByZWxhdGVkVGFyZ2V0O1xuICAgICAgICB9KSkpO1xuXG4gICAgICAgIC8vIEZvY3VzIGRpZCBub3QgbW92ZSBpbnNpZGUgdGhlIGZsb2F0aW5nIHRyZWUsIGFuZCB0aGVyZSBhcmUgbm8gdGFiYmFibGVcbiAgICAgICAgLy8gcG9ydGFsIGd1YXJkcyB0byBoYW5kbGUgY2xvc2luZy5cbiAgICAgICAgaWYgKHJlbGF0ZWRUYXJnZXQgJiYgbW92ZWRUb1VucmVsYXRlZE5vZGUgJiYgIWlzUG9pbnRlckRvd25SZWYuY3VycmVudCAmJlxuICAgICAgICAvLyBGaXggUmVhY3QgMTggU3RyaWN0IE1vZGUgcmV0dXJuRm9jdXMgZHVlIHRvIGRvdWJsZSByZW5kZXJpbmcuXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQgIT09IGdldFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCgpKSB7XG4gICAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGZsb2F0aW5nICYmIGlzSFRNTEVsZW1lbnQoZG9tUmVmZXJlbmNlKSkge1xuICAgICAgZG9tUmVmZXJlbmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgaGFuZGxlRm9jdXNPdXRzaWRlKTtcbiAgICAgIGRvbVJlZmVyZW5jZS5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICFtb2RhbCAmJiBmbG9hdGluZy5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGhhbmRsZUZvY3VzT3V0c2lkZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkb21SZWZlcmVuY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBoYW5kbGVGb2N1c091dHNpZGUpO1xuICAgICAgICBkb21SZWZlcmVuY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBoYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgICFtb2RhbCAmJiBmbG9hdGluZy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGhhbmRsZUZvY3VzT3V0c2lkZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2Rpc2FibGVkLCBkb21SZWZlcmVuY2UsIGZsb2F0aW5nLCBtb2RhbCwgbm9kZUlkLCB0cmVlLCBwb3J0YWxDb250ZXh0LCBvbk9wZW5DaGFuZ2UsIGNsb3NlT25Gb2N1c091dF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHZhciBfcG9ydGFsQ29udGV4dCRwb3J0YWw7XG4gICAgaWYgKGRpc2FibGVkKSByZXR1cm47XG5cbiAgICAvLyBEb24ndCBoaWRlIHBvcnRhbHMgbmVzdGVkIHdpdGhpbiB0aGUgcGFyZW50IHBvcnRhbC5cbiAgICBjb25zdCBwb3J0YWxOb2RlcyA9IEFycmF5LmZyb20oKHBvcnRhbENvbnRleHQgPT0gbnVsbCB8fCAoX3BvcnRhbENvbnRleHQkcG9ydGFsID0gcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlKSA9PSBudWxsID8gdm9pZCAwIDogX3BvcnRhbENvbnRleHQkcG9ydGFsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbXCIgKyBjcmVhdGVBdHRyaWJ1dGUoJ3BvcnRhbCcpICsgXCJdXCIpKSB8fCBbXSk7XG4gICAgaWYgKGZsb2F0aW5nKSB7XG4gICAgICBjb25zdCBpbnNpZGVFbGVtZW50cyA9IFtmbG9hdGluZywgLi4ucG9ydGFsTm9kZXMsIHN0YXJ0RGlzbWlzc0J1dHRvblJlZi5jdXJyZW50LCBlbmREaXNtaXNzQnV0dG9uUmVmLmN1cnJlbnQsIG9yZGVyUmVmLmN1cnJlbnQuaW5jbHVkZXMoJ3JlZmVyZW5jZScpIHx8IGlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCA/IGRvbVJlZmVyZW5jZSA6IG51bGxdLmZpbHRlcih4ID0+IHggIT0gbnVsbCk7XG4gICAgICBjb25zdCBjbGVhbnVwID0gbW9kYWwgfHwgaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94ID8gbWFya090aGVycyhpbnNpZGVFbGVtZW50cywgZ3VhcmRzLCAhZ3VhcmRzKSA6IG1hcmtPdGhlcnMoaW5zaWRlRWxlbWVudHMpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtkaXNhYmxlZCwgZG9tUmVmZXJlbmNlLCBmbG9hdGluZywgbW9kYWwsIG9yZGVyUmVmLCBwb3J0YWxDb250ZXh0LCBpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3gsIGd1YXJkc10pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8ICFmbG9hdGluZykgcmV0dXJuO1xuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGZsb2F0aW5nKTtcbiAgICBjb25zdCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBhY3RpdmVFbGVtZW50KGRvYyk7XG5cbiAgICAvLyBXYWl0IGZvciBhbnkgbGF5b3V0IGVmZmVjdCBzdGF0ZSBzZXR0ZXJzIHRvIGV4ZWN1dGUgdG8gc2V0IGB0YWJJbmRleGAuXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgY29uc3QgZm9jdXNhYmxlRWxlbWVudHMgPSBnZXRUYWJiYWJsZUVsZW1lbnRzKGZsb2F0aW5nKTtcbiAgICAgIGNvbnN0IGluaXRpYWxGb2N1c1ZhbHVlID0gaW5pdGlhbEZvY3VzUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBlbFRvRm9jdXMgPSAodHlwZW9mIGluaXRpYWxGb2N1c1ZhbHVlID09PSAnbnVtYmVyJyA/IGZvY3VzYWJsZUVsZW1lbnRzW2luaXRpYWxGb2N1c1ZhbHVlXSA6IGluaXRpYWxGb2N1c1ZhbHVlLmN1cnJlbnQpIHx8IGZsb2F0aW5nO1xuICAgICAgY29uc3QgZm9jdXNBbHJlYWR5SW5zaWRlRmxvYXRpbmdFbCA9IGNvbnRhaW5zKGZsb2F0aW5nLCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQpO1xuICAgICAgaWYgKCFpZ25vcmVJbml0aWFsRm9jdXMgJiYgIWZvY3VzQWxyZWFkeUluc2lkZUZsb2F0aW5nRWwgJiYgb3Blbikge1xuICAgICAgICBlbnF1ZXVlRm9jdXMoZWxUb0ZvY3VzLCB7XG4gICAgICAgICAgcHJldmVudFNjcm9sbDogZWxUb0ZvY3VzID09PSBmbG9hdGluZ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW2Rpc2FibGVkLCBvcGVuLCBmbG9hdGluZywgaWdub3JlSW5pdGlhbEZvY3VzLCBnZXRUYWJiYWJsZUVsZW1lbnRzLCBpbml0aWFsRm9jdXNSZWZdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhZmxvYXRpbmcpIHJldHVybjtcbiAgICBsZXQgcHJldmVudFJldHVybkZvY3VzU2Nyb2xsID0gZmFsc2U7XG4gICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQoZmxvYXRpbmcpO1xuICAgIGNvbnN0IHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQoZG9jKTtcbiAgICBjb25zdCBjb250ZXh0RGF0YSA9IGRhdGFSZWYuY3VycmVudDtcbiAgICBhZGRQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQocHJldmlvdXNseUZvY3VzZWRFbGVtZW50KTtcblxuICAgIC8vIERpc21pc3NpbmcgdmlhIG91dHNpZGUgcHJlc3Mgc2hvdWxkIGFsd2F5cyBpZ25vcmUgYHJldHVybkZvY3VzYCB0b1xuICAgIC8vIHByZXZlbnQgdW53YW50ZWQgc2Nyb2xsaW5nLlxuICAgIGZ1bmN0aW9uIG9uT3BlbkNoYW5nZShfcmVmKSB7XG4gICAgICBsZXQge1xuICAgICAgICByZWFzb24sXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBuZXN0ZWRcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgaWYgKHJlYXNvbiA9PT0gJ2VzY2FwZS1rZXknICYmIHJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQpIHtcbiAgICAgICAgYWRkUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KHJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHJlYXNvbiA9PT0gJ2hvdmVyJyAmJiBldmVudC50eXBlID09PSAnbW91c2VsZWF2ZScpIHtcbiAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlYXNvbiAhPT0gJ291dHNpZGUtcHJlc3MnKSByZXR1cm47XG4gICAgICBpZiAobmVzdGVkKSB7XG4gICAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1Njcm9sbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9ICEoaXNWaXJ0dWFsQ2xpY2soZXZlbnQpIHx8IGlzVmlydHVhbFBvaW50ZXJFdmVudChldmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBldmVudHMub24oJ29wZW5jaGFuZ2UnLCBvbk9wZW5DaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBldmVudHMub2ZmKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICAgIGNvbnN0IGFjdGl2ZUVsID0gYWN0aXZlRWxlbWVudChkb2MpO1xuICAgICAgY29uc3QgaXNGb2N1c0luc2lkZUZsb2F0aW5nVHJlZSA9IGNvbnRhaW5zKGZsb2F0aW5nLCBhY3RpdmVFbCkgfHwgdHJlZSAmJiBnZXRDaGlsZHJlbih0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkuc29tZShub2RlID0+IHtcbiAgICAgICAgdmFyIF9ub2RlJGNvbnRleHQ1O1xuICAgICAgICByZXR1cm4gY29udGFpbnMoKF9ub2RlJGNvbnRleHQ1ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dDUuZWxlbWVudHMuZmxvYXRpbmcsIGFjdGl2ZUVsKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2hvdWxkRm9jdXNSZWZlcmVuY2UgPSBpc0ZvY3VzSW5zaWRlRmxvYXRpbmdUcmVlIHx8IGNvbnRleHREYXRhLm9wZW5FdmVudCAmJiBbJ2NsaWNrJywgJ21vdXNlZG93biddLmluY2x1ZGVzKGNvbnRleHREYXRhLm9wZW5FdmVudC50eXBlKTtcbiAgICAgIGlmIChzaG91bGRGb2N1c1JlZmVyZW5jZSAmJiByZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KSB7XG4gICAgICAgIGFkZFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudChyZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJldHVybkVsZW1lbnQgPSBnZXRQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQoKTtcbiAgICAgIGlmIChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAgIHJldHVybkZvY3VzUmVmLmN1cnJlbnQgJiYgIXByZXZlbnRSZXR1cm5Gb2N1c1JlZi5jdXJyZW50ICYmIGlzSFRNTEVsZW1lbnQocmV0dXJuRWxlbWVudCkgJiYgKFxuICAgICAgLy8gSWYgdGhlIGZvY3VzIG1vdmVkIHNvbWV3aGVyZSBlbHNlIGFmdGVyIG1vdW50LCBhdm9pZCByZXR1cm5pbmcgZm9jdXNcbiAgICAgIC8vIHNpbmNlIGl0IGxpa2VseSBlbnRlcmVkIGEgZGlmZmVyZW50IGVsZW1lbnQgd2hpY2ggc2hvdWxkIGJlXG4gICAgICAvLyByZXNwZWN0ZWQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjYwN1xuICAgICAgcmV0dXJuRWxlbWVudCAhPT0gYWN0aXZlRWwgJiYgYWN0aXZlRWwgIT09IGRvYy5ib2R5ID8gaXNGb2N1c0luc2lkZUZsb2F0aW5nVHJlZSA6IHRydWUpKSB7XG4gICAgICAgIGVucXVldWVGb2N1cyhyZXR1cm5FbGVtZW50LCB7XG4gICAgICAgICAgLy8gV2hlbiBkaXNtaXNzaW5nIG5lc3RlZCBmbG9hdGluZyBlbGVtZW50cywgYnkgdGhlIHRpbWUgdGhlIHJBRiBoYXNcbiAgICAgICAgICAvLyBleGVjdXRlZCwgdGhlIG1lbnVzIHdpbGwgYWxsIGhhdmUgYmVlbiB1bm1vdW50ZWQuIFdoZW4gdGhleSB0cnlcbiAgICAgICAgICAvLyB0byBnZXQgZm9jdXNlZCwgdGhlIGNhbGxzIGdldCBpZ25vcmVkIOKAlCBsZWF2aW5nIHRoZSByb290XG4gICAgICAgICAgLy8gcmVmZXJlbmNlIGZvY3VzZWQgYXMgZGVzaXJlZC5cbiAgICAgICAgICBjYW5jZWxQcmV2aW91czogZmFsc2UsXG4gICAgICAgICAgcHJldmVudFNjcm9sbDogcHJldmVudFJldHVybkZvY3VzU2Nyb2xsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtkaXNhYmxlZCwgZmxvYXRpbmcsIHJldHVybkZvY3VzUmVmLCBkYXRhUmVmLCByZWZzLCBldmVudHMsIHRyZWUsIG5vZGVJZF0pO1xuXG4gIC8vIFN5bmNocm9uaXplIHRoZSBgY29udGV4dGAgJiBgbW9kYWxgIHZhbHVlIHRvIHRoZSBGbG9hdGluZ1BvcnRhbCBjb250ZXh0LlxuICAvLyBJdCB3aWxsIGRlY2lkZSB3aGV0aGVyIG9yIG5vdCBpdCBuZWVkcyB0byByZW5kZXIgaXRzIG93biBndWFyZHMuXG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIXBvcnRhbENvbnRleHQpIHJldHVybjtcbiAgICBwb3J0YWxDb250ZXh0LnNldEZvY3VzTWFuYWdlclN0YXRlKHtcbiAgICAgIG1vZGFsLFxuICAgICAgY2xvc2VPbkZvY3VzT3V0LFxuICAgICAgb3BlbixcbiAgICAgIG9uT3BlbkNoYW5nZSxcbiAgICAgIHJlZnNcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcG9ydGFsQ29udGV4dC5zZXRGb2N1c01hbmFnZXJTdGF0ZShudWxsKTtcbiAgICB9O1xuICB9LCBbZGlzYWJsZWQsIHBvcnRhbENvbnRleHQsIG1vZGFsLCBvcGVuLCBvbk9wZW5DaGFuZ2UsIHJlZnMsIGNsb3NlT25Gb2N1c091dF0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8ICFmbG9hdGluZyB8fCB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ2Z1bmN0aW9uJyB8fCBpZ25vcmVJbml0aWFsRm9jdXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlTXV0YXRpb24gPSAoKSA9PiB7XG4gICAgICBjb25zdCB0YWJJbmRleCA9IGZsb2F0aW5nLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgIGlmIChvcmRlclJlZi5jdXJyZW50LmluY2x1ZGVzKCdmbG9hdGluZycpIHx8IGFjdGl2ZUVsZW1lbnQoZ2V0RG9jdW1lbnQoZmxvYXRpbmcpKSAhPT0gcmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCAmJiBnZXRUYWJiYWJsZUNvbnRlbnQoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKHRhYkluZGV4ICE9PSAnMCcpIHtcbiAgICAgICAgICBmbG9hdGluZy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzAnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YWJJbmRleCAhPT0gJy0xJykge1xuICAgICAgICBmbG9hdGluZy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBoYW5kbGVNdXRhdGlvbigpO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoaGFuZGxlTXV0YXRpb24pO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZmxvYXRpbmcsIHtcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICBhdHRyaWJ1dGVzOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICB9LCBbZGlzYWJsZWQsIGZsb2F0aW5nLCByZWZzLCBvcmRlclJlZiwgZ2V0VGFiYmFibGVDb250ZW50LCBpZ25vcmVJbml0aWFsRm9jdXNdKTtcbiAgZnVuY3Rpb24gcmVuZGVyRGlzbWlzc0J1dHRvbihsb2NhdGlvbikge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhdmlzdWFsbHlIaWRkZW5EaXNtaXNzIHx8ICFtb2RhbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChWaXN1YWxseUhpZGRlbkRpc21pc3MsIHtcbiAgICAgIHJlZjogbG9jYXRpb24gPT09ICdzdGFydCcgPyBzdGFydERpc21pc3NCdXR0b25SZWYgOiBlbmREaXNtaXNzQnV0dG9uUmVmLFxuICAgICAgb25DbGljazogZXZlbnQgPT4gb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudClcbiAgICB9LCB0eXBlb2YgdmlzdWFsbHlIaWRkZW5EaXNtaXNzID09PSAnc3RyaW5nJyA/IHZpc3VhbGx5SGlkZGVuRGlzbWlzcyA6ICdEaXNtaXNzJyk7XG4gIH1cbiAgY29uc3Qgc2hvdWxkUmVuZGVyR3VhcmRzID0gIWRpc2FibGVkICYmIGd1YXJkcyAmJiAoaXNJbnNpZGVQb3J0YWwgfHwgbW9kYWwpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIHNob3VsZFJlbmRlckd1YXJkcyAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb2N1c0d1YXJkLCB7XG4gICAgXCJkYXRhLXR5cGVcIjogXCJpbnNpZGVcIixcbiAgICByZWY6IHBvcnRhbENvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHBvcnRhbENvbnRleHQuYmVmb3JlSW5zaWRlUmVmLFxuICAgIG9uRm9jdXM6IGV2ZW50ID0+IHtcbiAgICAgIGlmIChtb2RhbCkge1xuICAgICAgICBjb25zdCBlbHMgPSBnZXRUYWJiYWJsZUVsZW1lbnRzKCk7XG4gICAgICAgIGVucXVldWVGb2N1cyhvcmRlclswXSA9PT0gJ3JlZmVyZW5jZScgPyBlbHNbMF0gOiBlbHNbZWxzLmxlbmd0aCAtIDFdKTtcbiAgICAgIH0gZWxzZSBpZiAocG9ydGFsQ29udGV4dCAhPSBudWxsICYmIHBvcnRhbENvbnRleHQucHJlc2VydmVUYWJPcmRlciAmJiBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpIHtcbiAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgbmV4dFRhYmJhYmxlID0gZ2V0TmV4dFRhYmJhYmxlKCkgfHwgZG9tUmVmZXJlbmNlO1xuICAgICAgICAgIG5leHRUYWJiYWJsZSA9PSBudWxsIHx8IG5leHRUYWJiYWJsZS5mb2N1cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfcG9ydGFsQ29udGV4dCRiZWZvcmU7XG4gICAgICAgICAgKF9wb3J0YWxDb250ZXh0JGJlZm9yZSA9IHBvcnRhbENvbnRleHQuYmVmb3JlT3V0c2lkZVJlZi5jdXJyZW50KSA9PSBudWxsIHx8IF9wb3J0YWxDb250ZXh0JGJlZm9yZS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KSwgIWlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCAmJiByZW5kZXJEaXNtaXNzQnV0dG9uKCdzdGFydCcpLCBjaGlsZHJlbiwgcmVuZGVyRGlzbWlzc0J1dHRvbignZW5kJyksIHNob3VsZFJlbmRlckd1YXJkcyAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb2N1c0d1YXJkLCB7XG4gICAgXCJkYXRhLXR5cGVcIjogXCJpbnNpZGVcIixcbiAgICByZWY6IHBvcnRhbENvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHBvcnRhbENvbnRleHQuYWZ0ZXJJbnNpZGVSZWYsXG4gICAgb25Gb2N1czogZXZlbnQgPT4ge1xuICAgICAgaWYgKG1vZGFsKSB7XG4gICAgICAgIGVucXVldWVGb2N1cyhnZXRUYWJiYWJsZUVsZW1lbnRzKClbMF0pO1xuICAgICAgfSBlbHNlIGlmIChwb3J0YWxDb250ZXh0ICE9IG51bGwgJiYgcG9ydGFsQ29udGV4dC5wcmVzZXJ2ZVRhYk9yZGVyICYmIHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkge1xuICAgICAgICBpZiAoY2xvc2VPbkZvY3VzT3V0KSB7XG4gICAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc091dHNpZGVFdmVudChldmVudCwgcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlKSkge1xuICAgICAgICAgIGNvbnN0IHByZXZUYWJiYWJsZSA9IGdldFByZXZpb3VzVGFiYmFibGUoKSB8fCBkb21SZWZlcmVuY2U7XG4gICAgICAgICAgcHJldlRhYmJhYmxlID09IG51bGwgfHwgcHJldlRhYmJhYmxlLmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9wb3J0YWxDb250ZXh0JGFmdGVyTztcbiAgICAgICAgICAoX3BvcnRhbENvbnRleHQkYWZ0ZXJPID0gcG9ydGFsQ29udGV4dC5hZnRlck91dHNpZGVSZWYuY3VycmVudCkgPT0gbnVsbCB8fCBfcG9ydGFsQ29udGV4dCRhZnRlck8uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSkpO1xufVxuXG5jb25zdCBhY3RpdmVMb2NrcyA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KCk7XG5cbi8qKlxuICogUHJvdmlkZXMgYmFzZSBzdHlsaW5nIGZvciBhIGZpeGVkIG92ZXJsYXkgZWxlbWVudCB0byBkaW0gY29udGVudCBvciBibG9ja1xuICogcG9pbnRlciBldmVudHMgYmVoaW5kIGEgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEl0J3MgYSByZWd1bGFyIGA8ZGl2PmAsIHNvIGl0IGNhbiBiZSBzdHlsZWQgdmlhIGFueSBDU1Mgc29sdXRpb24geW91IHByZWZlci5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ092ZXJsYXlcbiAqL1xuY29uc3QgRmxvYXRpbmdPdmVybGF5ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gRmxvYXRpbmdPdmVybGF5KF9yZWYsIHJlZikge1xuICBsZXQge1xuICAgIGxvY2tTY3JvbGwgPSBmYWxzZSxcbiAgICAuLi5yZXN0XG4gIH0gPSBfcmVmO1xuICBjb25zdCBsb2NrSWQgPSB1c2VJZCgpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFsb2NrU2Nyb2xsKSByZXR1cm47XG4gICAgYWN0aXZlTG9ja3MuYWRkKGxvY2tJZCk7XG4gICAgY29uc3QgaXNJT1MgPSAvaVAoaG9uZXxhZHxvZCl8aU9TLy50ZXN0KGdldFBsYXRmb3JtKCkpO1xuICAgIGNvbnN0IGJvZHlTdHlsZSA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG4gICAgLy8gUlRMIDxib2R5PiBzY3JvbGxiYXJcbiAgICBjb25zdCBzY3JvbGxiYXJYID0gTWF0aC5yb3VuZChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCkgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICBjb25zdCBwYWRkaW5nUHJvcCA9IHNjcm9sbGJhclggPyAncGFkZGluZ0xlZnQnIDogJ3BhZGRpbmdSaWdodCc7XG4gICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICBjb25zdCBzY3JvbGxYID0gYm9keVN0eWxlLmxlZnQgPyBwYXJzZUZsb2F0KGJvZHlTdHlsZS5sZWZ0KSA6IHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICBjb25zdCBzY3JvbGxZID0gYm9keVN0eWxlLnRvcCA/IHBhcnNlRmxvYXQoYm9keVN0eWxlLnRvcCkgOiB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgYm9keVN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgaWYgKHNjcm9sbGJhcldpZHRoKSB7XG4gICAgICBib2R5U3R5bGVbcGFkZGluZ1Byb3BdID0gc2Nyb2xsYmFyV2lkdGggKyBcInB4XCI7XG4gICAgfVxuXG4gICAgLy8gT25seSBpT1MgZG9lc24ndCByZXNwZWN0IGBvdmVyZmxvdzogaGlkZGVuYCBvbiBkb2N1bWVudC5ib2R5LCBhbmQgdGhpc1xuICAgIC8vIHRlY2huaXF1ZSBoYXMgZmV3ZXIgc2lkZSBlZmZlY3RzLlxuICAgIGlmIChpc0lPUykge1xuICAgICAgdmFyIF93aW5kb3ckdmlzdWFsVmlld3BvciwgX3dpbmRvdyR2aXN1YWxWaWV3cG9yMjtcbiAgICAgIC8vIGlPUyAxMiBkb2VzIG5vdCBzdXBwb3J0IGB2aXN1YWxWaWV3cG9ydGAuXG4gICAgICBjb25zdCBvZmZzZXRMZWZ0ID0gKChfd2luZG93JHZpc3VhbFZpZXdwb3IgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfd2luZG93JHZpc3VhbFZpZXdwb3Iub2Zmc2V0TGVmdCkgfHwgMDtcbiAgICAgIGNvbnN0IG9mZnNldFRvcCA9ICgoX3dpbmRvdyR2aXN1YWxWaWV3cG9yMiA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckdmlzdWFsVmlld3BvcjIub2Zmc2V0VG9wKSB8fCAwO1xuICAgICAgT2JqZWN0LmFzc2lnbihib2R5U3R5bGUsIHtcbiAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgIHRvcDogLShzY3JvbGxZIC0gTWF0aC5mbG9vcihvZmZzZXRUb3ApKSArIFwicHhcIixcbiAgICAgICAgbGVmdDogLShzY3JvbGxYIC0gTWF0aC5mbG9vcihvZmZzZXRMZWZ0KSkgKyBcInB4XCIsXG4gICAgICAgIHJpZ2h0OiAnMCdcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgYWN0aXZlTG9ja3MuZGVsZXRlKGxvY2tJZCk7XG4gICAgICBpZiAoYWN0aXZlTG9ja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKGJvZHlTdHlsZSwge1xuICAgICAgICAgIG92ZXJmbG93OiAnJyxcbiAgICAgICAgICBbcGFkZGluZ1Byb3BdOiAnJ1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzSU9TKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihib2R5U3R5bGUsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnJyxcbiAgICAgICAgICAgIHRvcDogJycsXG4gICAgICAgICAgICBsZWZ0OiAnJyxcbiAgICAgICAgICAgIHJpZ2h0OiAnJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyhzY3JvbGxYLCBzY3JvbGxZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtsb2NrSWQsIGxvY2tTY3JvbGxdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICByZWY6IHJlZlxuICB9LCByZXN0LCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgb3ZlcmZsb3c6ICdhdXRvJyxcbiAgICAgIHRvcDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIC4uLnJlc3Quc3R5bGVcbiAgICB9XG4gIH0pKTtcbn0pO1xuXG5mdW5jdGlvbiBpc0J1dHRvblRhcmdldChldmVudCkge1xuICByZXR1cm4gaXNIVE1MRWxlbWVudChldmVudC50YXJnZXQpICYmIGV2ZW50LnRhcmdldC50YWdOYW1lID09PSAnQlVUVE9OJztcbn1cbmZ1bmN0aW9uIGlzU3BhY2VJZ25vcmVkKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGlzVHlwZWFibGVFbGVtZW50KGVsZW1lbnQpO1xufVxuLyoqXG4gKiBPcGVucyBvciBjbG9zZXMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hlbiBjbGlja2luZyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlQ2xpY2tcbiAqL1xuZnVuY3Rpb24gdXNlQ2xpY2soY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBkYXRhUmVmLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBkb21SZWZlcmVuY2VcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgZXZlbnQ6IGV2ZW50T3B0aW9uID0gJ2NsaWNrJyxcbiAgICB0b2dnbGUgPSB0cnVlLFxuICAgIGlnbm9yZU1vdXNlID0gZmFsc2UsXG4gICAga2V5Ym9hcmRIYW5kbGVycyA9IHRydWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCBwb2ludGVyVHlwZVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBkaWRLZXlEb3duUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuIHt9O1xuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgb25Qb2ludGVyRG93bihldmVudCkge1xuICAgICAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgYWxsIGJ1dHRvbnMgZXhjZXB0IGZvciB0aGUgXCJtYWluXCIgYnV0dG9uLlxuICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50L2J1dHRvblxuICAgICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzTW91c2VMaWtlUG9pbnRlclR5cGUocG9pbnRlclR5cGVSZWYuY3VycmVudCwgdHJ1ZSkgJiYgaWdub3JlTW91c2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV2ZW50T3B0aW9uID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcGVuICYmIHRvZ2dsZSAmJiAoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA/IGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgOiB0cnVlKSkge1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgc3RlYWxpbmcgZm9jdXMgZnJvbSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKGV2ZW50T3B0aW9uID09PSAnbW91c2Vkb3duJyAmJiBwb2ludGVyVHlwZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZVJlZi5jdXJyZW50LCB0cnVlKSAmJiBpZ25vcmVNb3VzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3BlbiAmJiB0b2dnbGUgJiYgKGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgPyBkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50LnR5cGUgPT09ICdjbGljaycgOiB0cnVlKSkge1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbktleURvd24oZXZlbnQpIHtcbiAgICAgICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkIHx8ICFrZXlib2FyZEhhbmRsZXJzIHx8IGlzQnV0dG9uVGFyZ2V0KGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcgJiYgIWlzU3BhY2VJZ25vcmVkKGRvbVJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgc2Nyb2xsaW5nXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZGlkS2V5RG93blJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgaWYgKG9wZW4gJiYgdG9nZ2xlKSB7XG4gICAgICAgICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdjbGljaycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uS2V5VXAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCB8fCAha2V5Ym9hcmRIYW5kbGVycyB8fCBpc0J1dHRvblRhcmdldChldmVudCkgfHwgaXNTcGFjZUlnbm9yZWQoZG9tUmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcgJiYgZGlkS2V5RG93blJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBkaWRLZXlEb3duUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChvcGVuICYmIHRvZ2dsZSkge1xuICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIGRhdGFSZWYsIGV2ZW50T3B0aW9uLCBpZ25vcmVNb3VzZSwga2V5Ym9hcmRIYW5kbGVycywgZG9tUmVmZXJlbmNlLCB0b2dnbGUsIG9wZW4sIG9uT3BlbkNoYW5nZV0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVWaXJ0dWFsRWxlbWVudChkb21SZWYsIGRhdGEpIHtcbiAgbGV0IG9mZnNldFggPSBudWxsO1xuICBsZXQgb2Zmc2V0WSA9IG51bGw7XG4gIGxldCBpc0F1dG9VcGRhdGVFdmVudCA9IGZhbHNlO1xuICByZXR1cm4ge1xuICAgIGNvbnRleHRFbGVtZW50OiBkb21SZWYuY3VycmVudCB8fCB1bmRlZmluZWQsXG4gICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xuICAgICAgdmFyIF9kb21SZWYkY3VycmVudCwgX2RhdGEkZGF0YVJlZiRjdXJyZW50O1xuICAgICAgY29uc3QgZG9tUmVjdCA9ICgoX2RvbVJlZiRjdXJyZW50ID0gZG9tUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZG9tUmVmJGN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpIHx8IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzWEF4aXMgPSBkYXRhLmF4aXMgPT09ICd4JyB8fCBkYXRhLmF4aXMgPT09ICdib3RoJztcbiAgICAgIGNvbnN0IGlzWUF4aXMgPSBkYXRhLmF4aXMgPT09ICd5JyB8fCBkYXRhLmF4aXMgPT09ICdib3RoJztcbiAgICAgIGNvbnN0IGNhblRyYWNrQ3Vyc29yT25BdXRvVXBkYXRlID0gWydtb3VzZWVudGVyJywgJ21vdXNlbW92ZSddLmluY2x1ZGVzKCgoX2RhdGEkZGF0YVJlZiRjdXJyZW50ID0gZGF0YS5kYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkZGF0YVJlZiRjdXJyZW50LnR5cGUpIHx8ICcnKSAmJiBkYXRhLnBvaW50ZXJUeXBlICE9PSAndG91Y2gnO1xuICAgICAgbGV0IHdpZHRoID0gZG9tUmVjdC53aWR0aDtcbiAgICAgIGxldCBoZWlnaHQgPSBkb21SZWN0LmhlaWdodDtcbiAgICAgIGxldCB4ID0gZG9tUmVjdC54O1xuICAgICAgbGV0IHkgPSBkb21SZWN0Lnk7XG4gICAgICBpZiAob2Zmc2V0WCA9PSBudWxsICYmIGRhdGEueCAmJiBpc1hBeGlzKSB7XG4gICAgICAgIG9mZnNldFggPSBkb21SZWN0LnggLSBkYXRhLng7XG4gICAgICB9XG4gICAgICBpZiAob2Zmc2V0WSA9PSBudWxsICYmIGRhdGEueSAmJiBpc1lBeGlzKSB7XG4gICAgICAgIG9mZnNldFkgPSBkb21SZWN0LnkgLSBkYXRhLnk7XG4gICAgICB9XG4gICAgICB4IC09IG9mZnNldFggfHwgMDtcbiAgICAgIHkgLT0gb2Zmc2V0WSB8fCAwO1xuICAgICAgd2lkdGggPSAwO1xuICAgICAgaGVpZ2h0ID0gMDtcbiAgICAgIGlmICghaXNBdXRvVXBkYXRlRXZlbnQgfHwgY2FuVHJhY2tDdXJzb3JPbkF1dG9VcGRhdGUpIHtcbiAgICAgICAgd2lkdGggPSBkYXRhLmF4aXMgPT09ICd5JyA/IGRvbVJlY3Qud2lkdGggOiAwO1xuICAgICAgICBoZWlnaHQgPSBkYXRhLmF4aXMgPT09ICd4JyA/IGRvbVJlY3QuaGVpZ2h0IDogMDtcbiAgICAgICAgeCA9IGlzWEF4aXMgJiYgZGF0YS54ICE9IG51bGwgPyBkYXRhLnggOiB4O1xuICAgICAgICB5ID0gaXNZQXhpcyAmJiBkYXRhLnkgIT0gbnVsbCA/IGRhdGEueSA6IHk7XG4gICAgICB9IGVsc2UgaWYgKGlzQXV0b1VwZGF0ZUV2ZW50ICYmICFjYW5UcmFja0N1cnNvck9uQXV0b1VwZGF0ZSkge1xuICAgICAgICBoZWlnaHQgPSBkYXRhLmF4aXMgPT09ICd4JyA/IGRvbVJlY3QuaGVpZ2h0IDogaGVpZ2h0O1xuICAgICAgICB3aWR0aCA9IGRhdGEuYXhpcyA9PT0gJ3knID8gZG9tUmVjdC53aWR0aCA6IHdpZHRoO1xuICAgICAgfVxuICAgICAgaXNBdXRvVXBkYXRlRXZlbnQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgdG9wOiB5LFxuICAgICAgICByaWdodDogeCArIHdpZHRoLFxuICAgICAgICBib3R0b206IHkgKyBoZWlnaHQsXG4gICAgICAgIGxlZnQ6IHhcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaXNNb3VzZUJhc2VkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50ICE9IG51bGwgJiYgZXZlbnQuY2xpZW50WCAhPSBudWxsO1xufVxuLyoqXG4gKiBQb3NpdGlvbnMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgcmVsYXRpdmUgdG8gYSBjbGllbnQgcG9pbnQgKGluIHRoZSB2aWV3cG9ydCksXG4gKiBzdWNoIGFzIHRoZSBtb3VzZSBwb3NpdGlvbi4gQnkgZGVmYXVsdCwgaXQgZm9sbG93cyB0aGUgbW91c2UgY3Vyc29yLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUNsaWVudFBvaW50XG4gKi9cbmZ1bmN0aW9uIHVzZUNsaWVudFBvaW50KGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICByZWZzLFxuICAgIGRhdGFSZWYsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGZsb2F0aW5nXG4gICAgfVxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGF4aXMgPSAnYm90aCcsXG4gICAgeCA9IG51bGwsXG4gICAgeSA9IG51bGxcbiAgfSA9IHByb3BzO1xuICBjb25zdCBpbml0aWFsUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgY2xlYW51cExpc3RlbmVyUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBbcG9pbnRlclR5cGUsIHNldFBvaW50ZXJUeXBlXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIGNvbnN0IFtyZWFjdGl2ZSwgc2V0UmVhY3RpdmVdID0gUmVhY3QudXNlU3RhdGUoW10pO1xuICBjb25zdCBzZXRSZWZlcmVuY2UgPSB1c2VFZmZlY3RFdmVudCgoeCwgeSkgPT4ge1xuICAgIGlmIChpbml0aWFsUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgIC8vIFByZXZlbnQgc2V0dGluZyBpZiB0aGUgb3BlbiBldmVudCB3YXMgbm90IGEgbW91c2UtbGlrZSBvbmVcbiAgICAvLyAoZS5nLiBmb2N1cyB0byBvcGVuLCB0aGVuIGhvdmVyIG92ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50KS5cbiAgICAvLyBPbmx5IGFwcGx5IGlmIHRoZSBldmVudCBleGlzdHMuXG4gICAgaWYgKGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgJiYgIWlzTW91c2VCYXNlZEV2ZW50KGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZnMuc2V0UG9zaXRpb25SZWZlcmVuY2UoY3JlYXRlVmlydHVhbEVsZW1lbnQocmVmcy5kb21SZWZlcmVuY2UsIHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgYXhpcyxcbiAgICAgIGRhdGFSZWYsXG4gICAgICBwb2ludGVyVHlwZVxuICAgIH0pKTtcbiAgfSk7XG4gIGNvbnN0IGhhbmRsZVJlZmVyZW5jZUVudGVyT3JNb3ZlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIGlmICh4ICE9IG51bGwgfHwgeSAhPSBudWxsKSByZXR1cm47XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICBzZXRSZWZlcmVuY2UoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgfSBlbHNlIGlmICghY2xlYW51cExpc3RlbmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gY2xlYW51cCwgdGhlcmUncyBubyBsaXN0ZW5lciwgYnV0IHdlIHdhbnQgdG8gZW5zdXJlXG4gICAgICAvLyB3ZSBhZGQgdGhlIGxpc3RlbmVyIGlmIHRoZSBjdXJzb3IgbGFuZGVkIG9uIHRoZSBmbG9hdGluZyBlbGVtZW50IGFuZFxuICAgICAgLy8gdGhlbiBiYWNrIG9uIHRoZSByZWZlcmVuY2UgKGkuZS4gaXQncyBpbnRlcmFjdGl2ZSkuXG4gICAgICBzZXRSZWFjdGl2ZShbXSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBJZiB0aGUgcG9pbnRlciBpcyBhIG1vdXNlLWxpa2UgcG9pbnRlciwgd2Ugd2FudCB0byBjb250aW51ZSBmb2xsb3dpbmcgdGhlXG4gIC8vIG1vdXNlIGV2ZW4gaWYgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgdHJhbnNpdGlvbmluZyBvdXQuIE9uIHRvdWNoXG4gIC8vIGRldmljZXMsIHRoaXMgaXMgdW5kZXNpcmFibGUgYmVjYXVzZSB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aWxsIG1vdmUgdG9cbiAgLy8gdGhlIGRpc21pc3NhbCB0b3VjaCBwb2ludC5cbiAgY29uc3Qgb3BlbkNoZWNrID0gaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZSkgPyBmbG9hdGluZyA6IG9wZW47XG4gIGNvbnN0IGFkZExpc3RlbmVyID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIC8vIEV4cGxpY2l0bHkgc3BlY2lmaWVkIGB4YC9geWAgY29vcmRpbmF0ZXMgc2hvdWxkbid0IGFkZCBhIGxpc3RlbmVyLlxuICAgIGlmICghb3BlbkNoZWNrIHx8ICFlbmFibGVkIHx8IHggIT0gbnVsbCB8fCB5ICE9IG51bGwpIHJldHVybjtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3cocmVmcy5mbG9hdGluZy5jdXJyZW50KTtcbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChldmVudCk7XG4gICAgICBpZiAoIWNvbnRhaW5zKHJlZnMuZmxvYXRpbmcuY3VycmVudCwgdGFyZ2V0KSkge1xuICAgICAgICBzZXRSZWZlcmVuY2UoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgY2xlYW51cExpc3RlbmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgfHwgaXNNb3VzZUJhc2VkRXZlbnQoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCkpIHtcbiAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICAgIGNsZWFudXBMaXN0ZW5lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBjbGVhbnVwTGlzdGVuZXJSZWYuY3VycmVudCA9IGNsZWFudXA7XG4gICAgICByZXR1cm4gY2xlYW51cDtcbiAgICB9XG4gICAgcmVmcy5zZXRQb3NpdGlvblJlZmVyZW5jZShyZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KTtcbiAgfSwgW2RhdGFSZWYsIGVuYWJsZWQsIG9wZW5DaGVjaywgcmVmcywgc2V0UmVmZXJlbmNlLCB4LCB5XSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGFkZExpc3RlbmVyKCk7XG4gIH0sIFthZGRMaXN0ZW5lciwgcmVhY3RpdmVdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZW5hYmxlZCAmJiAhZmxvYXRpbmcpIHtcbiAgICAgIGluaXRpYWxSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIGZsb2F0aW5nXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkICYmIG9wZW4pIHtcbiAgICAgIGluaXRpYWxSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgb3Blbl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKGVuYWJsZWQgJiYgKHggIT0gbnVsbCB8fCB5ICE9IG51bGwpKSB7XG4gICAgICBpbml0aWFsUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIHNldFJlZmVyZW5jZSh4LCB5KTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCB4LCB5LCBzZXRSZWZlcmVuY2VdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuIHt9O1xuICAgIGZ1bmN0aW9uIHNldFBvaW50ZXJUeXBlUmVmKF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHBvaW50ZXJUeXBlXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHNldFBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICBvblBvaW50ZXJEb3duOiBzZXRQb2ludGVyVHlwZVJlZixcbiAgICAgICAgb25Qb2ludGVyRW50ZXI6IHNldFBvaW50ZXJUeXBlUmVmLFxuICAgICAgICBvbk1vdXNlTW92ZTogaGFuZGxlUmVmZXJlbmNlRW50ZXJPck1vdmUsXG4gICAgICAgIG9uTW91c2VFbnRlcjogaGFuZGxlUmVmZXJlbmNlRW50ZXJPck1vdmVcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgaGFuZGxlUmVmZXJlbmNlRW50ZXJPck1vdmVdKTtcbn1cblxuY29uc3QgYnViYmxlSGFuZGxlcktleXMgPSB7XG4gIHBvaW50ZXJkb3duOiAnb25Qb2ludGVyRG93bicsXG4gIG1vdXNlZG93bjogJ29uTW91c2VEb3duJyxcbiAgY2xpY2s6ICdvbkNsaWNrJ1xufTtcbmNvbnN0IGNhcHR1cmVIYW5kbGVyS2V5cyA9IHtcbiAgcG9pbnRlcmRvd246ICdvblBvaW50ZXJEb3duQ2FwdHVyZScsXG4gIG1vdXNlZG93bjogJ29uTW91c2VEb3duQ2FwdHVyZScsXG4gIGNsaWNrOiAnb25DbGlja0NhcHR1cmUnXG59O1xuY29uc3Qgbm9ybWFsaXplUHJvcCA9IG5vcm1hbGl6YWJsZSA9PiB7XG4gIHZhciBfbm9ybWFsaXphYmxlJGVzY2FwZUssIF9ub3JtYWxpemFibGUkb3V0c2lkZTtcbiAgcmV0dXJuIHtcbiAgICBlc2NhcGVLZXk6IHR5cGVvZiBub3JtYWxpemFibGUgPT09ICdib29sZWFuJyA/IG5vcm1hbGl6YWJsZSA6IChfbm9ybWFsaXphYmxlJGVzY2FwZUsgPSBub3JtYWxpemFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vcm1hbGl6YWJsZS5lc2NhcGVLZXkpICE9IG51bGwgPyBfbm9ybWFsaXphYmxlJGVzY2FwZUsgOiBmYWxzZSxcbiAgICBvdXRzaWRlUHJlc3M6IHR5cGVvZiBub3JtYWxpemFibGUgPT09ICdib29sZWFuJyA/IG5vcm1hbGl6YWJsZSA6IChfbm9ybWFsaXphYmxlJG91dHNpZGUgPSBub3JtYWxpemFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vcm1hbGl6YWJsZS5vdXRzaWRlUHJlc3MpICE9IG51bGwgPyBfbm9ybWFsaXphYmxlJG91dHNpZGUgOiB0cnVlXG4gIH07XG59O1xuLyoqXG4gKiBDbG9zZXMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hlbiBhIGRpc21pc3NhbCBpcyByZXF1ZXN0ZWQg4oCUIGJ5IGRlZmF1bHQsIHdoZW5cbiAqIHRoZSB1c2VyIHByZXNzZXMgdGhlIGBlc2NhcGVgIGtleSBvciBvdXRzaWRlIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZURpc21pc3NcbiAqL1xuZnVuY3Rpb24gdXNlRGlzbWlzcyhjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIG5vZGVJZCxcbiAgICBlbGVtZW50czoge1xuICAgICAgcmVmZXJlbmNlLFxuICAgICAgZG9tUmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmdcbiAgICB9LFxuICAgIGRhdGFSZWZcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBlc2NhcGVLZXkgPSB0cnVlLFxuICAgIG91dHNpZGVQcmVzczogdW5zdGFibGVfb3V0c2lkZVByZXNzID0gdHJ1ZSxcbiAgICBvdXRzaWRlUHJlc3NFdmVudCA9ICdwb2ludGVyZG93bicsXG4gICAgcmVmZXJlbmNlUHJlc3MgPSBmYWxzZSxcbiAgICByZWZlcmVuY2VQcmVzc0V2ZW50ID0gJ3BvaW50ZXJkb3duJyxcbiAgICBhbmNlc3RvclNjcm9sbCA9IGZhbHNlLFxuICAgIGJ1YmJsZXMsXG4gICAgY2FwdHVyZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3Qgb3V0c2lkZVByZXNzRm4gPSB1c2VFZmZlY3RFdmVudCh0eXBlb2YgdW5zdGFibGVfb3V0c2lkZVByZXNzID09PSAnZnVuY3Rpb24nID8gdW5zdGFibGVfb3V0c2lkZVByZXNzIDogKCkgPT4gZmFsc2UpO1xuICBjb25zdCBvdXRzaWRlUHJlc3MgPSB0eXBlb2YgdW5zdGFibGVfb3V0c2lkZVByZXNzID09PSAnZnVuY3Rpb24nID8gb3V0c2lkZVByZXNzRm4gOiB1bnN0YWJsZV9vdXRzaWRlUHJlc3M7XG4gIGNvbnN0IGluc2lkZVJlYWN0VHJlZVJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGVuZGVkT3JTdGFydGVkSW5zaWRlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3Qge1xuICAgIGVzY2FwZUtleTogZXNjYXBlS2V5QnViYmxlcyxcbiAgICBvdXRzaWRlUHJlc3M6IG91dHNpZGVQcmVzc0J1YmJsZXNcbiAgfSA9IG5vcm1hbGl6ZVByb3AoYnViYmxlcyk7XG4gIGNvbnN0IHtcbiAgICBlc2NhcGVLZXk6IGVzY2FwZUtleUNhcHR1cmUsXG4gICAgb3V0c2lkZVByZXNzOiBvdXRzaWRlUHJlc3NDYXB0dXJlXG4gIH0gPSBub3JtYWxpemVQcm9wKGNhcHR1cmUpO1xuICBjb25zdCBjbG9zZU9uRXNjYXBlS2V5RG93biA9IHVzZUVmZmVjdEV2ZW50KGV2ZW50ID0+IHtcbiAgICBpZiAoIW9wZW4gfHwgIWVuYWJsZWQgfHwgIWVzY2FwZUtleSB8fCBldmVudC5rZXkgIT09ICdFc2NhcGUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gdHJlZSA/IGdldENoaWxkcmVuKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKSA6IFtdO1xuICAgIGlmICghZXNjYXBlS2V5QnViYmxlcykge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgc2hvdWxkRGlzbWlzcyA9IHRydWU7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgIHZhciBfY2hpbGQkY29udGV4dDtcbiAgICAgICAgICBpZiAoKF9jaGlsZCRjb250ZXh0ID0gY2hpbGQuY29udGV4dCkgIT0gbnVsbCAmJiBfY2hpbGQkY29udGV4dC5vcGVuICYmICFjaGlsZC5jb250ZXh0LmRhdGFSZWYuY3VycmVudC5fX2VzY2FwZUtleUJ1YmJsZXMpIHtcbiAgICAgICAgICAgIHNob3VsZERpc21pc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXNob3VsZERpc21pc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBpc1JlYWN0RXZlbnQoZXZlbnQpID8gZXZlbnQubmF0aXZlRXZlbnQgOiBldmVudCwgJ2VzY2FwZS1rZXknKTtcbiAgfSk7XG4gIGNvbnN0IGNsb3NlT25Fc2NhcGVLZXlEb3duQ2FwdHVyZSA9IHVzZUVmZmVjdEV2ZW50KGV2ZW50ID0+IHtcbiAgICB2YXIgX2dldFRhcmdldDI7XG4gICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICB2YXIgX2dldFRhcmdldDtcbiAgICAgIGNsb3NlT25Fc2NhcGVLZXlEb3duKGV2ZW50KTtcbiAgICAgIChfZ2V0VGFyZ2V0ID0gZ2V0VGFyZ2V0KGV2ZW50KSkgPT0gbnVsbCB8fCBfZ2V0VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAoX2dldFRhcmdldDIgPSBnZXRUYXJnZXQoZXZlbnQpKSA9PSBudWxsIHx8IF9nZXRUYXJnZXQyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjYWxsYmFjayk7XG4gIH0pO1xuICBjb25zdCBjbG9zZU9uUHJlc3NPdXRzaWRlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIC8vIEdpdmVuIGRldmVsb3BlcnMgY2FuIHN0b3AgdGhlIHByb3BhZ2F0aW9uIG9mIHRoZSBzeW50aGV0aWMgZXZlbnQsXG4gICAgLy8gd2UgY2FuIG9ubHkgYmUgY29uZmlkZW50IHdpdGggYSBwb3NpdGl2ZSB2YWx1ZS5cbiAgICBjb25zdCBpbnNpZGVSZWFjdFRyZWUgPSBpbnNpZGVSZWFjdFRyZWVSZWYuY3VycmVudDtcbiAgICBpbnNpZGVSZWFjdFRyZWVSZWYuY3VycmVudCA9IGZhbHNlO1xuXG4gICAgLy8gV2hlbiBjbGljayBvdXRzaWRlIGlzIGxhenkgKGBjbGlja2AgZXZlbnQpLCBoYW5kbGUgZHJhZ2dpbmcuXG4gICAgLy8gRG9uJ3QgY2xvc2UgaWY6XG4gICAgLy8gLSBUaGUgY2xpY2sgc3RhcnRlZCBpbnNpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gICAgLy8gLSBUaGUgY2xpY2sgZW5kZWQgaW5zaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50LlxuICAgIGNvbnN0IGVuZGVkT3JTdGFydGVkSW5zaWRlID0gZW5kZWRPclN0YXJ0ZWRJbnNpZGVSZWYuY3VycmVudDtcbiAgICBlbmRlZE9yU3RhcnRlZEluc2lkZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgaWYgKG91dHNpZGVQcmVzc0V2ZW50ID09PSAnY2xpY2snICYmIGVuZGVkT3JTdGFydGVkSW5zaWRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbnNpZGVSZWFjdFRyZWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvdXRzaWRlUHJlc3MgPT09ICdmdW5jdGlvbicgJiYgIW91dHNpZGVQcmVzcyhldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGV2ZW50KTtcbiAgICBjb25zdCBpbmVydFNlbGVjdG9yID0gXCJbXCIgKyBjcmVhdGVBdHRyaWJ1dGUoJ2luZXJ0JykgKyBcIl1cIjtcbiAgICBjb25zdCBtYXJrZXJzID0gZ2V0RG9jdW1lbnQoZmxvYXRpbmcpLnF1ZXJ5U2VsZWN0b3JBbGwoaW5lcnRTZWxlY3Rvcik7XG4gICAgbGV0IHRhcmdldFJvb3RBbmNlc3RvciA9IGlzRWxlbWVudCh0YXJnZXQpID8gdGFyZ2V0IDogbnVsbDtcbiAgICB3aGlsZSAodGFyZ2V0Um9vdEFuY2VzdG9yICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUodGFyZ2V0Um9vdEFuY2VzdG9yKSkge1xuICAgICAgY29uc3QgbmV4dFBhcmVudCA9IGdldFBhcmVudE5vZGUodGFyZ2V0Um9vdEFuY2VzdG9yKTtcbiAgICAgIGlmIChpc0xhc3RUcmF2ZXJzYWJsZU5vZGUobmV4dFBhcmVudCkgfHwgIWlzRWxlbWVudChuZXh0UGFyZW50KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFJvb3RBbmNlc3RvciA9IG5leHRQYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNsaWNrIG9jY3VycmVkIG9uIGEgdGhpcmQtcGFydHkgZWxlbWVudCBpbmplY3RlZCBhZnRlciB0aGVcbiAgICAvLyBmbG9hdGluZyBlbGVtZW50IHJlbmRlcmVkLlxuICAgIGlmIChtYXJrZXJzLmxlbmd0aCAmJiBpc0VsZW1lbnQodGFyZ2V0KSAmJiAhaXNSb290RWxlbWVudCh0YXJnZXQpICYmXG4gICAgLy8gQ2xpY2tlZCBvbiBhIGRpcmVjdCBhbmNlc3RvciAoZS5nLiBGbG9hdGluZ092ZXJsYXkpLlxuICAgICFjb250YWlucyh0YXJnZXQsIGZsb2F0aW5nKSAmJlxuICAgIC8vIElmIHRoZSB0YXJnZXQgcm9vdCBlbGVtZW50IGNvbnRhaW5zIG5vbmUgb2YgdGhlIG1hcmtlcnMsIHRoZW4gdGhlXG4gICAgLy8gZWxlbWVudCB3YXMgaW5qZWN0ZWQgYWZ0ZXIgdGhlIGZsb2F0aW5nIGVsZW1lbnQgcmVuZGVyZWQuXG4gICAgQXJyYXkuZnJvbShtYXJrZXJzKS5ldmVyeShtYXJrZXIgPT4gIWNvbnRhaW5zKHRhcmdldFJvb3RBbmNlc3RvciwgbWFya2VyKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgY2xpY2sgb2NjdXJyZWQgb24gdGhlIHNjcm9sbGJhclxuICAgIGlmIChpc0hUTUxFbGVtZW50KHRhcmdldCkgJiYgZmxvYXRpbmcpIHtcbiAgICAgIC8vIEluIEZpcmVmb3gsIGB0YXJnZXQuc2Nyb2xsV2lkdGggPiB0YXJnZXQuY2xpZW50V2lkdGhgIGZvciBpbmxpbmVcbiAgICAgIC8vIGVsZW1lbnRzLlxuICAgICAgY29uc3QgY2FuU2Nyb2xsWCA9IHRhcmdldC5jbGllbnRXaWR0aCA+IDAgJiYgdGFyZ2V0LnNjcm9sbFdpZHRoID4gdGFyZ2V0LmNsaWVudFdpZHRoO1xuICAgICAgY29uc3QgY2FuU2Nyb2xsWSA9IHRhcmdldC5jbGllbnRIZWlnaHQgPiAwICYmIHRhcmdldC5zY3JvbGxIZWlnaHQgPiB0YXJnZXQuY2xpZW50SGVpZ2h0O1xuICAgICAgbGV0IHhDb25kID0gY2FuU2Nyb2xsWSAmJiBldmVudC5vZmZzZXRYID4gdGFyZ2V0LmNsaWVudFdpZHRoO1xuXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzIGl0IGlzIHBvc3NpYmxlIHRvIGNoYW5nZSB0aGUgPGJvZHk+IChvciB3aW5kb3cpXG4gICAgICAvLyBzY3JvbGxiYXIgdG8gdGhlIGxlZnQgc2lkZSwgYnV0IGlzIHZlcnkgcmFyZSBhbmQgaXMgZGlmZmljdWx0IHRvXG4gICAgICAvLyBjaGVjayBmb3IuIFBsdXMsIGZvciBtb2RhbCBkaWFsb2dzIHdpdGggYmFja2Ryb3BzLCBpdCBpcyBtb3JlXG4gICAgICAvLyBpbXBvcnRhbnQgdGhhdCB0aGUgYmFja2Ryb3AgaXMgY2hlY2tlZCBidXQgbm90IHNvIG11Y2ggdGhlIHdpbmRvdy5cbiAgICAgIGlmIChjYW5TY3JvbGxZKSB7XG4gICAgICAgIGNvbnN0IGlzUlRMID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG4gICAgICAgIGlmIChpc1JUTCkge1xuICAgICAgICAgIHhDb25kID0gZXZlbnQub2Zmc2V0WCA8PSB0YXJnZXQub2Zmc2V0V2lkdGggLSB0YXJnZXQuY2xpZW50V2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh4Q29uZCB8fCBjYW5TY3JvbGxYICYmIGV2ZW50Lm9mZnNldFkgPiB0YXJnZXQuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0SXNJbnNpZGVDaGlsZHJlbiA9IHRyZWUgJiYgZ2V0Q2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpLnNvbWUobm9kZSA9PiB7XG4gICAgICB2YXIgX25vZGUkY29udGV4dDtcbiAgICAgIHJldHVybiBpc0V2ZW50VGFyZ2V0V2l0aGluKGV2ZW50LCAoX25vZGUkY29udGV4dCA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQuZWxlbWVudHMuZmxvYXRpbmcpO1xuICAgIH0pO1xuICAgIGlmIChpc0V2ZW50VGFyZ2V0V2l0aGluKGV2ZW50LCBmbG9hdGluZykgfHwgaXNFdmVudFRhcmdldFdpdGhpbihldmVudCwgZG9tUmVmZXJlbmNlKSB8fCB0YXJnZXRJc0luc2lkZUNoaWxkcmVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gdHJlZSA/IGdldENoaWxkcmVuKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKSA6IFtdO1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBsZXQgc2hvdWxkRGlzbWlzcyA9IHRydWU7XG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgdmFyIF9jaGlsZCRjb250ZXh0MjtcbiAgICAgICAgaWYgKChfY2hpbGQkY29udGV4dDIgPSBjaGlsZC5jb250ZXh0KSAhPSBudWxsICYmIF9jaGlsZCRjb250ZXh0Mi5vcGVuICYmICFjaGlsZC5jb250ZXh0LmRhdGFSZWYuY3VycmVudC5fX291dHNpZGVQcmVzc0J1YmJsZXMpIHtcbiAgICAgICAgICBzaG91bGREaXNtaXNzID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghc2hvdWxkRGlzbWlzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQsICdvdXRzaWRlLXByZXNzJyk7XG4gIH0pO1xuICBjb25zdCBjbG9zZU9uUHJlc3NPdXRzaWRlQ2FwdHVyZSA9IHVzZUVmZmVjdEV2ZW50KGV2ZW50ID0+IHtcbiAgICB2YXIgX2dldFRhcmdldDQ7XG4gICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICB2YXIgX2dldFRhcmdldDM7XG4gICAgICBjbG9zZU9uUHJlc3NPdXRzaWRlKGV2ZW50KTtcbiAgICAgIChfZ2V0VGFyZ2V0MyA9IGdldFRhcmdldChldmVudCkpID09IG51bGwgfHwgX2dldFRhcmdldDMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvdXRzaWRlUHJlc3NFdmVudCwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgKF9nZXRUYXJnZXQ0ID0gZ2V0VGFyZ2V0KGV2ZW50KSkgPT0gbnVsbCB8fCBfZ2V0VGFyZ2V0NC5hZGRFdmVudExpc3RlbmVyKG91dHNpZGVQcmVzc0V2ZW50LCBjYWxsYmFjayk7XG4gIH0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghb3BlbiB8fCAhZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRhUmVmLmN1cnJlbnQuX19lc2NhcGVLZXlCdWJibGVzID0gZXNjYXBlS2V5QnViYmxlcztcbiAgICBkYXRhUmVmLmN1cnJlbnQuX19vdXRzaWRlUHJlc3NCdWJibGVzID0gb3V0c2lkZVByZXNzQnViYmxlcztcbiAgICBmdW5jdGlvbiBvblNjcm9sbChldmVudCkge1xuICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCwgJ2FuY2VzdG9yLXNjcm9sbCcpO1xuICAgIH1cbiAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudChmbG9hdGluZyk7XG4gICAgZXNjYXBlS2V5ICYmIGRvYy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXNjYXBlS2V5Q2FwdHVyZSA/IGNsb3NlT25Fc2NhcGVLZXlEb3duQ2FwdHVyZSA6IGNsb3NlT25Fc2NhcGVLZXlEb3duLCBlc2NhcGVLZXlDYXB0dXJlKTtcbiAgICBvdXRzaWRlUHJlc3MgJiYgZG9jLmFkZEV2ZW50TGlzdGVuZXIob3V0c2lkZVByZXNzRXZlbnQsIG91dHNpZGVQcmVzc0NhcHR1cmUgPyBjbG9zZU9uUHJlc3NPdXRzaWRlQ2FwdHVyZSA6IGNsb3NlT25QcmVzc091dHNpZGUsIG91dHNpZGVQcmVzc0NhcHR1cmUpO1xuICAgIGxldCBhbmNlc3RvcnMgPSBbXTtcbiAgICBpZiAoYW5jZXN0b3JTY3JvbGwpIHtcbiAgICAgIGlmIChpc0VsZW1lbnQoZG9tUmVmZXJlbmNlKSkge1xuICAgICAgICBhbmNlc3RvcnMgPSBnZXRPdmVyZmxvd0FuY2VzdG9ycyhkb21SZWZlcmVuY2UpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRWxlbWVudChmbG9hdGluZykpIHtcbiAgICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmNvbmNhdChnZXRPdmVyZmxvd0FuY2VzdG9ycyhmbG9hdGluZykpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0VsZW1lbnQocmVmZXJlbmNlKSAmJiByZWZlcmVuY2UgJiYgcmVmZXJlbmNlLmNvbnRleHRFbGVtZW50KSB7XG4gICAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycy5jb25jYXQoZ2V0T3ZlcmZsb3dBbmNlc3RvcnMocmVmZXJlbmNlLmNvbnRleHRFbGVtZW50KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWdub3JlIHRoZSB2aXN1YWwgdmlld3BvcnQgZm9yIHNjcm9sbGluZyBkaXNtaXNzYWwgKGFsbG93IHBpbmNoLXpvb20pXG4gICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmZpbHRlcihhbmNlc3RvciA9PiB7XG4gICAgICB2YXIgX2RvYyRkZWZhdWx0VmlldztcbiAgICAgIHJldHVybiBhbmNlc3RvciAhPT0gKChfZG9jJGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogX2RvYyRkZWZhdWx0Vmlldy52aXN1YWxWaWV3cG9ydCk7XG4gICAgfSk7XG4gICAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgICAgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGVzY2FwZUtleSAmJiBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGVzY2FwZUtleUNhcHR1cmUgPyBjbG9zZU9uRXNjYXBlS2V5RG93bkNhcHR1cmUgOiBjbG9zZU9uRXNjYXBlS2V5RG93biwgZXNjYXBlS2V5Q2FwdHVyZSk7XG4gICAgICBvdXRzaWRlUHJlc3MgJiYgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIob3V0c2lkZVByZXNzRXZlbnQsIG91dHNpZGVQcmVzc0NhcHR1cmUgPyBjbG9zZU9uUHJlc3NPdXRzaWRlQ2FwdHVyZSA6IGNsb3NlT25QcmVzc091dHNpZGUsIG91dHNpZGVQcmVzc0NhcHR1cmUpO1xuICAgICAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgICAgICBhbmNlc3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbZGF0YVJlZiwgZmxvYXRpbmcsIGRvbVJlZmVyZW5jZSwgcmVmZXJlbmNlLCBlc2NhcGVLZXksIG91dHNpZGVQcmVzcywgb3V0c2lkZVByZXNzRXZlbnQsIG9wZW4sIG9uT3BlbkNoYW5nZSwgYW5jZXN0b3JTY3JvbGwsIGVuYWJsZWQsIGVzY2FwZUtleUJ1YmJsZXMsIG91dHNpZGVQcmVzc0J1YmJsZXMsIGNsb3NlT25Fc2NhcGVLZXlEb3duLCBlc2NhcGVLZXlDYXB0dXJlLCBjbG9zZU9uRXNjYXBlS2V5RG93bkNhcHR1cmUsIGNsb3NlT25QcmVzc091dHNpZGUsIG91dHNpZGVQcmVzc0NhcHR1cmUsIGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaW5zaWRlUmVhY3RUcmVlUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgfSwgW291dHNpZGVQcmVzcywgb3V0c2lkZVByZXNzRXZlbnRdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgIG9uS2V5RG93bjogY2xvc2VPbkVzY2FwZUtleURvd24sXG4gICAgICAgIFtidWJibGVIYW5kbGVyS2V5c1tyZWZlcmVuY2VQcmVzc0V2ZW50XV06IGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAocmVmZXJlbmNlUHJlc3MpIHtcbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdyZWZlcmVuY2UtcHJlc3MnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmbG9hdGluZzoge1xuICAgICAgICBvbktleURvd246IGNsb3NlT25Fc2NhcGVLZXlEb3duLFxuICAgICAgICBvbk1vdXNlRG93bigpIHtcbiAgICAgICAgICBlbmRlZE9yU3RhcnRlZEluc2lkZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZVVwKCkge1xuICAgICAgICAgIGVuZGVkT3JTdGFydGVkSW5zaWRlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBbY2FwdHVyZUhhbmRsZXJLZXlzW291dHNpZGVQcmVzc0V2ZW50XV06ICgpID0+IHtcbiAgICAgICAgICBpbnNpZGVSZWFjdFRyZWVSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgcmVmZXJlbmNlUHJlc3MsIG91dHNpZGVQcmVzc0V2ZW50LCByZWZlcmVuY2VQcmVzc0V2ZW50LCBvbk9wZW5DaGFuZ2UsIGNsb3NlT25Fc2NhcGVLZXlEb3duXSk7XG59XG5cbmxldCBkZXZNZXNzYWdlU2V0O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBkZXZNZXNzYWdlU2V0ID0gLyojX19QVVJFX18qL25ldyBTZXQoKTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGEgZmxvYXRpbmcgZWxlbWVudCBhbmQgY29udGV4dCB0byBhZGQgaW50ZXJhY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUZsb2F0aW5nXG4gKi9cbmZ1bmN0aW9uIHVzZUZsb2F0aW5nKG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnRzMjtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbiA9IGZhbHNlLFxuICAgIG9uT3BlbkNoYW5nZTogdW5zdGFibGVfb25PcGVuQ2hhbmdlLFxuICAgIG5vZGVJZFxuICB9ID0gb3B0aW9ucztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhciBfb3B0aW9ucyRlbGVtZW50cztcbiAgICBjb25zdCBlcnIgPSAnRmxvYXRpbmcgVUk6IENhbm5vdCBwYXNzIGEgdmlydHVhbCBlbGVtZW50IHRvIHRoZSAnICsgJ2BlbGVtZW50cy5yZWZlcmVuY2VgIG9wdGlvbiwgYXMgaXQgbXVzdCBiZSBhIHJlYWwgRE9NIGVsZW1lbnQuICcgKyAnVXNlIGByZWZzLnNldFBvc2l0aW9uUmVmZXJlbmNlYCBpbnN0ZWFkLic7XG4gICAgaWYgKChfb3B0aW9ucyRlbGVtZW50cyA9IG9wdGlvbnMuZWxlbWVudHMpICE9IG51bGwgJiYgX29wdGlvbnMkZWxlbWVudHMucmVmZXJlbmNlICYmICFpc0VsZW1lbnQob3B0aW9ucy5lbGVtZW50cy5yZWZlcmVuY2UpKSB7XG4gICAgICB2YXIgX2Rldk1lc3NhZ2VTZXQ7XG4gICAgICBpZiAoISgoX2Rldk1lc3NhZ2VTZXQgPSBkZXZNZXNzYWdlU2V0KSAhPSBudWxsICYmIF9kZXZNZXNzYWdlU2V0LmhhcyhlcnIpKSkge1xuICAgICAgICB2YXIgX2Rldk1lc3NhZ2VTZXQyO1xuICAgICAgICAoX2Rldk1lc3NhZ2VTZXQyID0gZGV2TWVzc2FnZVNldCkgPT0gbnVsbCB8fCBfZGV2TWVzc2FnZVNldDIuYWRkKGVycik7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgW19kb21SZWZlcmVuY2UsIHNldERvbVJlZmVyZW5jZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgZG9tUmVmZXJlbmNlID0gKChfb3B0aW9ucyRlbGVtZW50czIgPSBvcHRpb25zLmVsZW1lbnRzKSA9PSBudWxsID8gdm9pZCAwIDogX29wdGlvbnMkZWxlbWVudHMyLnJlZmVyZW5jZSkgfHwgX2RvbVJlZmVyZW5jZTtcbiAgY29uc3QgcG9zaXRpb24gPSB1c2VGbG9hdGluZyQxKG9wdGlvbnMpO1xuICBjb25zdCB0cmVlID0gdXNlRmxvYXRpbmdUcmVlKCk7XG4gIGNvbnN0IG5lc3RlZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCkgIT0gbnVsbDtcbiAgY29uc3Qgb25PcGVuQ2hhbmdlID0gdXNlRWZmZWN0RXZlbnQoKG9wZW4sIGV2ZW50LCByZWFzb24pID0+IHtcbiAgICBpZiAob3Blbikge1xuICAgICAgZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA9IGV2ZW50O1xuICAgIH1cbiAgICBldmVudHMuZW1pdCgnb3BlbmNoYW5nZScsIHtcbiAgICAgIG9wZW4sXG4gICAgICBldmVudCxcbiAgICAgIHJlYXNvbixcbiAgICAgIG5lc3RlZFxuICAgIH0pO1xuICAgIHVuc3RhYmxlX29uT3BlbkNoYW5nZSA9PSBudWxsIHx8IHVuc3RhYmxlX29uT3BlbkNoYW5nZShvcGVuLCBldmVudCwgcmVhc29uKTtcbiAgfSk7XG4gIGNvbnN0IGRvbVJlZmVyZW5jZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZGF0YVJlZiA9IFJlYWN0LnVzZVJlZih7fSk7XG4gIGNvbnN0IGV2ZW50cyA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGNyZWF0ZVB1YlN1YigpKVswXTtcbiAgY29uc3QgZmxvYXRpbmdJZCA9IHVzZUlkKCk7XG4gIGNvbnN0IHNldFBvc2l0aW9uUmVmZXJlbmNlID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgY29uc3QgcG9zaXRpb25SZWZlcmVuY2UgPSBpc0VsZW1lbnQobm9kZSkgPyB7XG4gICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6ICgpID0+IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBjb250ZXh0RWxlbWVudDogbm9kZVxuICAgIH0gOiBub2RlO1xuICAgIHBvc2l0aW9uLnJlZnMuc2V0UmVmZXJlbmNlKHBvc2l0aW9uUmVmZXJlbmNlKTtcbiAgfSwgW3Bvc2l0aW9uLnJlZnNdKTtcbiAgY29uc3Qgc2V0UmVmZXJlbmNlID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgaWYgKGlzRWxlbWVudChub2RlKSB8fCBub2RlID09PSBudWxsKSB7XG4gICAgICBkb21SZWZlcmVuY2VSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICBzZXREb21SZWZlcmVuY2Uobm9kZSk7XG4gICAgfVxuXG4gICAgLy8gQmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHBhc3NpbmcgYSB2aXJ0dWFsIGVsZW1lbnQgdG8gYHJlZmVyZW5jZWBcbiAgICAvLyBhZnRlciBpdCBoYXMgc2V0IHRoZSBET00gcmVmZXJlbmNlLlxuICAgIGlmIChpc0VsZW1lbnQocG9zaXRpb24ucmVmcy5yZWZlcmVuY2UuY3VycmVudCkgfHwgcG9zaXRpb24ucmVmcy5yZWZlcmVuY2UuY3VycmVudCA9PT0gbnVsbCB8fFxuICAgIC8vIERvbid0IGFsbG93IHNldHRpbmcgdmlydHVhbCBlbGVtZW50cyB1c2luZyB0aGUgb2xkIHRlY2huaXF1ZSBiYWNrIHRvXG4gICAgLy8gYG51bGxgIHRvIHN1cHBvcnQgYHBvc2l0aW9uUmVmZXJlbmNlYCArIGFuIHVuc3RhYmxlIGByZWZlcmVuY2VgXG4gICAgLy8gY2FsbGJhY2sgcmVmLlxuICAgIG5vZGUgIT09IG51bGwgJiYgIWlzRWxlbWVudChub2RlKSkge1xuICAgICAgcG9zaXRpb24ucmVmcy5zZXRSZWZlcmVuY2Uobm9kZSk7XG4gICAgfVxuICB9LCBbcG9zaXRpb24ucmVmc10pO1xuICBjb25zdCByZWZzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLnBvc2l0aW9uLnJlZnMsXG4gICAgc2V0UmVmZXJlbmNlLFxuICAgIHNldFBvc2l0aW9uUmVmZXJlbmNlLFxuICAgIGRvbVJlZmVyZW5jZTogZG9tUmVmZXJlbmNlUmVmXG4gIH0pLCBbcG9zaXRpb24ucmVmcywgc2V0UmVmZXJlbmNlLCBzZXRQb3NpdGlvblJlZmVyZW5jZV0pO1xuICBjb25zdCBlbGVtZW50cyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5wb3NpdGlvbi5lbGVtZW50cyxcbiAgICBkb21SZWZlcmVuY2U6IGRvbVJlZmVyZW5jZVxuICB9KSwgW3Bvc2l0aW9uLmVsZW1lbnRzLCBkb21SZWZlcmVuY2VdKTtcbiAgY29uc3QgY29udGV4dCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5wb3NpdGlvbixcbiAgICByZWZzLFxuICAgIGVsZW1lbnRzLFxuICAgIGRhdGFSZWYsXG4gICAgbm9kZUlkLFxuICAgIGZsb2F0aW5nSWQsXG4gICAgZXZlbnRzLFxuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlXG4gIH0pLCBbcG9zaXRpb24sIG5vZGVJZCwgZmxvYXRpbmdJZCwgZXZlbnRzLCBvcGVuLCBvbk9wZW5DaGFuZ2UsIHJlZnMsIGVsZW1lbnRzXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBjb25zdCBub2RlID0gdHJlZSA9PSBudWxsID8gdm9pZCAwIDogdHJlZS5ub2Rlc1JlZi5jdXJyZW50LmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBub2RlSWQpO1xuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24sXG4gICAgY29udGV4dCxcbiAgICByZWZzLFxuICAgIGVsZW1lbnRzXG4gIH0pLCBbcG9zaXRpb24sIHJlZnMsIGVsZW1lbnRzLCBjb250ZXh0XSk7XG59XG5cbi8qKlxuICogT3BlbnMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hpbGUgdGhlIHJlZmVyZW5jZSBlbGVtZW50IGhhcyBmb2N1cywgbGlrZSBDU1NcbiAqIGA6Zm9jdXNgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUZvY3VzXG4gKi9cbmZ1bmN0aW9uIHVzZUZvY3VzKGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgZXZlbnRzLFxuICAgIHJlZnMsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGZsb2F0aW5nLFxuICAgICAgZG9tUmVmZXJlbmNlXG4gICAgfVxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIHZpc2libGVPbmx5ID0gdHJ1ZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGJsb2NrRm9jdXNSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCB0aW1lb3V0UmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IGtleWJvYXJkTW9kYWxpdHlSZWYgPSBSZWFjdC51c2VSZWYodHJ1ZSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhkb21SZWZlcmVuY2UpO1xuXG4gICAgLy8gSWYgdGhlIHJlZmVyZW5jZSB3YXMgZm9jdXNlZCBhbmQgdGhlIHVzZXIgbGVmdCB0aGUgdGFiL3dpbmRvdywgYW5kIHRoZVxuICAgIC8vIGZsb2F0aW5nIGVsZW1lbnQgd2FzIG5vdCBvcGVuLCB0aGUgZm9jdXMgc2hvdWxkIGJlIGJsb2NrZWQgd2hlbiB0aGV5XG4gICAgLy8gcmV0dXJuIHRvIHRoZSB0YWIvd2luZG93LlxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIGlmICghb3BlbiAmJiBpc0hUTUxFbGVtZW50KGRvbVJlZmVyZW5jZSkgJiYgZG9tUmVmZXJlbmNlID09PSBhY3RpdmVFbGVtZW50KGdldERvY3VtZW50KGRvbVJlZmVyZW5jZSkpKSB7XG4gICAgICAgIGJsb2NrRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uS2V5RG93bigpIHtcbiAgICAgIGtleWJvYXJkTW9kYWxpdHlSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfVxuICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgb25CbHVyKTtcbiAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5RG93biwgdHJ1ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgb25CbHVyKTtcbiAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXlEb3duLCB0cnVlKTtcbiAgICB9O1xuICB9LCBbZmxvYXRpbmcsIGRvbVJlZmVyZW5jZSwgb3BlbiwgZW5hYmxlZF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk9wZW5DaGFuZ2UoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgcmVhc29uXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGlmIChyZWFzb24gPT09ICdyZWZlcmVuY2UtcHJlc3MnIHx8IHJlYXNvbiA9PT0gJ2VzY2FwZS1rZXknKSB7XG4gICAgICAgIGJsb2NrRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGV2ZW50cy5vbignb3BlbmNoYW5nZScsIG9uT3BlbkNoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGV2ZW50cy5vZmYoJ29wZW5jaGFuZ2UnLCBvbk9wZW5DaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtldmVudHMsIGVuYWJsZWRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgb25Qb2ludGVyRG93bihldmVudCkge1xuICAgICAgICAgIGlmIChpc1ZpcnR1YWxQb2ludGVyRXZlbnQoZXZlbnQubmF0aXZlRXZlbnQpKSByZXR1cm47XG4gICAgICAgICAga2V5Ym9hcmRNb2RhbGl0eVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VMZWF2ZSgpIHtcbiAgICAgICAgICBibG9ja0ZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Gb2N1cyhldmVudCkge1xuICAgICAgICAgIGlmIChibG9ja0ZvY3VzUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQubmF0aXZlRXZlbnQpO1xuICAgICAgICAgIGlmICh2aXNpYmxlT25seSAmJiBpc0VsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gTWFjIFNhZmFyaSB1bnJlbGlhYmx5IG1hdGNoZXMgYDpmb2N1cy12aXNpYmxlYCBvbiB0aGUgcmVmZXJlbmNlXG4gICAgICAgICAgICAgIC8vIGlmIGZvY3VzIHdhcyBvdXRzaWRlIHRoZSBwYWdlIGluaXRpYWxseSAtIHVzZSB0aGUgZmFsbGJhY2tcbiAgICAgICAgICAgICAgLy8gaW5zdGVhZC5cbiAgICAgICAgICAgICAgaWYgKGlzU2FmYXJpKCkgJiYgaXNNYWMoKSkgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgaWYgKCF0YXJnZXQubWF0Y2hlcygnOmZvY3VzLXZpc2libGUnKSkgcmV0dXJuO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAvLyBPbGQgYnJvd3NlcnMgd2lsbCB0aHJvdyBhbiBlcnJvciB3aGVuIHVzaW5nIGA6Zm9jdXMtdmlzaWJsZWAuXG4gICAgICAgICAgICAgIGlmICgha2V5Ym9hcmRNb2RhbGl0eVJlZi5jdXJyZW50ICYmICFpc1R5cGVhYmxlRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2ZvY3VzJyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQmx1cihldmVudCkge1xuICAgICAgICAgIGJsb2NrRm9jdXNSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuXG4gICAgICAgICAgLy8gSGl0IHRoZSBub24tbW9kYWwgZm9jdXMgbWFuYWdlbWVudCBwb3J0YWwgZ3VhcmQuIEZvY3VzIHdpbGwgYmVcbiAgICAgICAgICAvLyBtb3ZlZCBpbnRvIHRoZSBmbG9hdGluZyBlbGVtZW50IGltbWVkaWF0ZWx5IGFmdGVyLlxuICAgICAgICAgIGNvbnN0IG1vdmVkVG9Gb2N1c0d1YXJkID0gaXNFbGVtZW50KHJlbGF0ZWRUYXJnZXQpICYmIHJlbGF0ZWRUYXJnZXQuaGFzQXR0cmlidXRlKGNyZWF0ZUF0dHJpYnV0ZSgnZm9jdXMtZ3VhcmQnKSkgJiYgcmVsYXRlZFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdHlwZScpID09PSAnb3V0c2lkZSc7XG5cbiAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgd2luZG93IGJsdXIgbGlzdGVuZXIgdG8gZmlyZS5cbiAgICAgICAgICB0aW1lb3V0UmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmVFbCA9IGFjdGl2ZUVsZW1lbnQoZG9tUmVmZXJlbmNlID8gZG9tUmVmZXJlbmNlLm93bmVyRG9jdW1lbnQgOiBkb2N1bWVudCk7XG5cbiAgICAgICAgICAgIC8vIEZvY3VzIGxlZnQgdGhlIHBhZ2UsIGtlZXAgaXQgb3Blbi5cbiAgICAgICAgICAgIGlmICghcmVsYXRlZFRhcmdldCAmJiBhY3RpdmVFbCA9PT0gZG9tUmVmZXJlbmNlKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIFdoZW4gZm9jdXNpbmcgdGhlIHJlZmVyZW5jZSBlbGVtZW50IChlLmcuIHJlZ3VsYXIgY2xpY2spLCB0aGVuXG4gICAgICAgICAgICAvLyBjbGlja2luZyBpbnRvIHRoZSBmbG9hdGluZyBlbGVtZW50LCBwcmV2ZW50IGl0IGZyb20gaGlkaW5nLlxuICAgICAgICAgICAgLy8gTm90ZTogaXQgbXVzdCBiZSBmb2N1c2FibGUsIGUuZy4gYHRhYmluZGV4PVwiLTFcImAuXG4gICAgICAgICAgICBpZiAoY29udGFpbnMocmVmcy5mbG9hdGluZy5jdXJyZW50LCByZWxhdGVkVGFyZ2V0KSB8fCBjb250YWlucyhkb21SZWZlcmVuY2UsIHJlbGF0ZWRUYXJnZXQpIHx8IG1vdmVkVG9Gb2N1c0d1YXJkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdmb2N1cycpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIHZpc2libGVPbmx5LCBkb21SZWZlcmVuY2UsIHJlZnMsIG9uT3BlbkNoYW5nZV0pO1xufVxuXG5jb25zdCBBQ1RJVkVfS0VZID0gJ2FjdGl2ZSc7XG5jb25zdCBTRUxFQ1RFRF9LRVkgPSAnc2VsZWN0ZWQnO1xuZnVuY3Rpb24gbWVyZ2VQcm9wcyh1c2VyUHJvcHMsIHByb3BzTGlzdCwgZWxlbWVudEtleSkge1xuICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGlzSXRlbSA9IGVsZW1lbnRLZXkgPT09ICdpdGVtJztcbiAgbGV0IGRvbVVzZXJQcm9wcyA9IHVzZXJQcm9wcztcbiAgaWYgKGlzSXRlbSAmJiB1c2VyUHJvcHMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgY29uc3Qge1xuICAgICAgW0FDVElWRV9LRVldOiBfLFxuICAgICAgW1NFTEVDVEVEX0tFWV06IF9fLFxuICAgICAgLi4udmFsaWRQcm9wc1xuICAgIH0gPSB1c2VyUHJvcHM7XG4gICAgZG9tVXNlclByb3BzID0gdmFsaWRQcm9wcztcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLihlbGVtZW50S2V5ID09PSAnZmxvYXRpbmcnICYmIHtcbiAgICAgIHRhYkluZGV4OiAtMVxuICAgIH0pLFxuICAgIC4uLmRvbVVzZXJQcm9wcyxcbiAgICAuLi5wcm9wc0xpc3QubWFwKHZhbHVlID0+IHtcbiAgICAgIGNvbnN0IHByb3BzT3JHZXRQcm9wcyA9IHZhbHVlID8gdmFsdWVbZWxlbWVudEtleV0gOiBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBwcm9wc09yR2V0UHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHVzZXJQcm9wcyA/IHByb3BzT3JHZXRQcm9wcyh1c2VyUHJvcHMpIDogbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wc09yR2V0UHJvcHM7XG4gICAgfSkuY29uY2F0KHVzZXJQcm9wcykucmVkdWNlKChhY2MsIHByb3BzKSA9PiB7XG4gICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG4gICAgICBPYmplY3QuZW50cmllcyhwcm9wcykuZm9yRWFjaChfcmVmID0+IHtcbiAgICAgICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWY7XG4gICAgICAgIGlmIChpc0l0ZW0gJiYgW0FDVElWRV9LRVksIFNFTEVDVEVEX0tFWV0uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5LmluZGV4T2YoJ29uJykgPT09IDApIHtcbiAgICAgICAgICBpZiAoIW1hcC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgbWFwLnNldChrZXksIFtdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIF9tYXAkZ2V0O1xuICAgICAgICAgICAgKF9tYXAkZ2V0ID0gbWFwLmdldChrZXkpKSA9PSBudWxsIHx8IF9tYXAkZ2V0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgYWNjW2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBfbWFwJGdldDI7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIChfbWFwJGdldDIgPSBtYXAuZ2V0KGtleSkpID09IG51bGwgPyB2b2lkIDAgOiBfbWFwJGdldDIubWFwKGZuID0+IGZuKC4uLmFyZ3MpKS5maW5kKHZhbCA9PiB2YWwgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pXG4gIH07XG59XG5cbi8qKlxuICogTWVyZ2VzIGFuIGFycmF5IG9mIGludGVyYWN0aW9uIGhvb2tzJyBwcm9wcyBpbnRvIHByb3AgZ2V0dGVycywgYWxsb3dpbmdcbiAqIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25zIHRvIGJlIGNvbXBvc2VkIHRvZ2V0aGVyIHdpdGhvdXQgb3ZlcndyaXRpbmcgb25lXG4gKiBhbm90aGVyLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUludGVyYWN0aW9uc1xuICovXG5mdW5jdGlvbiB1c2VJbnRlcmFjdGlvbnMocHJvcHNMaXN0KSB7XG4gIGlmIChwcm9wc0xpc3QgPT09IHZvaWQgMCkge1xuICAgIHByb3BzTGlzdCA9IFtdO1xuICB9XG4gIC8vIFRoZSBkZXBlbmRlbmNpZXMgYXJlIGEgZHluYW1pYyBhcnJheSwgc28gd2UgY2FuJ3QgdXNlIHRoZSBsaW50ZXInc1xuICAvLyBzdWdnZXN0aW9uIHRvIGFkZCBpdCB0byB0aGUgZGVwcyBhcnJheS5cbiAgY29uc3QgZGVwcyA9IHByb3BzTGlzdDtcbiAgY29uc3QgZ2V0UmVmZXJlbmNlUHJvcHMgPSBSZWFjdC51c2VDYWxsYmFjayh1c2VyUHJvcHMgPT4gbWVyZ2VQcm9wcyh1c2VyUHJvcHMsIHByb3BzTGlzdCwgJ3JlZmVyZW5jZScpLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIGRlcHMpO1xuICBjb25zdCBnZXRGbG9hdGluZ1Byb3BzID0gUmVhY3QudXNlQ2FsbGJhY2sodXNlclByb3BzID0+IG1lcmdlUHJvcHModXNlclByb3BzLCBwcm9wc0xpc3QsICdmbG9hdGluZycpLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIGRlcHMpO1xuICBjb25zdCBnZXRJdGVtUHJvcHMgPSBSZWFjdC51c2VDYWxsYmFjayh1c2VyUHJvcHMgPT4gbWVyZ2VQcm9wcyh1c2VyUHJvcHMsIHByb3BzTGlzdCwgJ2l0ZW0nKSxcbiAgLy8gR3JhbnVsYXJseSBjaGVjayBmb3IgYGl0ZW1gIGNoYW5nZXMsIGJlY2F1c2UgdGhlIGBnZXRJdGVtUHJvcHNgIGdldHRlclxuICAvLyBzaG91bGQgYmUgYXMgcmVmZXJlbnRpYWxseSBzdGFibGUgYXMgcG9zc2libGUgc2luY2UgaXQgbWF5IGJlIHBhc3NlZCBhc1xuICAvLyBhIHByb3AgdG8gbWFueSBjb21wb25lbnRzLiBBbGwgYGl0ZW1gIGtleSB2YWx1ZXMgbXVzdCB0aGVyZWZvcmUgYmVcbiAgLy8gbWVtb2l6ZWQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgcHJvcHNMaXN0Lm1hcChrZXkgPT4ga2V5ID09IG51bGwgPyB2b2lkIDAgOiBrZXkuaXRlbSkpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIGdldFJlZmVyZW5jZVByb3BzLFxuICAgIGdldEZsb2F0aW5nUHJvcHMsXG4gICAgZ2V0SXRlbVByb3BzXG4gIH0pLCBbZ2V0UmVmZXJlbmNlUHJvcHMsIGdldEZsb2F0aW5nUHJvcHMsIGdldEl0ZW1Qcm9wc10pO1xufVxuXG5sZXQgaXNQcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gZmFsc2U7XG5mdW5jdGlvbiBkb1N3aXRjaChvcmllbnRhdGlvbiwgdmVydGljYWwsIGhvcml6b250YWwpIHtcbiAgc3dpdGNoIChvcmllbnRhdGlvbikge1xuICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgIHJldHVybiB2ZXJ0aWNhbDtcbiAgICBjYXNlICdob3Jpem9udGFsJzpcbiAgICAgIHJldHVybiBob3Jpem9udGFsO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdmVydGljYWwgfHwgaG9yaXpvbnRhbDtcbiAgfVxufVxuZnVuY3Rpb24gaXNNYWluT3JpZW50YXRpb25LZXkoa2V5LCBvcmllbnRhdGlvbikge1xuICBjb25zdCB2ZXJ0aWNhbCA9IGtleSA9PT0gQVJST1dfVVAgfHwga2V5ID09PSBBUlJPV19ET1dOO1xuICBjb25zdCBob3Jpem9udGFsID0ga2V5ID09PSBBUlJPV19MRUZUIHx8IGtleSA9PT0gQVJST1dfUklHSFQ7XG4gIHJldHVybiBkb1N3aXRjaChvcmllbnRhdGlvbiwgdmVydGljYWwsIGhvcml6b250YWwpO1xufVxuZnVuY3Rpb24gaXNNYWluT3JpZW50YXRpb25Ub0VuZEtleShrZXksIG9yaWVudGF0aW9uLCBydGwpIHtcbiAgY29uc3QgdmVydGljYWwgPSBrZXkgPT09IEFSUk9XX0RPV047XG4gIGNvbnN0IGhvcml6b250YWwgPSBydGwgPyBrZXkgPT09IEFSUk9XX0xFRlQgOiBrZXkgPT09IEFSUk9XX1JJR0hUO1xuICByZXR1cm4gZG9Td2l0Y2gob3JpZW50YXRpb24sIHZlcnRpY2FsLCBob3Jpem9udGFsKSB8fCBrZXkgPT09ICdFbnRlcicgfHwga2V5ID09ICcgJyB8fCBrZXkgPT09ICcnO1xufVxuZnVuY3Rpb24gaXNDcm9zc09yaWVudGF0aW9uT3BlbktleShrZXksIG9yaWVudGF0aW9uLCBydGwpIHtcbiAgY29uc3QgdmVydGljYWwgPSBydGwgPyBrZXkgPT09IEFSUk9XX0xFRlQgOiBrZXkgPT09IEFSUk9XX1JJR0hUO1xuICBjb25zdCBob3Jpem9udGFsID0ga2V5ID09PSBBUlJPV19ET1dOO1xuICByZXR1cm4gZG9Td2l0Y2gob3JpZW50YXRpb24sIHZlcnRpY2FsLCBob3Jpem9udGFsKTtcbn1cbmZ1bmN0aW9uIGlzQ3Jvc3NPcmllbnRhdGlvbkNsb3NlS2V5KGtleSwgb3JpZW50YXRpb24sIHJ0bCkge1xuICBjb25zdCB2ZXJ0aWNhbCA9IHJ0bCA/IGtleSA9PT0gQVJST1dfUklHSFQgOiBrZXkgPT09IEFSUk9XX0xFRlQ7XG4gIGNvbnN0IGhvcml6b250YWwgPSBrZXkgPT09IEFSUk9XX1VQO1xuICByZXR1cm4gZG9Td2l0Y2gob3JpZW50YXRpb24sIHZlcnRpY2FsLCBob3Jpem9udGFsKTtcbn1cbi8qKlxuICogQWRkcyBhcnJvdyBrZXktYmFzZWQgbmF2aWdhdGlvbiBvZiBhIGxpc3Qgb2YgaXRlbXMsIGVpdGhlciB1c2luZyByZWFsIERPTVxuICogZm9jdXMgb3IgdmlydHVhbCBmb2N1cy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VMaXN0TmF2aWdhdGlvblxuICovXG5mdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvbihjb250ZXh0LCBwcm9wcykge1xuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgcmVmcyxcbiAgICBlbGVtZW50czoge1xuICAgICAgZG9tUmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmdcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgbGlzdFJlZixcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvbk5hdmlnYXRlOiB1bnN0YWJsZV9vbk5hdmlnYXRlID0gKCkgPT4ge30sXG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgc2VsZWN0ZWRJbmRleCA9IG51bGwsXG4gICAgYWxsb3dFc2NhcGUgPSBmYWxzZSxcbiAgICBsb29wID0gZmFsc2UsXG4gICAgbmVzdGVkID0gZmFsc2UsXG4gICAgcnRsID0gZmFsc2UsXG4gICAgdmlydHVhbCA9IGZhbHNlLFxuICAgIGZvY3VzSXRlbU9uT3BlbiA9ICdhdXRvJyxcbiAgICBmb2N1c0l0ZW1PbkhvdmVyID0gdHJ1ZSxcbiAgICBvcGVuT25BcnJvd0tleURvd24gPSB0cnVlLFxuICAgIGRpc2FibGVkSW5kaWNlcyA9IHVuZGVmaW5lZCxcbiAgICBvcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCcsXG4gICAgY29scyA9IDEsXG4gICAgc2Nyb2xsSXRlbUludG9WaWV3ID0gdHJ1ZSxcbiAgICB2aXJ0dWFsSXRlbVJlZlxuICB9ID0gcHJvcHM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoYWxsb3dFc2NhcGUpIHtcbiAgICAgIGlmICghbG9vcCkge1xuICAgICAgICBjb25zb2xlLndhcm4oWydGbG9hdGluZyBVSTogYHVzZUxpc3ROYXZpZ2F0aW9uYCBsb29waW5nIG11c3QgYmUgZW5hYmxlZCB0byBhbGxvdycsICdlc2NhcGluZy4nXS5qb2luKCcgJykpO1xuICAgICAgfVxuICAgICAgaWYgKCF2aXJ0dWFsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihbJ0Zsb2F0aW5nIFVJOiBgdXNlTGlzdE5hdmlnYXRpb25gIG11c3QgYmUgdmlydHVhbCB0byBhbGxvdycsICdlc2NhcGluZy4nXS5qb2luKCcgJykpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgJiYgY29scyA+IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybihbJ0Zsb2F0aW5nIFVJOiBJbiBncmlkIGxpc3QgbmF2aWdhdGlvbiBtb2RlIChgY29sc2AgPiAxKSwgdGhlJywgJ2BvcmllbnRhdGlvbmAgc2hvdWxkIGJlIGVpdGhlciBcImhvcml6b250YWxcIiBvciBcImJvdGhcIi4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYXJlbnRJZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCk7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3Qgb25OYXZpZ2F0ZSA9IHVzZUVmZmVjdEV2ZW50KHVuc3RhYmxlX29uTmF2aWdhdGUpO1xuICBjb25zdCBmb2N1c0l0ZW1Pbk9wZW5SZWYgPSBSZWFjdC51c2VSZWYoZm9jdXNJdGVtT25PcGVuKTtcbiAgY29uc3QgaW5kZXhSZWYgPSBSZWFjdC51c2VSZWYoc2VsZWN0ZWRJbmRleCAhPSBudWxsID8gc2VsZWN0ZWRJbmRleCA6IC0xKTtcbiAgY29uc3Qga2V5UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBpc1BvaW50ZXJNb2RhbGl0eVJlZiA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgY29uc3QgcHJldmlvdXNPbk5hdmlnYXRlUmVmID0gUmVhY3QudXNlUmVmKG9uTmF2aWdhdGUpO1xuICBjb25zdCBwcmV2aW91c01vdW50ZWRSZWYgPSBSZWFjdC51c2VSZWYoISFmbG9hdGluZyk7XG4gIGNvbnN0IGZvcmNlU3luY0ZvY3VzID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgZm9yY2VTY3JvbGxJbnRvVmlld1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGRpc2FibGVkSW5kaWNlc1JlZiA9IHVzZUxhdGVzdFJlZihkaXNhYmxlZEluZGljZXMpO1xuICBjb25zdCBsYXRlc3RPcGVuUmVmID0gdXNlTGF0ZXN0UmVmKG9wZW4pO1xuICBjb25zdCBzY3JvbGxJdGVtSW50b1ZpZXdSZWYgPSB1c2VMYXRlc3RSZWYoc2Nyb2xsSXRlbUludG9WaWV3KTtcbiAgY29uc3QgW2FjdGl2ZUlkLCBzZXRBY3RpdmVJZF0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICBjb25zdCBbdmlydHVhbElkLCBzZXRWaXJ0dWFsSWRdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgY29uc3QgZm9jdXNJdGVtID0gdXNlRWZmZWN0RXZlbnQoZnVuY3Rpb24gKGxpc3RSZWYsIGluZGV4UmVmLCBmb3JjZVNjcm9sbEludG9WaWV3KSB7XG4gICAgaWYgKGZvcmNlU2Nyb2xsSW50b1ZpZXcgPT09IHZvaWQgMCkge1xuICAgICAgZm9yY2VTY3JvbGxJbnRvVmlldyA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0gbGlzdFJlZi5jdXJyZW50W2luZGV4UmVmLmN1cnJlbnRdO1xuICAgIGlmICghaXRlbSkgcmV0dXJuO1xuICAgIGlmICh2aXJ0dWFsKSB7XG4gICAgICBzZXRBY3RpdmVJZChpdGVtLmlkKTtcbiAgICAgIHRyZWUgPT0gbnVsbCB8fCB0cmVlLmV2ZW50cy5lbWl0KCd2aXJ0dWFsZm9jdXMnLCBpdGVtKTtcbiAgICAgIGlmICh2aXJ0dWFsSXRlbVJlZikge1xuICAgICAgICB2aXJ0dWFsSXRlbVJlZi5jdXJyZW50ID0gaXRlbTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZW5xdWV1ZUZvY3VzKGl0ZW0sIHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZSxcbiAgICAgICAgLy8gTWFjIFNhZmFyaSBkb2VzIG5vdCBtb3ZlIHRoZSB2aXJ0dWFsIGN1cnNvciB1bmxlc3MgdGhlIGZvY3VzIGNhbGxcbiAgICAgICAgLy8gaXMgc3luYy4gSG93ZXZlciwgZm9yIHRoZSB2ZXJ5IGZpcnN0IGZvY3VzIGNhbGwsIHdlIG5lZWQgdG8gd2FpdFxuICAgICAgICAvLyBmb3IgdGhlIHBvc2l0aW9uIHRvIGJlIHJlYWR5IGluIG9yZGVyIHRvIHByZXZlbnQgdW53YW50ZWRcbiAgICAgICAgLy8gc2Nyb2xsaW5nLiBUaGlzIG1lYW5zIHRoZSB2aXJ0dWFsIGN1cnNvciB3aWxsIG5vdCBtb3ZlIHRvIHRoZSBmaXJzdFxuICAgICAgICAvLyBpdGVtIHdoZW4gZmlyc3Qgb3BlbmluZyB0aGUgZmxvYXRpbmcgZWxlbWVudCwgYnV0IHdpbGwgb25cbiAgICAgICAgLy8gc3Vic2VxdWVudCBjYWxscy4gYHByZXZlbnRTY3JvbGxgIGlzIHN1cHBvcnRlZCBpbiBtb2Rlcm4gU2FmYXJpLFxuICAgICAgICAvLyBzbyB3ZSBjYW4gdXNlIHRoYXQgaW5zdGVhZC5cbiAgICAgICAgLy8gaU9TIFNhZmFyaSBtdXN0IGJlIGFzeW5jIG9yIHRoZSBmaXJzdCBpdGVtIHdpbGwgbm90IGJlIGZvY3VzZWQuXG4gICAgICAgIHN5bmM6IGlzTWFjKCkgJiYgaXNTYWZhcmkoKSA/IGlzUHJldmVudFNjcm9sbFN1cHBvcnRlZCB8fCBmb3JjZVN5bmNGb2N1cy5jdXJyZW50IDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgY29uc3Qgc2Nyb2xsSW50b1ZpZXdPcHRpb25zID0gc2Nyb2xsSXRlbUludG9WaWV3UmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBzaG91bGRTY3JvbGxJbnRvVmlldyA9IHNjcm9sbEludG9WaWV3T3B0aW9ucyAmJiBpdGVtICYmIChmb3JjZVNjcm9sbEludG9WaWV3IHx8ICFpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50KTtcbiAgICAgIGlmIChzaG91bGRTY3JvbGxJbnRvVmlldykge1xuICAgICAgICAvLyBKU0RPTSBkb2Vzbid0IHN1cHBvcnQgYC5zY3JvbGxJbnRvVmlldygpYCBidXQgaXQncyB3aWRlbHkgc3VwcG9ydGVkXG4gICAgICAgIC8vIGJ5IGFsbCBicm93c2Vycy5cbiAgICAgICAgaXRlbS5zY3JvbGxJbnRvVmlldyA9PSBudWxsIHx8IGl0ZW0uc2Nyb2xsSW50b1ZpZXcodHlwZW9mIHNjcm9sbEludG9WaWV3T3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8ge1xuICAgICAgICAgIGJsb2NrOiAnbmVhcmVzdCcsXG4gICAgICAgICAgaW5saW5lOiAnbmVhcmVzdCdcbiAgICAgICAgfSA6IHNjcm9sbEludG9WaWV3T3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykuZm9jdXMoe1xuICAgICAgZ2V0IHByZXZlbnRTY3JvbGwoKSB7XG4gICAgICAgIGlzUHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW10pO1xuXG4gIC8vIFN5bmMgYHNlbGVjdGVkSW5kZXhgIHRvIGJlIHRoZSBgYWN0aXZlSW5kZXhgIHVwb24gb3BlbmluZyB0aGUgZmxvYXRpbmdcbiAgLy8gZWxlbWVudC4gQWxzbywgcmVzZXQgYGFjdGl2ZUluZGV4YCB1cG9uIGNsb3NpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wZW4gJiYgZmxvYXRpbmcpIHtcbiAgICAgIGlmIChmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCAmJiBzZWxlY3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgLy8gUmVnYXJkbGVzcyBvZiB0aGUgcG9pbnRlciBtb2RhbGl0eSwgd2Ugd2FudCB0byBlbnN1cmUgdGhlIHNlbGVjdGVkXG4gICAgICAgIC8vIGl0ZW0gY29tZXMgaW50byB2aWV3IHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgb3BlbmVkLlxuICAgICAgICBmb3JjZVNjcm9sbEludG9WaWV3UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBvbk5hdmlnYXRlKHNlbGVjdGVkSW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJldmlvdXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIFNpbmNlIHRoZSB1c2VyIGNhbiBzcGVjaWZ5IGBvbk5hdmlnYXRlYCBjb25kaXRpb25hbGx5XG4gICAgICAvLyAob25OYXZpZ2F0ZTogb3BlbiA/IHNldEFjdGl2ZUluZGV4IDogc2V0U2VsZWN0ZWRJbmRleCksXG4gICAgICAvLyB3ZSBzdG9yZSBhbmQgY2FsbCB0aGUgcHJldmlvdXMgZnVuY3Rpb24uXG4gICAgICBpbmRleFJlZi5jdXJyZW50ID0gLTE7XG4gICAgICBwcmV2aW91c09uTmF2aWdhdGVSZWYuY3VycmVudChudWxsKTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBmbG9hdGluZywgc2VsZWN0ZWRJbmRleCwgb25OYXZpZ2F0ZV0pO1xuXG4gIC8vIFN5bmMgYGFjdGl2ZUluZGV4YCB0byBiZSB0aGUgZm9jdXNlZCBpdGVtIHdoaWxlIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzXG4gIC8vIG9wZW4uXG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wZW4gJiYgZmxvYXRpbmcpIHtcbiAgICAgIGlmIChhY3RpdmVJbmRleCA9PSBudWxsKSB7XG4gICAgICAgIGZvcmNlU3luY0ZvY3VzLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2V0IHdoaWxlIHRoZSBmbG9hdGluZyBlbGVtZW50IHdhcyBvcGVuIChlLmcuIHRoZSBsaXN0IGNoYW5nZWQpLlxuICAgICAgICBpZiAocHJldmlvdXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gLTE7XG4gICAgICAgICAgZm9jdXNJdGVtKGxpc3RSZWYsIGluZGV4UmVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYWwgc3luYy5cbiAgICAgICAgaWYgKCFwcmV2aW91c01vdW50ZWRSZWYuY3VycmVudCAmJiBmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCAmJiAoa2V5UmVmLmN1cnJlbnQgIT0gbnVsbCB8fCBmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCA9PT0gdHJ1ZSAmJiBrZXlSZWYuY3VycmVudCA9PSBudWxsKSkge1xuICAgICAgICAgIGxldCBydW5zID0gMDtcbiAgICAgICAgICBjb25zdCB3YWl0Rm9yTGlzdFBvcHVsYXRlZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChsaXN0UmVmLmN1cnJlbnRbMF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBBdm9pZCBsZXR0aW5nIHRoZSBicm93c2VyIHBhaW50IGlmIHBvc3NpYmxlIG9uIHRoZSBmaXJzdCB0cnksXG4gICAgICAgICAgICAgIC8vIG90aGVyd2lzZSB1c2UgckFGLiBEb24ndCB0cnkgbW9yZSB0aGFuIHR3aWNlLCBzaW5jZSBzb21ldGhpbmdcbiAgICAgICAgICAgICAgLy8gaXMgd3Jvbmcgb3RoZXJ3aXNlLlxuICAgICAgICAgICAgICBpZiAocnVucyA8IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlZHVsZXIgPSBydW5zID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogcXVldWVNaWNyb3Rhc2s7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyKHdhaXRGb3JMaXN0UG9wdWxhdGVkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBydW5zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0ga2V5UmVmLmN1cnJlbnQgPT0gbnVsbCB8fCBpc01haW5PcmllbnRhdGlvblRvRW5kS2V5KGtleVJlZi5jdXJyZW50LCBvcmllbnRhdGlvbiwgcnRsKSB8fCBuZXN0ZWQgPyBnZXRNaW5JbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXNSZWYuY3VycmVudCkgOiBnZXRNYXhJbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXNSZWYuY3VycmVudCk7XG4gICAgICAgICAgICAgIGtleVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHdhaXRGb3JMaXN0UG9wdWxhdGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzSW5kZXhPdXRPZkJvdW5kcyhsaXN0UmVmLCBhY3RpdmVJbmRleCkpIHtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGFjdGl2ZUluZGV4O1xuICAgICAgICBmb2N1c0l0ZW0obGlzdFJlZiwgaW5kZXhSZWYsIGZvcmNlU2Nyb2xsSW50b1ZpZXdSZWYuY3VycmVudCk7XG4gICAgICAgIGZvcmNlU2Nyb2xsSW50b1ZpZXdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2VuYWJsZWQsIG9wZW4sIGZsb2F0aW5nLCBhY3RpdmVJbmRleCwgc2VsZWN0ZWRJbmRleCwgbmVzdGVkLCBsaXN0UmVmLCBvcmllbnRhdGlvbiwgcnRsLCBvbk5hdmlnYXRlLCBmb2N1c0l0ZW0sIGRpc2FibGVkSW5kaWNlc1JlZl0pO1xuXG4gIC8vIEVuc3VyZSB0aGUgcGFyZW50IGZsb2F0aW5nIGVsZW1lbnQgaGFzIGZvY3VzIHdoZW4gYSBuZXN0ZWQgY2hpbGQgY2xvc2VzXG4gIC8vIHRvIGFsbG93IGFycm93IGtleSBuYXZpZ2F0aW9uIHRvIHdvcmsgYWZ0ZXIgdGhlIHBvaW50ZXIgbGVhdmVzIHRoZSBjaGlsZC5cbiAgaW5kZXgoKCkgPT4ge1xuICAgIHZhciBfbm9kZXMkZmluZDtcbiAgICBpZiAoIWVuYWJsZWQgfHwgZmxvYXRpbmcgfHwgIXRyZWUgfHwgdmlydHVhbCB8fCAhcHJldmlvdXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm9kZXMgPSB0cmVlLm5vZGVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgcGFyZW50ID0gKF9ub2RlcyRmaW5kID0gbm9kZXMuZmluZChub2RlID0+IG5vZGUuaWQgPT09IHBhcmVudElkKSkgPT0gbnVsbCB8fCAoX25vZGVzJGZpbmQgPSBfbm9kZXMkZmluZC5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGVzJGZpbmQuZWxlbWVudHMuZmxvYXRpbmc7XG4gICAgY29uc3QgYWN0aXZlRWwgPSBhY3RpdmVFbGVtZW50KGdldERvY3VtZW50KGZsb2F0aW5nKSk7XG4gICAgY29uc3QgdHJlZUNvbnRhaW5zQWN0aXZlRWwgPSBub2Rlcy5zb21lKG5vZGUgPT4gbm9kZS5jb250ZXh0ICYmIGNvbnRhaW5zKG5vZGUuY29udGV4dC5lbGVtZW50cy5mbG9hdGluZywgYWN0aXZlRWwpKTtcbiAgICBpZiAocGFyZW50ICYmICF0cmVlQ29udGFpbnNBY3RpdmVFbCAmJiBpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50KSB7XG4gICAgICBwYXJlbnQuZm9jdXMoe1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBmbG9hdGluZywgdHJlZSwgcGFyZW50SWQsIHZpcnR1YWxdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCB8fCAhdHJlZSB8fCAhdmlydHVhbCB8fCBwYXJlbnRJZCkgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIGhhbmRsZVZpcnR1YWxGb2N1cyhpdGVtKSB7XG4gICAgICBzZXRWaXJ0dWFsSWQoaXRlbS5pZCk7XG4gICAgICBpZiAodmlydHVhbEl0ZW1SZWYpIHtcbiAgICAgICAgdmlydHVhbEl0ZW1SZWYuY3VycmVudCA9IGl0ZW07XG4gICAgICB9XG4gICAgfVxuICAgIHRyZWUuZXZlbnRzLm9uKCd2aXJ0dWFsZm9jdXMnLCBoYW5kbGVWaXJ0dWFsRm9jdXMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0cmVlLmV2ZW50cy5vZmYoJ3ZpcnR1YWxmb2N1cycsIGhhbmRsZVZpcnR1YWxGb2N1cyk7XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIHRyZWUsIHZpcnR1YWwsIHBhcmVudElkLCB2aXJ0dWFsSXRlbVJlZl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgcHJldmlvdXNPbk5hdmlnYXRlUmVmLmN1cnJlbnQgPSBvbk5hdmlnYXRlO1xuICAgIHByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50ID0gISFmbG9hdGluZztcbiAgfSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIW9wZW4pIHtcbiAgICAgIGtleVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtvcGVuXSk7XG4gIGNvbnN0IGhhc0FjdGl2ZUluZGV4ID0gYWN0aXZlSW5kZXggIT0gbnVsbDtcbiAgY29uc3QgaXRlbSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHN5bmNDdXJyZW50VGFyZ2V0KGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIGlmICghb3BlbikgcmV0dXJuO1xuICAgICAgY29uc3QgaW5kZXggPSBsaXN0UmVmLmN1cnJlbnQuaW5kZXhPZihjdXJyZW50VGFyZ2V0KTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgb25OYXZpZ2F0ZShpbmRleCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgb25Gb2N1cyhfcmVmKSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgY3VycmVudFRhcmdldFxuICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgc3luY0N1cnJlbnRUYXJnZXQoY3VycmVudFRhcmdldCk7XG4gICAgICB9LFxuICAgICAgb25DbGljazogX3JlZjIgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICByZXR1cm4gY3VycmVudFRhcmdldC5mb2N1cyh7XG4gICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICAvLyBTYWZhcmlcbiAgICAgIC4uLihmb2N1c0l0ZW1PbkhvdmVyICYmIHtcbiAgICAgICAgb25Nb3VzZU1vdmUoX3JlZjMpIHtcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgY3VycmVudFRhcmdldFxuICAgICAgICAgIH0gPSBfcmVmMztcbiAgICAgICAgICBzeW5jQ3VycmVudFRhcmdldChjdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyTGVhdmUoX3JlZjQpIHtcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgcG9pbnRlclR5cGVcbiAgICAgICAgICB9ID0gX3JlZjQ7XG4gICAgICAgICAgaWYgKCFpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50IHx8IHBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSAtMTtcbiAgICAgICAgICBmb2N1c0l0ZW0obGlzdFJlZiwgaW5kZXhSZWYpO1xuICAgICAgICAgIG9uTmF2aWdhdGUobnVsbCk7XG4gICAgICAgICAgaWYgKCF2aXJ0dWFsKSB7XG4gICAgICAgICAgICBlbnF1ZXVlRm9jdXMocmVmcy5mbG9hdGluZy5jdXJyZW50LCB7XG4gICAgICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9O1xuICAgIHJldHVybiBwcm9wcztcbiAgfSwgW29wZW4sIHJlZnMsIGZvY3VzSXRlbSwgZm9jdXNJdGVtT25Ib3ZlciwgbGlzdFJlZiwgb25OYXZpZ2F0ZSwgdmlydHVhbF0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IGRpc2FibGVkSW5kaWNlcyA9IGRpc2FibGVkSW5kaWNlc1JlZi5jdXJyZW50O1xuICAgIGZ1bmN0aW9uIG9uS2V5RG93bihldmVudCkge1xuICAgICAgaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgZm9yY2VTeW5jRm9jdXMuY3VycmVudCA9IHRydWU7XG5cbiAgICAgIC8vIElmIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzIGFuaW1hdGluZyBvdXQsIGlnbm9yZSBuYXZpZ2F0aW9uLiBPdGhlcndpc2UsXG4gICAgICAvLyB0aGUgYGFjdGl2ZUluZGV4YCBnZXRzIHNldCB0byAwIGRlc3BpdGUgbm90IGJlaW5nIG9wZW4gc28gdGhlIG5leHQgdGltZVxuICAgICAgLy8gdGhlIHVzZXIgQXJyb3dEb3ducywgdGhlIGZpcnN0IGl0ZW0gd29uJ3QgYmUgZm9jdXNlZC5cbiAgICAgIGlmICghbGF0ZXN0T3BlblJlZi5jdXJyZW50ICYmIGV2ZW50LmN1cnJlbnRUYXJnZXQgPT09IHJlZnMuZmxvYXRpbmcuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobmVzdGVkICYmIGlzQ3Jvc3NPcmllbnRhdGlvbkNsb3NlS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24sIHJ0bCkpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2xpc3QtbmF2aWdhdGlvbicpO1xuICAgICAgICBpZiAoaXNIVE1MRWxlbWVudChkb21SZWZlcmVuY2UpICYmICF2aXJ0dWFsKSB7XG4gICAgICAgICAgZG9tUmVmZXJlbmNlLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gaW5kZXhSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IG1pbkluZGV4ID0gZ2V0TWluSW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzKTtcbiAgICAgIGNvbnN0IG1heEluZGV4ID0gZ2V0TWF4SW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzKTtcbiAgICAgIGlmIChldmVudC5rZXkgPT09ICdIb21lJykge1xuICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gbWluSW5kZXg7XG4gICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnRW5kJykge1xuICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gbWF4SW5kZXg7XG4gICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEdyaWQgbmF2aWdhdGlvbi5cbiAgICAgIGlmIChjb2xzID4gMSkge1xuICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gZ2V0R3JpZE5hdmlnYXRlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICBldmVudCxcbiAgICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgICBsb29wLFxuICAgICAgICAgIGNvbHMsXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzLFxuICAgICAgICAgIG1pbkluZGV4LFxuICAgICAgICAgIG1heEluZGV4LFxuICAgICAgICAgIHByZXZJbmRleDogaW5kZXhSZWYuY3VycmVudCxcbiAgICAgICAgICBzdG9wRXZlbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ2JvdGgnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNNYWluT3JpZW50YXRpb25LZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbikpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcblxuICAgICAgICAvLyBSZXNldCB0aGUgaW5kZXggaWYgbm8gaXRlbSBpcyBmb2N1c2VkLlxuICAgICAgICBpZiAob3BlbiAmJiAhdmlydHVhbCAmJiBhY3RpdmVFbGVtZW50KGV2ZW50LmN1cnJlbnRUYXJnZXQub3duZXJEb2N1bWVudCkgPT09IGV2ZW50LmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gaXNNYWluT3JpZW50YXRpb25Ub0VuZEtleShldmVudC5rZXksIG9yaWVudGF0aW9uLCBydGwpID8gbWluSW5kZXggOiBtYXhJbmRleDtcbiAgICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNNYWluT3JpZW50YXRpb25Ub0VuZEtleShldmVudC5rZXksIG9yaWVudGF0aW9uLCBydGwpKSB7XG4gICAgICAgICAgaWYgKGxvb3ApIHtcbiAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBjdXJyZW50SW5kZXggPj0gbWF4SW5kZXggPyBhbGxvd0VzY2FwZSAmJiBjdXJyZW50SW5kZXggIT09IGxpc3RSZWYuY3VycmVudC5sZW5ndGggPyAtMSA6IG1pbkluZGV4IDogZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgICBzdGFydGluZ0luZGV4OiBjdXJyZW50SW5kZXgsXG4gICAgICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBNYXRoLm1pbihtYXhJbmRleCwgZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgICBzdGFydGluZ0luZGV4OiBjdXJyZW50SW5kZXgsXG4gICAgICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobG9vcCkge1xuICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGN1cnJlbnRJbmRleCA8PSBtaW5JbmRleCA/IGFsbG93RXNjYXBlICYmIGN1cnJlbnRJbmRleCAhPT0gLTEgPyBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoIDogbWF4SW5kZXggOiBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IGN1cnJlbnRJbmRleCxcbiAgICAgICAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gTWF0aC5tYXgobWluSW5kZXgsIGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogY3VycmVudEluZGV4LFxuICAgICAgICAgICAgICBkZWNyZW1lbnQ6IHRydWUsXG4gICAgICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJbmRleE91dE9mQm91bmRzKGxpc3RSZWYsIGluZGV4UmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgb25OYXZpZ2F0ZShudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVmlydHVhbE1vdXNlKGV2ZW50KSB7XG4gICAgICBpZiAoZm9jdXNJdGVtT25PcGVuID09PSAnYXV0bycgJiYgaXNWaXJ0dWFsQ2xpY2soZXZlbnQubmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIGZvY3VzSXRlbU9uT3BlblJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tWaXJ0dWFsUG9pbnRlcihldmVudCkge1xuICAgICAgLy8gYHBvaW50ZXJkb3duYCBmaXJlcyBmaXJzdCwgcmVzZXQgdGhlIHN0YXRlIHRoZW4gcGVyZm9ybSB0aGUgY2hlY2tzLlxuICAgICAgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgPSBmb2N1c0l0ZW1Pbk9wZW47XG4gICAgICBpZiAoZm9jdXNJdGVtT25PcGVuID09PSAnYXV0bycgJiYgaXNWaXJ0dWFsUG9pbnRlckV2ZW50KGV2ZW50Lm5hdGl2ZUV2ZW50KSkge1xuICAgICAgICBmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFyaWFBY3RpdmVEZXNjZW5kYW50UHJvcCA9IHZpcnR1YWwgJiYgb3BlbiAmJiBoYXNBY3RpdmVJbmRleCAmJiB7XG4gICAgICAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogdmlydHVhbElkIHx8IGFjdGl2ZUlkXG4gICAgfTtcbiAgICBjb25zdCBhY3RpdmVJdGVtID0gbGlzdFJlZi5jdXJyZW50LmZpbmQoaXRlbSA9PiAoaXRlbSA9PSBudWxsID8gdm9pZCAwIDogaXRlbS5pZCkgPT09IGFjdGl2ZUlkKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgIC4uLmFyaWFBY3RpdmVEZXNjZW5kYW50UHJvcCxcbiAgICAgICAgb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICAgICAgaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IGlzQXJyb3dLZXkgPSBldmVudC5rZXkuaW5kZXhPZignQXJyb3cnKSA9PT0gMDtcbiAgICAgICAgICBjb25zdCBpc0Nyb3NzT3BlbktleSA9IGlzQ3Jvc3NPcmllbnRhdGlvbk9wZW5LZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsKTtcbiAgICAgICAgICBjb25zdCBpc0Nyb3NzQ2xvc2VLZXkgPSBpc0Nyb3NzT3JpZW50YXRpb25DbG9zZUtleShldmVudC5rZXksIG9yaWVudGF0aW9uLCBydGwpO1xuICAgICAgICAgIGNvbnN0IGlzTWFpbktleSA9IGlzTWFpbk9yaWVudGF0aW9uS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24pO1xuICAgICAgICAgIGNvbnN0IGlzTmF2aWdhdGlvbktleSA9IChuZXN0ZWQgPyBpc0Nyb3NzT3BlbktleSA6IGlzTWFpbktleSkgfHwgZXZlbnQua2V5ID09PSAnRW50ZXInIHx8IGV2ZW50LmtleS50cmltKCkgPT09ICcnO1xuICAgICAgICAgIGlmICh2aXJ0dWFsICYmIG9wZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3ROb2RlID0gdHJlZSA9PSBudWxsID8gdm9pZCAwIDogdHJlZS5ub2Rlc1JlZi5jdXJyZW50LmZpbmQobm9kZSA9PiBub2RlLnBhcmVudElkID09IG51bGwpO1xuICAgICAgICAgICAgY29uc3QgZGVlcGVzdE5vZGUgPSB0cmVlICYmIHJvb3ROb2RlID8gZ2V0RGVlcGVzdE5vZGUodHJlZS5ub2Rlc1JlZi5jdXJyZW50LCByb290Tm9kZS5pZCkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGlzQXJyb3dLZXkgJiYgZGVlcGVzdE5vZGUgJiYgdmlydHVhbEl0ZW1SZWYpIHtcbiAgICAgICAgICAgICAgY29uc3QgZXZlbnRPYmplY3QgPSBuZXcgS2V5Ym9hcmRFdmVudCgna2V5ZG93bicsIHtcbiAgICAgICAgICAgICAgICBrZXk6IGV2ZW50LmtleSxcbiAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoaXNDcm9zc09wZW5LZXkgfHwgaXNDcm9zc0Nsb3NlS2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9kZWVwZXN0Tm9kZSRjb250ZXh0LCBfZGVlcGVzdE5vZGUkY29udGV4dDI7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNDdXJyZW50VGFyZ2V0ID0gKChfZGVlcGVzdE5vZGUkY29udGV4dCA9IGRlZXBlc3ROb2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfZGVlcGVzdE5vZGUkY29udGV4dC5lbGVtZW50cy5kb21SZWZlcmVuY2UpID09PSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3BhdGNoSXRlbSA9IGlzQ3Jvc3NDbG9zZUtleSAmJiAhaXNDdXJyZW50VGFyZ2V0ID8gKF9kZWVwZXN0Tm9kZSRjb250ZXh0MiA9IGRlZXBlc3ROb2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfZGVlcGVzdE5vZGUkY29udGV4dDIuZWxlbWVudHMuZG9tUmVmZXJlbmNlIDogaXNDcm9zc09wZW5LZXkgPyBhY3RpdmVJdGVtIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoZGlzcGF0Y2hJdGVtKSB7XG4gICAgICAgICAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hJdGVtLmRpc3BhdGNoRXZlbnQoZXZlbnRPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgc2V0VmlydHVhbElkKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc01haW5LZXkgJiYgZGVlcGVzdE5vZGUuY29udGV4dCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWVwZXN0Tm9kZS5jb250ZXh0Lm9wZW4gJiYgZGVlcGVzdE5vZGUucGFyZW50SWQgJiYgZXZlbnQuY3VycmVudFRhcmdldCAhPT0gZGVlcGVzdE5vZGUuY29udGV4dC5lbGVtZW50cy5kb21SZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfZGVlcGVzdE5vZGUkY29udGV4dCQ7XG4gICAgICAgICAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgKF9kZWVwZXN0Tm9kZSRjb250ZXh0JCA9IGRlZXBlc3ROb2RlLmNvbnRleHQuZWxlbWVudHMuZG9tUmVmZXJlbmNlKSA9PSBudWxsIHx8IF9kZWVwZXN0Tm9kZSRjb250ZXh0JC5kaXNwYXRjaEV2ZW50KGV2ZW50T2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvbktleURvd24oZXZlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIGEgZmxvYXRpbmcgZWxlbWVudCBzaG91bGQgbm90IG9wZW4gb24gYXJyb3cga2V5IGRvd24sIGF2b2lkXG4gICAgICAgICAgLy8gc2V0dGluZyBgYWN0aXZlSW5kZXhgIHdoaWxlIGl0J3MgY2xvc2VkLlxuICAgICAgICAgIGlmICghb3BlbiAmJiAhb3Blbk9uQXJyb3dLZXlEb3duICYmIGlzQXJyb3dLZXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzTmF2aWdhdGlvbktleSkge1xuICAgICAgICAgICAga2V5UmVmLmN1cnJlbnQgPSBuZXN0ZWQgJiYgaXNNYWluS2V5ID8gbnVsbCA6IGV2ZW50LmtleTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5lc3RlZCkge1xuICAgICAgICAgICAgaWYgKGlzQ3Jvc3NPcGVuS2V5KSB7XG4gICAgICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGdldE1pbkluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgICAgICAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQubmF0aXZlRXZlbnQsICdsaXN0LW5hdmlnYXRpb24nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNNYWluS2V5KSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBzZWxlY3RlZEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghb3BlbiAmJiBvcGVuT25BcnJvd0tleURvd24pIHtcbiAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnbGlzdC1uYXZpZ2F0aW9uJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvbktleURvd24oZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uRm9jdXMoKSB7XG4gICAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIG9uTmF2aWdhdGUobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblBvaW50ZXJEb3duOiBjaGVja1ZpcnR1YWxQb2ludGVyLFxuICAgICAgICBvbk1vdXNlRG93bjogY2hlY2tWaXJ0dWFsTW91c2UsXG4gICAgICAgIG9uQ2xpY2s6IGNoZWNrVmlydHVhbE1vdXNlXG4gICAgICB9LFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgJ2FyaWEtb3JpZW50YXRpb24nOiBvcmllbnRhdGlvbiA9PT0gJ2JvdGgnID8gdW5kZWZpbmVkIDogb3JpZW50YXRpb24sXG4gICAgICAgIC4uLighaXNUeXBlYWJsZUNvbWJvYm94KGRvbVJlZmVyZW5jZSkgJiYgYXJpYUFjdGl2ZURlc2NlbmRhbnRQcm9wKSxcbiAgICAgICAgb25LZXlEb3duLFxuICAgICAgICBvblBvaW50ZXJNb3ZlKCkge1xuICAgICAgICAgIGlzUG9pbnRlck1vZGFsaXR5UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaXRlbVxuICAgIH07XG4gIH0sIFtkb21SZWZlcmVuY2UsIHJlZnMsIGFjdGl2ZUlkLCB2aXJ0dWFsSWQsIGRpc2FibGVkSW5kaWNlc1JlZiwgbGF0ZXN0T3BlblJlZiwgbGlzdFJlZiwgZW5hYmxlZCwgb3JpZW50YXRpb24sIHJ0bCwgdmlydHVhbCwgb3BlbiwgaGFzQWN0aXZlSW5kZXgsIG5lc3RlZCwgc2VsZWN0ZWRJbmRleCwgb3Blbk9uQXJyb3dLZXlEb3duLCBhbGxvd0VzY2FwZSwgY29scywgbG9vcCwgZm9jdXNJdGVtT25PcGVuLCBvbk5hdmlnYXRlLCBvbk9wZW5DaGFuZ2UsIGl0ZW0sIHRyZWUsIHZpcnR1YWxJdGVtUmVmXSk7XG59XG5cbmNvbnN0IGNvbXBvbmVudFJvbGVUb0FyaWFSb2xlTWFwID0gLyojX19QVVJFX18qL25ldyBNYXAoW1snc2VsZWN0JywgJ2xpc3Rib3gnXSwgWydjb21ib2JveCcsICdsaXN0Ym94J10sIFsnbGFiZWwnLCBmYWxzZV1dKTtcblxuLyoqXG4gKiBBZGRzIGJhc2Ugc2NyZWVuIHJlYWRlciBwcm9wcyB0byB0aGUgcmVmZXJlbmNlIGFuZCBmbG9hdGluZyBlbGVtZW50cyBmb3IgYVxuICogZ2l2ZW4gZmxvYXRpbmcgZWxlbWVudCBgcm9sZWAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlUm9sZVxuICovXG5mdW5jdGlvbiB1c2VSb2xlKGNvbnRleHQsIHByb3BzKSB7XG4gIHZhciBfY29tcG9uZW50Um9sZVRvQXJpYVI7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBmbG9hdGluZ0lkXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgcm9sZSA9ICdkaWFsb2cnXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgYXJpYVJvbGUgPSAoX2NvbXBvbmVudFJvbGVUb0FyaWFSID0gY29tcG9uZW50Um9sZVRvQXJpYVJvbGVNYXAuZ2V0KHJvbGUpKSAhPSBudWxsID8gX2NvbXBvbmVudFJvbGVUb0FyaWFSIDogcm9sZTtcbiAgY29uc3QgcmVmZXJlbmNlSWQgPSB1c2VJZCgpO1xuICBjb25zdCBwYXJlbnRJZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCk7XG4gIGNvbnN0IGlzTmVzdGVkID0gcGFyZW50SWQgIT0gbnVsbDtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuIHt9O1xuICAgIGNvbnN0IGZsb2F0aW5nUHJvcHMgPSB7XG4gICAgICBpZDogZmxvYXRpbmdJZCxcbiAgICAgIC4uLihhcmlhUm9sZSAmJiB7XG4gICAgICAgIHJvbGU6IGFyaWFSb2xlXG4gICAgICB9KVxuICAgIH07XG4gICAgaWYgKGFyaWFSb2xlID09PSAndG9vbHRpcCcgfHwgcm9sZSA9PT0gJ2xhYmVsJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgICAgW1wiYXJpYS1cIiArIChyb2xlID09PSAnbGFiZWwnID8gJ2xhYmVsbGVkYnknIDogJ2Rlc2NyaWJlZGJ5JyldOiBvcGVuID8gZmxvYXRpbmdJZCA6IHVuZGVmaW5lZFxuICAgICAgICB9LFxuICAgICAgICBmbG9hdGluZzogZmxvYXRpbmdQcm9wc1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICAnYXJpYS1leHBhbmRlZCc6IG9wZW4gPyAndHJ1ZScgOiAnZmFsc2UnLFxuICAgICAgICAnYXJpYS1oYXNwb3B1cCc6IGFyaWFSb2xlID09PSAnYWxlcnRkaWFsb2cnID8gJ2RpYWxvZycgOiBhcmlhUm9sZSxcbiAgICAgICAgJ2FyaWEtY29udHJvbHMnOiBvcGVuID8gZmxvYXRpbmdJZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgLi4uKGFyaWFSb2xlID09PSAnbGlzdGJveCcgJiYge1xuICAgICAgICAgIHJvbGU6ICdjb21ib2JveCdcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihhcmlhUm9sZSA9PT0gJ21lbnUnICYmIHtcbiAgICAgICAgICBpZDogcmVmZXJlbmNlSWRcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihhcmlhUm9sZSA9PT0gJ21lbnUnICYmIGlzTmVzdGVkICYmIHtcbiAgICAgICAgICByb2xlOiAnbWVudWl0ZW0nXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocm9sZSA9PT0gJ3NlbGVjdCcgJiYge1xuICAgICAgICAgICdhcmlhLWF1dG9jb21wbGV0ZSc6ICdub25lJ1xuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJvbGUgPT09ICdjb21ib2JveCcgJiYge1xuICAgICAgICAgICdhcmlhLWF1dG9jb21wbGV0ZSc6ICdsaXN0J1xuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIGZsb2F0aW5nOiB7XG4gICAgICAgIC4uLmZsb2F0aW5nUHJvcHMsXG4gICAgICAgIC4uLihhcmlhUm9sZSA9PT0gJ21lbnUnICYmIHtcbiAgICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogcmVmZXJlbmNlSWRcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBpdGVtKF9yZWYpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBhY3RpdmUsXG4gICAgICAgICAgc2VsZWN0ZWRcbiAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgIGNvbnN0IGNvbW1vblByb3BzID0ge1xuICAgICAgICAgIHJvbGU6ICdvcHRpb24nLFxuICAgICAgICAgIC4uLihhY3RpdmUgJiYge1xuICAgICAgICAgICAgaWQ6IGZsb2F0aW5nSWQgKyBcIi1vcHRpb25cIlxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRm9yIGBtZW51YCwgd2UgYXJlIHVuYWJsZSB0byB0ZWxsIGlmIHRoZSBpdGVtIGlzIGEgYG1lbnVpdGVtcmFkaW9gXG4gICAgICAgIC8vIG9yIGBtZW51aXRlbWNoZWNrYm94YC4gRm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHJlYXNvbnMsIGFsc29cbiAgICAgICAgLy8gYXZvaWQgZGVmYXVsdGluZyB0byBgbWVudWl0ZW1gIGFzIGl0IG1heSBvdmVyd3JpdGUgY3VzdG9tIHJvbGUgcHJvcHMuXG4gICAgICAgIHN3aXRjaCAocm9sZSkge1xuICAgICAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5jb21tb25Qcm9wcyxcbiAgICAgICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiBhY3RpdmUgJiYgc2VsZWN0ZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgY2FzZSAnY29tYm9ib3gnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmNvbW1vblByb3BzLFxuICAgICAgICAgICAgICAgIC4uLihhY3RpdmUgJiYge1xuICAgICAgICAgICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiB0cnVlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIHJvbGUsIGFyaWFSb2xlLCBvcGVuLCBmbG9hdGluZ0lkLCByZWZlcmVuY2VJZCwgaXNOZXN0ZWRdKTtcbn1cblxuLy8gQ29udmVydHMgYSBKUyBzdHlsZSBrZXkgbGlrZSBgYmFja2dyb3VuZENvbG9yYCB0byBhIENTUyB0cmFuc2l0aW9uLXByb3BlcnR5XG4vLyBsaWtlIGBiYWNrZ3JvdW5kLWNvbG9yYC5cbmNvbnN0IGNhbWVsQ2FzZVRvS2ViYWJDYXNlID0gc3RyID0+IHN0ci5yZXBsYWNlKC9bQS1aXSsoPyFbYS16XSl8W0EtWl0vZywgKCQsIG9mcykgPT4gKG9mcyA/ICctJyA6ICcnKSArICQudG9Mb3dlckNhc2UoKSk7XG5mdW5jdGlvbiBleGVjV2l0aEFyZ3NPclJldHVybih2YWx1ZU9yRm4sIGFyZ3MpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZU9yRm4gPT09ICdmdW5jdGlvbicgPyB2YWx1ZU9yRm4oYXJncykgOiB2YWx1ZU9yRm47XG59XG5mdW5jdGlvbiB1c2VEZWxheVVubW91bnQob3BlbiwgZHVyYXRpb25Ncykge1xuICBjb25zdCBbaXNNb3VudGVkLCBzZXRJc01vdW50ZWRdID0gUmVhY3QudXNlU3RhdGUob3Blbik7XG4gIGlmIChvcGVuICYmICFpc01vdW50ZWQpIHtcbiAgICBzZXRJc01vdW50ZWQodHJ1ZSk7XG4gIH1cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW9wZW4pIHtcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHNldElzTW91bnRlZChmYWxzZSksIGR1cmF0aW9uTXMpO1xuICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB9XG4gIH0sIFtvcGVuLCBkdXJhdGlvbk1zXSk7XG4gIHJldHVybiBpc01vdW50ZWQ7XG59XG4vKipcbiAqIFByb3ZpZGVzIGEgc3RhdHVzIHN0cmluZyB0byBhcHBseSBDU1MgdHJhbnNpdGlvbnMgdG8gYSBmbG9hdGluZyBlbGVtZW50LFxuICogY29ycmVjdGx5IGhhbmRsaW5nIHBsYWNlbWVudC1hd2FyZSB0cmFuc2l0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VUcmFuc2l0aW9uI3VzZXRyYW5zaXRpb25zdGF0dXNcbiAqL1xuZnVuY3Rpb24gdXNlVHJhbnNpdGlvblN0YXR1cyhjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGZsb2F0aW5nXG4gICAgfVxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGR1cmF0aW9uID0gMjUwXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgaXNOdW1iZXJEdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ251bWJlcic7XG4gIGNvbnN0IGNsb3NlRHVyYXRpb24gPSAoaXNOdW1iZXJEdXJhdGlvbiA/IGR1cmF0aW9uIDogZHVyYXRpb24uY2xvc2UpIHx8IDA7XG4gIGNvbnN0IFtpbml0aWF0ZWQsIHNldEluaXRpYXRlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzdGF0dXMsIHNldFN0YXR1c10gPSBSZWFjdC51c2VTdGF0ZSgndW5tb3VudGVkJyk7XG4gIGNvbnN0IGlzTW91bnRlZCA9IHVzZURlbGF5VW5tb3VudChvcGVuLCBjbG9zZUR1cmF0aW9uKTtcblxuICAvLyBgaW5pdGlhdGVkYCBjaGVjayBwcmV2ZW50cyB0aGlzIGBzZXRTdGF0ZWAgY2FsbCBmcm9tIGJyZWFraW5nXG4gIC8vIDxGbG9hdGluZ1BvcnRhbCAvPi4gVGhpcyBjYWxsIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgc3Vic2VxdWVudCBvcGVuc1xuICAvLyBhZnRlciB0aGUgaW5pdGlhbCBvbmUgYWxsb3dzIHRoZSBjb3JyZWN0IHNpZGUgYW5pbWF0aW9uIHRvIHBsYXkgd2hlbiB0aGVcbiAgLy8gcGxhY2VtZW50IGhhcyBjaGFuZ2VkLlxuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKGluaXRpYXRlZCAmJiAhaXNNb3VudGVkKSB7XG4gICAgICBzZXRTdGF0dXMoJ3VubW91bnRlZCcpO1xuICAgIH1cbiAgfSwgW2luaXRpYXRlZCwgaXNNb3VudGVkXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWZsb2F0aW5nKSByZXR1cm47XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIHNldFN0YXR1cygnaW5pdGlhbCcpO1xuICAgICAgY29uc3QgZnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBzZXRTdGF0dXMoJ29wZW4nKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWUpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SW5pdGlhdGVkKHRydWUpO1xuICAgICAgc2V0U3RhdHVzKCdjbG9zZScpO1xuICAgIH1cbiAgfSwgW29wZW4sIGZsb2F0aW5nXSk7XG4gIHJldHVybiB7XG4gICAgaXNNb3VudGVkLFxuICAgIHN0YXR1c1xuICB9O1xufVxuLyoqXG4gKiBQcm92aWRlcyBzdHlsZXMgdG8gYXBwbHkgQ1NTIHRyYW5zaXRpb25zIHRvIGEgZmxvYXRpbmcgZWxlbWVudCwgY29ycmVjdGx5XG4gKiBoYW5kbGluZyBwbGFjZW1lbnQtYXdhcmUgdHJhbnNpdGlvbnMuIFdyYXBwZXIgYXJvdW5kIGB1c2VUcmFuc2l0aW9uU3RhdHVzYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VUcmFuc2l0aW9uI3VzZXRyYW5zaXRpb25zdHlsZXNcbiAqL1xuZnVuY3Rpb24gdXNlVHJhbnNpdGlvblN0eWxlcyhjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGluaXRpYWw6IHVuc3RhYmxlX2luaXRpYWwgPSB7XG4gICAgICBvcGFjaXR5OiAwXG4gICAgfSxcbiAgICBvcGVuOiB1bnN0YWJsZV9vcGVuLFxuICAgIGNsb3NlOiB1bnN0YWJsZV9jbG9zZSxcbiAgICBjb21tb246IHVuc3RhYmxlX2NvbW1vbixcbiAgICBkdXJhdGlvbiA9IDI1MFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHBsYWNlbWVudCA9IGNvbnRleHQucGxhY2VtZW50O1xuICBjb25zdCBzaWRlID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIGNvbnN0IGZuQXJncyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBzaWRlLFxuICAgIHBsYWNlbWVudFxuICB9KSwgW3NpZGUsIHBsYWNlbWVudF0pO1xuICBjb25zdCBpc051bWJlckR1cmF0aW9uID0gdHlwZW9mIGR1cmF0aW9uID09PSAnbnVtYmVyJztcbiAgY29uc3Qgb3BlbkR1cmF0aW9uID0gKGlzTnVtYmVyRHVyYXRpb24gPyBkdXJhdGlvbiA6IGR1cmF0aW9uLm9wZW4pIHx8IDA7XG4gIGNvbnN0IGNsb3NlRHVyYXRpb24gPSAoaXNOdW1iZXJEdXJhdGlvbiA/IGR1cmF0aW9uIDogZHVyYXRpb24uY2xvc2UpIHx8IDA7XG4gIGNvbnN0IFtzdHlsZXMsIHNldFN0eWxlc10gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiAoe1xuICAgIC4uLmV4ZWNXaXRoQXJnc09yUmV0dXJuKHVuc3RhYmxlX2NvbW1vbiwgZm5BcmdzKSxcbiAgICAuLi5leGVjV2l0aEFyZ3NPclJldHVybih1bnN0YWJsZV9pbml0aWFsLCBmbkFyZ3MpXG4gIH0pKTtcbiAgY29uc3Qge1xuICAgIGlzTW91bnRlZCxcbiAgICBzdGF0dXNcbiAgfSA9IHVzZVRyYW5zaXRpb25TdGF0dXMoY29udGV4dCwge1xuICAgIGR1cmF0aW9uXG4gIH0pO1xuICBjb25zdCBpbml0aWFsUmVmID0gdXNlTGF0ZXN0UmVmKHVuc3RhYmxlX2luaXRpYWwpO1xuICBjb25zdCBvcGVuUmVmID0gdXNlTGF0ZXN0UmVmKHVuc3RhYmxlX29wZW4pO1xuICBjb25zdCBjbG9zZVJlZiA9IHVzZUxhdGVzdFJlZih1bnN0YWJsZV9jbG9zZSk7XG4gIGNvbnN0IGNvbW1vblJlZiA9IHVzZUxhdGVzdFJlZih1bnN0YWJsZV9jb21tb24pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbFN0eWxlcyA9IGV4ZWNXaXRoQXJnc09yUmV0dXJuKGluaXRpYWxSZWYuY3VycmVudCwgZm5BcmdzKTtcbiAgICBjb25zdCBjbG9zZVN0eWxlcyA9IGV4ZWNXaXRoQXJnc09yUmV0dXJuKGNsb3NlUmVmLmN1cnJlbnQsIGZuQXJncyk7XG4gICAgY29uc3QgY29tbW9uU3R5bGVzID0gZXhlY1dpdGhBcmdzT3JSZXR1cm4oY29tbW9uUmVmLmN1cnJlbnQsIGZuQXJncyk7XG4gICAgY29uc3Qgb3BlblN0eWxlcyA9IGV4ZWNXaXRoQXJnc09yUmV0dXJuKG9wZW5SZWYuY3VycmVudCwgZm5BcmdzKSB8fCBPYmplY3Qua2V5cyhpbml0aWFsU3R5bGVzKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICBhY2Nba2V5XSA9ICcnO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgaWYgKHN0YXR1cyA9PT0gJ2luaXRpYWwnKSB7XG4gICAgICBzZXRTdHlsZXMoc3R5bGVzID0+ICh7XG4gICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogc3R5bGVzLnRyYW5zaXRpb25Qcm9wZXJ0eSxcbiAgICAgICAgLi4uY29tbW9uU3R5bGVzLFxuICAgICAgICAuLi5pbml0aWFsU3R5bGVzXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09ICdvcGVuJykge1xuICAgICAgc2V0U3R5bGVzKHtcbiAgICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiBPYmplY3Qua2V5cyhvcGVuU3R5bGVzKS5tYXAoY2FtZWxDYXNlVG9LZWJhYkNhc2UpLmpvaW4oJywnKSxcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBvcGVuRHVyYXRpb24gKyBcIm1zXCIsXG4gICAgICAgIC4uLmNvbW1vblN0eWxlcyxcbiAgICAgICAgLi4ub3BlblN0eWxlc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09ICdjbG9zZScpIHtcbiAgICAgIGNvbnN0IHN0eWxlcyA9IGNsb3NlU3R5bGVzIHx8IGluaXRpYWxTdHlsZXM7XG4gICAgICBzZXRTdHlsZXMoe1xuICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6IE9iamVjdC5rZXlzKHN0eWxlcykubWFwKGNhbWVsQ2FzZVRvS2ViYWJDYXNlKS5qb2luKCcsJyksXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogY2xvc2VEdXJhdGlvbiArIFwibXNcIixcbiAgICAgICAgLi4uY29tbW9uU3R5bGVzLFxuICAgICAgICAuLi5zdHlsZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2Nsb3NlRHVyYXRpb24sIGNsb3NlUmVmLCBpbml0aWFsUmVmLCBvcGVuUmVmLCBjb21tb25SZWYsIG9wZW5EdXJhdGlvbiwgc3RhdHVzLCBmbkFyZ3NdKTtcbiAgcmV0dXJuIHtcbiAgICBpc01vdW50ZWQsXG4gICAgc3R5bGVzXG4gIH07XG59XG5cbi8qKlxuICogUHJvdmlkZXMgYSBtYXRjaGluZyBjYWxsYmFjayB0aGF0IGNhbiBiZSB1c2VkIHRvIGZvY3VzIGFuIGl0ZW0gYXMgdGhlIHVzZXJcbiAqIHR5cGVzLCBvZnRlbiB1c2VkIGluIHRhbmRlbSB3aXRoIGB1c2VMaXN0TmF2aWdhdGlvbigpYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VUeXBlYWhlYWRcbiAqL1xuZnVuY3Rpb24gdXNlVHlwZWFoZWFkKGNvbnRleHQsIHByb3BzKSB7XG4gIHZhciBfcmVmO1xuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBkYXRhUmVmXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgbGlzdFJlZixcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvbk1hdGNoOiB1bnN0YWJsZV9vbk1hdGNoLFxuICAgIG9uVHlwaW5nQ2hhbmdlOiB1bnN0YWJsZV9vblR5cGluZ0NoYW5nZSxcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBmaW5kTWF0Y2ggPSBudWxsLFxuICAgIHJlc2V0TXMgPSA3NTAsXG4gICAgaWdub3JlS2V5cyA9IFtdLFxuICAgIHNlbGVjdGVkSW5kZXggPSBudWxsXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgdGltZW91dElkUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IHN0cmluZ1JlZiA9IFJlYWN0LnVzZVJlZignJyk7XG4gIGNvbnN0IHByZXZJbmRleFJlZiA9IFJlYWN0LnVzZVJlZigoX3JlZiA9IHNlbGVjdGVkSW5kZXggIT0gbnVsbCA/IHNlbGVjdGVkSW5kZXggOiBhY3RpdmVJbmRleCkgIT0gbnVsbCA/IF9yZWYgOiAtMSk7XG4gIGNvbnN0IG1hdGNoSW5kZXhSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IG9uTWF0Y2ggPSB1c2VFZmZlY3RFdmVudCh1bnN0YWJsZV9vbk1hdGNoKTtcbiAgY29uc3Qgb25UeXBpbmdDaGFuZ2UgPSB1c2VFZmZlY3RFdmVudCh1bnN0YWJsZV9vblR5cGluZ0NoYW5nZSk7XG4gIGNvbnN0IGZpbmRNYXRjaFJlZiA9IHVzZUxhdGVzdFJlZihmaW5kTWF0Y2gpO1xuICBjb25zdCBpZ25vcmVLZXlzUmVmID0gdXNlTGF0ZXN0UmVmKGlnbm9yZUtleXMpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWRSZWYuY3VycmVudCk7XG4gICAgICBtYXRjaEluZGV4UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICB9XG4gIH0sIFtvcGVuXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICAvLyBTeW5jIGFycm93IGtleSBuYXZpZ2F0aW9uIGJ1dCBub3QgdHlwZWFoZWFkIG5hdmlnYXRpb24uXG4gICAgaWYgKG9wZW4gJiYgc3RyaW5nUmVmLmN1cnJlbnQgPT09ICcnKSB7XG4gICAgICB2YXIgX3JlZjI7XG4gICAgICBwcmV2SW5kZXhSZWYuY3VycmVudCA9IChfcmVmMiA9IHNlbGVjdGVkSW5kZXggIT0gbnVsbCA/IHNlbGVjdGVkSW5kZXggOiBhY3RpdmVJbmRleCkgIT0gbnVsbCA/IF9yZWYyIDogLTE7XG4gICAgfVxuICB9LCBbb3Blbiwgc2VsZWN0ZWRJbmRleCwgYWN0aXZlSW5kZXhdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRUeXBpbmdDaGFuZ2UodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBpZiAoIWRhdGFSZWYuY3VycmVudC50eXBpbmcpIHtcbiAgICAgICAgICBkYXRhUmVmLmN1cnJlbnQudHlwaW5nID0gdmFsdWU7XG4gICAgICAgICAgb25UeXBpbmdDaGFuZ2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGF0YVJlZi5jdXJyZW50LnR5cGluZykge1xuICAgICAgICAgIGRhdGFSZWYuY3VycmVudC50eXBpbmcgPSB2YWx1ZTtcbiAgICAgICAgICBvblR5cGluZ0NoYW5nZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TWF0Y2hpbmdJbmRleChsaXN0LCBvcmRlcmVkTGlzdCwgc3RyaW5nKSB7XG4gICAgICBjb25zdCBzdHIgPSBmaW5kTWF0Y2hSZWYuY3VycmVudCA/IGZpbmRNYXRjaFJlZi5jdXJyZW50KG9yZGVyZWRMaXN0LCBzdHJpbmcpIDogb3JkZXJlZExpc3QuZmluZCh0ZXh0ID0+ICh0ZXh0ID09IG51bGwgPyB2b2lkIDAgOiB0ZXh0LnRvTG9jYWxlTG93ZXJDYXNlKCkuaW5kZXhPZihzdHJpbmcudG9Mb2NhbGVMb3dlckNhc2UoKSkpID09PSAwKTtcbiAgICAgIHJldHVybiBzdHIgPyBsaXN0LmluZGV4T2Yoc3RyKSA6IC0xO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbktleURvd24oZXZlbnQpIHtcbiAgICAgIGNvbnN0IGxpc3RDb250ZW50ID0gbGlzdFJlZi5jdXJyZW50O1xuICAgICAgaWYgKHN0cmluZ1JlZi5jdXJyZW50Lmxlbmd0aCA+IDAgJiYgc3RyaW5nUmVmLmN1cnJlbnRbMF0gIT09ICcgJykge1xuICAgICAgICBpZiAoZ2V0TWF0Y2hpbmdJbmRleChsaXN0Q29udGVudCwgbGlzdENvbnRlbnQsIHN0cmluZ1JlZi5jdXJyZW50KSA9PT0gLTEpIHtcbiAgICAgICAgICBzZXRUeXBpbmdDaGFuZ2UoZmFsc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gJyAnKSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxpc3RDb250ZW50ID09IG51bGwgfHwgaWdub3JlS2V5c1JlZi5jdXJyZW50LmluY2x1ZGVzKGV2ZW50LmtleSkgfHxcbiAgICAgIC8vIENoYXJhY3RlciBrZXkuXG4gICAgICBldmVudC5rZXkubGVuZ3RoICE9PSAxIHx8XG4gICAgICAvLyBNb2RpZmllciBrZXkuXG4gICAgICBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvcGVuICYmIGV2ZW50LmtleSAhPT0gJyAnKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIHNldFR5cGluZ0NoYW5nZSh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQmFpbCBvdXQgaWYgdGhlIGxpc3QgY29udGFpbnMgYSB3b3JkIGxpa2UgXCJsbGFtYVwiIG9yIFwiYWFyb25cIi4gVE9ETzpcbiAgICAgIC8vIGFsbG93IGl0IGluIHRoaXMgY2FzZSwgdG9vLlxuICAgICAgY29uc3QgYWxsb3dSYXBpZFN1Y2Nlc3Npb25PZkZpcnN0TGV0dGVyID0gbGlzdENvbnRlbnQuZXZlcnkodGV4dCA9PiB7XG4gICAgICAgIHZhciBfdGV4dCQsIF90ZXh0JDI7XG4gICAgICAgIHJldHVybiB0ZXh0ID8gKChfdGV4dCQgPSB0ZXh0WzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3RleHQkLnRvTG9jYWxlTG93ZXJDYXNlKCkpICE9PSAoKF90ZXh0JDIgPSB0ZXh0WzFdKSA9PSBudWxsID8gdm9pZCAwIDogX3RleHQkMi50b0xvY2FsZUxvd2VyQ2FzZSgpKSA6IHRydWU7XG4gICAgICB9KTtcblxuICAgICAgLy8gQWxsb3dzIHRoZSB1c2VyIHRvIGN5Y2xlIHRocm91Z2ggaXRlbXMgdGhhdCBzdGFydCB3aXRoIHRoZSBzYW1lIGxldHRlclxuICAgICAgLy8gaW4gcmFwaWQgc3VjY2Vzc2lvbi5cbiAgICAgIGlmIChhbGxvd1JhcGlkU3VjY2Vzc2lvbk9mRmlyc3RMZXR0ZXIgJiYgc3RyaW5nUmVmLmN1cnJlbnQgPT09IGV2ZW50LmtleSkge1xuICAgICAgICBzdHJpbmdSZWYuY3VycmVudCA9ICcnO1xuICAgICAgICBwcmV2SW5kZXhSZWYuY3VycmVudCA9IG1hdGNoSW5kZXhSZWYuY3VycmVudDtcbiAgICAgIH1cbiAgICAgIHN0cmluZ1JlZi5jdXJyZW50ICs9IGV2ZW50LmtleTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWRSZWYuY3VycmVudCk7XG4gICAgICB0aW1lb3V0SWRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzdHJpbmdSZWYuY3VycmVudCA9ICcnO1xuICAgICAgICBwcmV2SW5kZXhSZWYuY3VycmVudCA9IG1hdGNoSW5kZXhSZWYuY3VycmVudDtcbiAgICAgICAgc2V0VHlwaW5nQ2hhbmdlKGZhbHNlKTtcbiAgICAgIH0sIHJlc2V0TXMpO1xuICAgICAgY29uc3QgcHJldkluZGV4ID0gcHJldkluZGV4UmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBpbmRleCA9IGdldE1hdGNoaW5nSW5kZXgobGlzdENvbnRlbnQsIFsuLi5saXN0Q29udGVudC5zbGljZSgocHJldkluZGV4IHx8IDApICsgMSksIC4uLmxpc3RDb250ZW50LnNsaWNlKDAsIChwcmV2SW5kZXggfHwgMCkgKyAxKV0sIHN0cmluZ1JlZi5jdXJyZW50KTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgb25NYXRjaChpbmRleCk7XG4gICAgICAgIG1hdGNoSW5kZXhSZWYuY3VycmVudCA9IGluZGV4O1xuICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgIT09ICcgJykge1xuICAgICAgICBzdHJpbmdSZWYuY3VycmVudCA9ICcnO1xuICAgICAgICBzZXRUeXBpbmdDaGFuZ2UoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgIG9uS2V5RG93blxuICAgICAgfSxcbiAgICAgIGZsb2F0aW5nOiB7XG4gICAgICAgIG9uS2V5RG93bixcbiAgICAgICAgb25LZXlVcChldmVudCkge1xuICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICcgJykge1xuICAgICAgICAgICAgc2V0VHlwaW5nQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgb3BlbiwgZGF0YVJlZiwgbGlzdFJlZiwgcmVzZXRNcywgaWdub3JlS2V5c1JlZiwgZmluZE1hdGNoUmVmLCBvbk1hdGNoLCBvblR5cGluZ0NoYW5nZV0pO1xufVxuXG5mdW5jdGlvbiBnZXRBcmdzV2l0aEN1c3RvbUZsb2F0aW5nSGVpZ2h0KHN0YXRlLCBoZWlnaHQpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICByZWN0czoge1xuICAgICAgLi4uc3RhdGUucmVjdHMsXG4gICAgICBmbG9hdGluZzoge1xuICAgICAgICAuLi5zdGF0ZS5yZWN0cy5mbG9hdGluZyxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuLyoqXG4gKiBQb3NpdGlvbnMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc3VjaCB0aGF0IGFuIGlubmVyIGVsZW1lbnQgaW5zaWRlXG4gKiBvZiBpdCBpcyBhbmNob3JlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5uZXJcbiAqL1xuY29uc3QgaW5uZXIgPSBwcm9wcyA9PiAoe1xuICBuYW1lOiAnaW5uZXInLFxuICBvcHRpb25zOiBwcm9wcyxcbiAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBsaXN0UmVmLFxuICAgICAgb3ZlcmZsb3dSZWYsXG4gICAgICBvbkZhbGxiYWNrQ2hhbmdlLFxuICAgICAgb2Zmc2V0OiBpbm5lck9mZnNldCA9IDAsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBtaW5JdGVtc1Zpc2libGUgPSA0LFxuICAgICAgcmVmZXJlbmNlT3ZlcmZsb3dUaHJlc2hvbGQgPSAwLFxuICAgICAgc2Nyb2xsUmVmLFxuICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlY3RzLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgZmxvYXRpbmdcbiAgICAgIH1cbiAgICB9ID0gc3RhdGU7XG4gICAgY29uc3QgaXRlbSA9IGxpc3RSZWYuY3VycmVudFtpbmRleF07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKCFzdGF0ZS5wbGFjZW1lbnQuc3RhcnRzV2l0aCgnYm90dG9tJykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFsnRmxvYXRpbmcgVUk6IGBwbGFjZW1lbnRgIHNpZGUgbXVzdCBiZSBcImJvdHRvbVwiIHdoZW4gdXNpbmcgdGhlJywgJ2Bpbm5lcmAgbWlkZGxld2FyZS4nXS5qb2luKCcgJykpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgbmV4dEFyZ3MgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIC4uLihhd2FpdCBvZmZzZXQoLWl0ZW0ub2Zmc2V0VG9wIC0gZmxvYXRpbmcuY2xpZW50VG9wIC0gcmVjdHMucmVmZXJlbmNlLmhlaWdodCAvIDIgLSBpdGVtLm9mZnNldEhlaWdodCAvIDIgLSBpbm5lck9mZnNldCkuZm4oc3RhdGUpKVxuICAgIH07XG4gICAgY29uc3QgZWwgPSAoc2Nyb2xsUmVmID09IG51bGwgPyB2b2lkIDAgOiBzY3JvbGxSZWYuY3VycmVudCkgfHwgZmxvYXRpbmc7XG4gICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhnZXRBcmdzV2l0aEN1c3RvbUZsb2F0aW5nSGVpZ2h0KG5leHRBcmdzLCBlbC5zY3JvbGxIZWlnaHQpLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgIGNvbnN0IHJlZk92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3cobmV4dEFyZ3MsIHtcbiAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyxcbiAgICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICAgIH0pO1xuICAgIGNvbnN0IGRpZmZZID0gTWF0aC5tYXgoMCwgb3ZlcmZsb3cudG9wKTtcbiAgICBjb25zdCBuZXh0WSA9IG5leHRBcmdzLnkgKyBkaWZmWTtcbiAgICBjb25zdCBtYXhIZWlnaHQgPSBNYXRoLm1heCgwLCBlbC5zY3JvbGxIZWlnaHQgLSBkaWZmWSAtIE1hdGgubWF4KDAsIG92ZXJmbG93LmJvdHRvbSkpO1xuICAgIGVsLnN0eWxlLm1heEhlaWdodCA9IG1heEhlaWdodCArIFwicHhcIjtcbiAgICBlbC5zY3JvbGxUb3AgPSBkaWZmWTtcblxuICAgIC8vIFRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UsIGZhbGxiYWNrIHRvIHN0YW5kYXJkIGFuY2hvcmVkIHBvc2l0aW9uaW5nXG4gICAgaWYgKG9uRmFsbGJhY2tDaGFuZ2UpIHtcbiAgICAgIGlmIChlbC5vZmZzZXRIZWlnaHQgPCBpdGVtLm9mZnNldEhlaWdodCAqIE1hdGgubWluKG1pbkl0ZW1zVmlzaWJsZSwgbGlzdFJlZi5jdXJyZW50Lmxlbmd0aCAtIDEpIC0gMSB8fCByZWZPdmVyZmxvdy50b3AgPj0gLXJlZmVyZW5jZU92ZXJmbG93VGhyZXNob2xkIHx8IHJlZk92ZXJmbG93LmJvdHRvbSA+PSAtcmVmZXJlbmNlT3ZlcmZsb3dUaHJlc2hvbGQpIHtcbiAgICAgICAgZmx1c2hTeW5jKCgpID0+IG9uRmFsbGJhY2tDaGFuZ2UodHJ1ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmx1c2hTeW5jKCgpID0+IG9uRmFsbGJhY2tDaGFuZ2UoZmFsc2UpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG92ZXJmbG93UmVmKSB7XG4gICAgICBvdmVyZmxvd1JlZi5jdXJyZW50ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodCh7XG4gICAgICAgIC4uLm5leHRBcmdzLFxuICAgICAgICB5OiBuZXh0WVxuICAgICAgfSwgZWwub2Zmc2V0SGVpZ2h0KSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHk6IG5leHRZXG4gICAgfTtcbiAgfVxufSk7XG4vKipcbiAqIENoYW5nZXMgdGhlIGBpbm5lcmAgbWlkZGxld2FyZSdzIGBvZmZzZXRgIHVwb24gYSBgd2hlZWxgIGV2ZW50IHRvXG4gKiBleHBhbmQgdGhlIGZsb2F0aW5nIGVsZW1lbnQncyBoZWlnaHQsIHJldmVhbGluZyBtb3JlIGxpc3QgaXRlbXMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5uZXJcbiAqL1xuZnVuY3Rpb24gdXNlSW5uZXJPZmZzZXQoY29udGV4dCwgcHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgZWxlbWVudHNcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBvdmVyZmxvd1JlZixcbiAgICBzY3JvbGxSZWYsXG4gICAgb25DaGFuZ2U6IHVuc3RhYmxlX29uQ2hhbmdlXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qgb25DaGFuZ2UgPSB1c2VFZmZlY3RFdmVudCh1bnN0YWJsZV9vbkNoYW5nZSk7XG4gIGNvbnN0IGNvbnRyb2xsZWRTY3JvbGxpbmdSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBwcmV2U2Nyb2xsVG9wUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBpbml0aWFsT3ZlcmZsb3dSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uV2hlZWwoZSkge1xuICAgICAgaWYgKGUuY3RybEtleSB8fCAhZWwgfHwgb3ZlcmZsb3dSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRZID0gZS5kZWx0YVk7XG4gICAgICBjb25zdCBpc0F0VG9wID0gb3ZlcmZsb3dSZWYuY3VycmVudC50b3AgPj0gLTAuNTtcbiAgICAgIGNvbnN0IGlzQXRCb3R0b20gPSBvdmVyZmxvd1JlZi5jdXJyZW50LmJvdHRvbSA+PSAtMC41O1xuICAgICAgY29uc3QgcmVtYWluaW5nU2Nyb2xsID0gZWwuc2Nyb2xsSGVpZ2h0IC0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgY29uc3Qgc2lnbiA9IGRZIDwgMCA/IC0xIDogMTtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IGRZIDwgMCA/ICdtYXgnIDogJ21pbic7XG4gICAgICBpZiAoZWwuc2Nyb2xsSGVpZ2h0IDw9IGVsLmNsaWVudEhlaWdodCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXRUb3AgJiYgZFkgPiAwIHx8ICFpc0F0Qm90dG9tICYmIGRZIDwgMCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgb25DaGFuZ2UoZCA9PiBkICsgTWF0aFttZXRob2RdKGRZLCByZW1haW5pbmdTY3JvbGwgKiBzaWduKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICgvZmlyZWZveC9pLnRlc3QoZ2V0VXNlckFnZW50KCkpKSB7XG4gICAgICAgIC8vIE5lZWRlZCB0byBwcm9wYWdhdGUgc2Nyb2xsaW5nIGR1cmluZyBtb21lbnR1bSBzY3JvbGxpbmcgcGhhc2Ugb25jZVxuICAgICAgICAvLyBpdCBnZXRzIGxpbWl0ZWQgYnkgdGhlIGJvdW5kYXJ5LiBVWCBpbXByb3ZlbWVudCwgbm90IGNyaXRpY2FsLlxuICAgICAgICBlbC5zY3JvbGxUb3AgKz0gZFk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVsID0gKHNjcm9sbFJlZiA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsUmVmLmN1cnJlbnQpIHx8IGVsZW1lbnRzLmZsb2F0aW5nO1xuICAgIGlmIChvcGVuICYmIGVsKSB7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIG9uV2hlZWwpO1xuXG4gICAgICAvLyBXYWl0IGZvciB0aGUgcG9zaXRpb24gdG8gYmUgcmVhZHkuXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgPSBlbC5zY3JvbGxUb3A7XG4gICAgICAgIGlmIChvdmVyZmxvd1JlZi5jdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsT3ZlcmZsb3dSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICAgIC4uLm92ZXJmbG93UmVmLmN1cnJlbnRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHByZXZTY3JvbGxUb3BSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGluaXRpYWxPdmVyZmxvd1JlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBvbldoZWVsKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgb3BlbiwgZWxlbWVudHMuZmxvYXRpbmcsIG92ZXJmbG93UmVmLCBzY3JvbGxSZWYsIG9uQ2hhbmdlXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGZsb2F0aW5nOiB7XG4gICAgICAgIG9uS2V5RG93bigpIHtcbiAgICAgICAgICBjb250cm9sbGVkU2Nyb2xsaW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBvbldoZWVsKCkge1xuICAgICAgICAgIGNvbnRyb2xsZWRTY3JvbGxpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBvblBvaW50ZXJNb3ZlKCkge1xuICAgICAgICAgIGNvbnRyb2xsZWRTY3JvbGxpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBvblNjcm9sbCgpIHtcbiAgICAgICAgICBjb25zdCBlbCA9IChzY3JvbGxSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IHNjcm9sbFJlZi5jdXJyZW50KSB8fCBlbGVtZW50cy5mbG9hdGluZztcbiAgICAgICAgICBpZiAoIW92ZXJmbG93UmVmLmN1cnJlbnQgfHwgIWVsIHx8ICFjb250cm9sbGVkU2Nyb2xsaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXZTY3JvbGxUb3BSZWYuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsRGlmZiA9IGVsLnNjcm9sbFRvcCAtIHByZXZTY3JvbGxUb3BSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChvdmVyZmxvd1JlZi5jdXJyZW50LmJvdHRvbSA8IC0wLjUgJiYgc2Nyb2xsRGlmZiA8IC0xIHx8IG92ZXJmbG93UmVmLmN1cnJlbnQudG9wIDwgLTAuNSAmJiBzY3JvbGxEaWZmID4gMSkge1xuICAgICAgICAgICAgICBmbHVzaFN5bmMoKCkgPT4gb25DaGFuZ2UoZCA9PiBkICsgc2Nyb2xsRGlmZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFtGaXJlZm94XSBXYWl0IGZvciB0aGUgaGVpZ2h0IGNoYW5nZSB0byBoYXZlIGJlZW4gYXBwbGllZC5cbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgcHJldlNjcm9sbFRvcFJlZi5jdXJyZW50ID0gZWwuc2Nyb2xsVG9wO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIG92ZXJmbG93UmVmLCBlbGVtZW50cy5mbG9hdGluZywgc2Nyb2xsUmVmLCBvbkNoYW5nZV0pO1xufVxuXG5mdW5jdGlvbiBpc1BvaW50SW5Qb2x5Z29uKHBvaW50LCBwb2x5Z29uKSB7XG4gIGNvbnN0IFt4LCB5XSA9IHBvaW50O1xuICBsZXQgaXNJbnNpZGUgPSBmYWxzZTtcbiAgY29uc3QgbGVuZ3RoID0gcG9seWdvbi5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gbGVuZ3RoIC0gMTsgaSA8IGxlbmd0aDsgaiA9IGkrKykge1xuICAgIGNvbnN0IFt4aSwgeWldID0gcG9seWdvbltpXSB8fCBbMCwgMF07XG4gICAgY29uc3QgW3hqLCB5al0gPSBwb2x5Z29uW2pdIHx8IFswLCAwXTtcbiAgICBjb25zdCBpbnRlcnNlY3QgPSB5aSA+PSB5ICE9PSB5aiA+PSB5ICYmIHggPD0gKHhqIC0geGkpICogKHkgLSB5aSkgLyAoeWogLSB5aSkgKyB4aTtcbiAgICBpZiAoaW50ZXJzZWN0KSB7XG4gICAgICBpc0luc2lkZSA9ICFpc0luc2lkZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlzSW5zaWRlO1xufVxuZnVuY3Rpb24gaXNJbnNpZGUocG9pbnQsIHJlY3QpIHtcbiAgcmV0dXJuIHBvaW50WzBdID49IHJlY3QueCAmJiBwb2ludFswXSA8PSByZWN0LnggKyByZWN0LndpZHRoICYmIHBvaW50WzFdID49IHJlY3QueSAmJiBwb2ludFsxXSA8PSByZWN0LnkgKyByZWN0LmhlaWdodDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgc2FmZSBwb2x5Z29uIGFyZWEgdGhhdCB0aGUgdXNlciBjYW4gdHJhdmVyc2Ugd2l0aG91dCBjbG9zaW5nIHRoZVxuICogZmxvYXRpbmcgZWxlbWVudCBvbmNlIGxlYXZpbmcgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUhvdmVyI3NhZmVQb2x5Z29uXG4gKi9cbmZ1bmN0aW9uIHNhZmVQb2x5Z29uKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgYnVmZmVyID0gMC41LFxuICAgIGJsb2NrUG9pbnRlckV2ZW50cyA9IGZhbHNlLFxuICAgIHJlcXVpcmVJbnRlbnQgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBsZXQgdGltZW91dElkO1xuICBsZXQgaGFzTGFuZGVkID0gZmFsc2U7XG4gIGxldCBsYXN0WCA9IG51bGw7XG4gIGxldCBsYXN0WSA9IG51bGw7XG4gIGxldCBsYXN0Q3Vyc29yVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICBmdW5jdGlvbiBnZXRDdXJzb3JTcGVlZCh4LCB5KSB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBlbGFwc2VkVGltZSA9IGN1cnJlbnRUaW1lIC0gbGFzdEN1cnNvclRpbWU7XG4gICAgaWYgKGxhc3RYID09PSBudWxsIHx8IGxhc3RZID09PSBudWxsIHx8IGVsYXBzZWRUaW1lID09PSAwKSB7XG4gICAgICBsYXN0WCA9IHg7XG4gICAgICBsYXN0WSA9IHk7XG4gICAgICBsYXN0Q3Vyc29yVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGRlbHRhWCA9IHggLSBsYXN0WDtcbiAgICBjb25zdCBkZWx0YVkgPSB5IC0gbGFzdFk7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZKTtcbiAgICBjb25zdCBzcGVlZCA9IGRpc3RhbmNlIC8gZWxhcHNlZFRpbWU7IC8vIHB4IC8gbXNcblxuICAgIGxhc3RYID0geDtcbiAgICBsYXN0WSA9IHk7XG4gICAgbGFzdEN1cnNvclRpbWUgPSBjdXJyZW50VGltZTtcbiAgICByZXR1cm4gc3BlZWQ7XG4gIH1cbiAgY29uc3QgZm4gPSBfcmVmID0+IHtcbiAgICBsZXQge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBwbGFjZW1lbnQsXG4gICAgICBlbGVtZW50cyxcbiAgICAgIG9uQ2xvc2UsXG4gICAgICBub2RlSWQsXG4gICAgICB0cmVlXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgaWYgKCFlbGVtZW50cy5kb21SZWZlcmVuY2UgfHwgIWVsZW1lbnRzLmZsb2F0aW5nIHx8IHBsYWNlbWVudCA9PSBudWxsIHx8IHggPT0gbnVsbCB8fCB5ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBjbGllbnRYLFxuICAgICAgICBjbGllbnRZXG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICBjb25zdCBjbGllbnRQb2ludCA9IFtjbGllbnRYLCBjbGllbnRZXTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChldmVudCk7XG4gICAgICBjb25zdCBpc0xlYXZlID0gZXZlbnQudHlwZSA9PT0gJ21vdXNlbGVhdmUnO1xuICAgICAgY29uc3QgaXNPdmVyRmxvYXRpbmdFbCA9IGNvbnRhaW5zKGVsZW1lbnRzLmZsb2F0aW5nLCB0YXJnZXQpO1xuICAgICAgY29uc3QgaXNPdmVyUmVmZXJlbmNlRWwgPSBjb250YWlucyhlbGVtZW50cy5kb21SZWZlcmVuY2UsIHRhcmdldCk7XG4gICAgICBjb25zdCByZWZSZWN0ID0gZWxlbWVudHMuZG9tUmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgcmVjdCA9IGVsZW1lbnRzLmZsb2F0aW5nLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3Qgc2lkZSA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgICAgY29uc3QgY3Vyc29yTGVhdmVGcm9tUmlnaHQgPSB4ID4gcmVjdC5yaWdodCAtIHJlY3Qud2lkdGggLyAyO1xuICAgICAgY29uc3QgY3Vyc29yTGVhdmVGcm9tQm90dG9tID0geSA+IHJlY3QuYm90dG9tIC0gcmVjdC5oZWlnaHQgLyAyO1xuICAgICAgY29uc3QgaXNPdmVyUmVmZXJlbmNlUmVjdCA9IGlzSW5zaWRlKGNsaWVudFBvaW50LCByZWZSZWN0KTtcbiAgICAgIGNvbnN0IGlzRmxvYXRpbmdXaWRlciA9IHJlY3Qud2lkdGggPiByZWZSZWN0LndpZHRoO1xuICAgICAgY29uc3QgaXNGbG9hdGluZ1RhbGxlciA9IHJlY3QuaGVpZ2h0ID4gcmVmUmVjdC5oZWlnaHQ7XG4gICAgICBjb25zdCBsZWZ0ID0gKGlzRmxvYXRpbmdXaWRlciA/IHJlZlJlY3QgOiByZWN0KS5sZWZ0O1xuICAgICAgY29uc3QgcmlnaHQgPSAoaXNGbG9hdGluZ1dpZGVyID8gcmVmUmVjdCA6IHJlY3QpLnJpZ2h0O1xuICAgICAgY29uc3QgdG9wID0gKGlzRmxvYXRpbmdUYWxsZXIgPyByZWZSZWN0IDogcmVjdCkudG9wO1xuICAgICAgY29uc3QgYm90dG9tID0gKGlzRmxvYXRpbmdUYWxsZXIgPyByZWZSZWN0IDogcmVjdCkuYm90dG9tO1xuICAgICAgaWYgKGlzT3ZlckZsb2F0aW5nRWwpIHtcbiAgICAgICAgaGFzTGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFpc0xlYXZlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNPdmVyUmVmZXJlbmNlRWwpIHtcbiAgICAgICAgaGFzTGFuZGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNPdmVyUmVmZXJlbmNlRWwgJiYgIWlzTGVhdmUpIHtcbiAgICAgICAgaGFzTGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmV2ZW50IG92ZXJsYXBwaW5nIGZsb2F0aW5nIGVsZW1lbnQgZnJvbSBiZWluZyBzdHVjayBpbiBhbiBvcGVuLWNsb3NlXG4gICAgICAvLyBsb29wOiBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzE5MTBcbiAgICAgIGlmIChpc0xlYXZlICYmIGlzRWxlbWVudChldmVudC5yZWxhdGVkVGFyZ2V0KSAmJiBjb250YWlucyhlbGVtZW50cy5mbG9hdGluZywgZXZlbnQucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBhbnkgbmVzdGVkIGNoaWxkIGlzIG9wZW4sIGFib3J0LlxuICAgICAgaWYgKHRyZWUgJiYgZ2V0Q2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpLnNvbWUoX3JlZjIgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICByZXR1cm4gY29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogY29udGV4dC5vcGVuO1xuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgcG9pbnRlciBpcyBsZWF2aW5nIGZyb20gdGhlIG9wcG9zaXRlIHNpZGUsIHRoZSBcImJ1ZmZlclwiIGxvZ2ljXG4gICAgICAvLyBjcmVhdGVzIGEgcG9pbnQgd2hlcmUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgcmVtYWlucyBvcGVuLCBidXQgc2hvdWxkIGJlXG4gICAgICAvLyBpZ25vcmVkLlxuICAgICAgLy8gQSBjb25zdGFudCBvZiAxIGhhbmRsZXMgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzLlxuICAgICAgaWYgKHNpZGUgPT09ICd0b3AnICYmIHkgPj0gcmVmUmVjdC5ib3R0b20gLSAxIHx8IHNpZGUgPT09ICdib3R0b20nICYmIHkgPD0gcmVmUmVjdC50b3AgKyAxIHx8IHNpZGUgPT09ICdsZWZ0JyAmJiB4ID49IHJlZlJlY3QucmlnaHQgLSAxIHx8IHNpZGUgPT09ICdyaWdodCcgJiYgeCA8PSByZWZSZWN0LmxlZnQgKyAxKSB7XG4gICAgICAgIHJldHVybiBjbG9zZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZ25vcmUgd2hlbiB0aGUgY3Vyc29yIGlzIHdpdGhpbiB0aGUgcmVjdGFuZ3VsYXIgdHJvdWdoIGJldHdlZW4gdGhlXG4gICAgICAvLyB0d28gZWxlbWVudHMuIFNpbmNlIHRoZSB0cmlhbmdsZSBpcyBjcmVhdGVkIGZyb20gdGhlIGN1cnNvciBwb2ludCxcbiAgICAgIC8vIHdoaWNoIGNhbiBzdGFydCBiZXlvbmQgdGhlIHJlZiBlbGVtZW50J3MgZWRnZSwgdHJhdmVyc2luZyBiYWNrIGFuZFxuICAgICAgLy8gZm9ydGggZnJvbSB0aGUgcmVmIHRvIHRoZSBmbG9hdGluZyBlbGVtZW50IGNhbiBjYXVzZSBpdCB0byBjbG9zZS4gVGhpc1xuICAgICAgLy8gZW5zdXJlcyBpdCBhbHdheXMgcmVtYWlucyBvcGVuIGluIHRoYXQgY2FzZS5cbiAgICAgIGxldCByZWN0UG9seSA9IFtdO1xuICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgcmVjdFBvbHkgPSBbW2xlZnQsIHJlZlJlY3QudG9wICsgMV0sIFtsZWZ0LCByZWN0LmJvdHRvbSAtIDFdLCBbcmlnaHQsIHJlY3QuYm90dG9tIC0gMV0sIFtyaWdodCwgcmVmUmVjdC50b3AgKyAxXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgcmVjdFBvbHkgPSBbW2xlZnQsIHJlY3QudG9wICsgMV0sIFtsZWZ0LCByZWZSZWN0LmJvdHRvbSAtIDFdLCBbcmlnaHQsIHJlZlJlY3QuYm90dG9tIC0gMV0sIFtyaWdodCwgcmVjdC50b3AgKyAxXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIHJlY3RQb2x5ID0gW1tyZWN0LnJpZ2h0IC0gMSwgYm90dG9tXSwgW3JlY3QucmlnaHQgLSAxLCB0b3BdLCBbcmVmUmVjdC5sZWZ0ICsgMSwgdG9wXSwgW3JlZlJlY3QubGVmdCArIDEsIGJvdHRvbV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgcmVjdFBvbHkgPSBbW3JlZlJlY3QucmlnaHQgLSAxLCBib3R0b21dLCBbcmVmUmVjdC5yaWdodCAtIDEsIHRvcF0sIFtyZWN0LmxlZnQgKyAxLCB0b3BdLCBbcmVjdC5sZWZ0ICsgMSwgYm90dG9tXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnZXRQb2x5Z29uKF9yZWYzKSB7XG4gICAgICAgIGxldCBbeCwgeV0gPSBfcmVmMztcbiAgICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRPbmUgPSBbaXNGbG9hdGluZ1dpZGVyID8geCArIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHggKyBidWZmZXIgKiA0IDogeCAtIGJ1ZmZlciAqIDQsIHkgKyBidWZmZXIgKyAxXTtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRUd28gPSBbaXNGbG9hdGluZ1dpZGVyID8geCAtIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHggKyBidWZmZXIgKiA0IDogeCAtIGJ1ZmZlciAqIDQsIHkgKyBidWZmZXIgKyAxXTtcbiAgICAgICAgICAgICAgY29uc3QgY29tbW9uUG9pbnRzID0gW1tyZWN0LmxlZnQsIGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8gcmVjdC5ib3R0b20gLSBidWZmZXIgOiBpc0Zsb2F0aW5nV2lkZXIgPyByZWN0LmJvdHRvbSAtIGJ1ZmZlciA6IHJlY3QudG9wXSwgW3JlY3QucmlnaHQsIGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8gaXNGbG9hdGluZ1dpZGVyID8gcmVjdC5ib3R0b20gLSBidWZmZXIgOiByZWN0LnRvcCA6IHJlY3QuYm90dG9tIC0gYnVmZmVyXV07XG4gICAgICAgICAgICAgIHJldHVybiBbY3Vyc29yUG9pbnRPbmUsIGN1cnNvclBvaW50VHdvLCAuLi5jb21tb25Qb2ludHNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50T25lID0gW2lzRmxvYXRpbmdXaWRlciA/IHggKyBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyB4ICsgYnVmZmVyICogNCA6IHggLSBidWZmZXIgKiA0LCB5IC0gYnVmZmVyXTtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRUd28gPSBbaXNGbG9hdGluZ1dpZGVyID8geCAtIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHggKyBidWZmZXIgKiA0IDogeCAtIGJ1ZmZlciAqIDQsIHkgLSBidWZmZXJdO1xuICAgICAgICAgICAgICBjb25zdCBjb21tb25Qb2ludHMgPSBbW3JlY3QubGVmdCwgY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyByZWN0LnRvcCArIGJ1ZmZlciA6IGlzRmxvYXRpbmdXaWRlciA/IHJlY3QudG9wICsgYnVmZmVyIDogcmVjdC5ib3R0b21dLCBbcmVjdC5yaWdodCwgY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyBpc0Zsb2F0aW5nV2lkZXIgPyByZWN0LnRvcCArIGJ1ZmZlciA6IHJlY3QuYm90dG9tIDogcmVjdC50b3AgKyBidWZmZXJdXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjdXJzb3JQb2ludE9uZSwgY3Vyc29yUG9pbnRUd28sIC4uLmNvbW1vblBvaW50c107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50T25lID0gW3ggKyBidWZmZXIgKyAxLCBpc0Zsb2F0aW5nVGFsbGVyID8geSArIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyB5ICsgYnVmZmVyICogNCA6IHkgLSBidWZmZXIgKiA0XTtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRUd28gPSBbeCArIGJ1ZmZlciArIDEsIGlzRmxvYXRpbmdUYWxsZXIgPyB5IC0gYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHkgKyBidWZmZXIgKiA0IDogeSAtIGJ1ZmZlciAqIDRdO1xuICAgICAgICAgICAgICBjb25zdCBjb21tb25Qb2ludHMgPSBbW2N1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHJlY3QucmlnaHQgLSBidWZmZXIgOiBpc0Zsb2F0aW5nVGFsbGVyID8gcmVjdC5yaWdodCAtIGJ1ZmZlciA6IHJlY3QubGVmdCwgcmVjdC50b3BdLCBbY3Vyc29yTGVhdmVGcm9tQm90dG9tID8gaXNGbG9hdGluZ1RhbGxlciA/IHJlY3QucmlnaHQgLSBidWZmZXIgOiByZWN0LmxlZnQgOiByZWN0LnJpZ2h0IC0gYnVmZmVyLCByZWN0LmJvdHRvbV1dO1xuICAgICAgICAgICAgICByZXR1cm4gWy4uLmNvbW1vblBvaW50cywgY3Vyc29yUG9pbnRPbmUsIGN1cnNvclBvaW50VHdvXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50T25lID0gW3ggLSBidWZmZXIsIGlzRmxvYXRpbmdUYWxsZXIgPyB5ICsgYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHkgKyBidWZmZXIgKiA0IDogeSAtIGJ1ZmZlciAqIDRdO1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludFR3byA9IFt4IC0gYnVmZmVyLCBpc0Zsb2F0aW5nVGFsbGVyID8geSAtIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyB5ICsgYnVmZmVyICogNCA6IHkgLSBidWZmZXIgKiA0XTtcbiAgICAgICAgICAgICAgY29uc3QgY29tbW9uUG9pbnRzID0gW1tjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyByZWN0LmxlZnQgKyBidWZmZXIgOiBpc0Zsb2F0aW5nVGFsbGVyID8gcmVjdC5sZWZ0ICsgYnVmZmVyIDogcmVjdC5yaWdodCwgcmVjdC50b3BdLCBbY3Vyc29yTGVhdmVGcm9tQm90dG9tID8gaXNGbG9hdGluZ1RhbGxlciA/IHJlY3QubGVmdCArIGJ1ZmZlciA6IHJlY3QucmlnaHQgOiByZWN0LmxlZnQgKyBidWZmZXIsIHJlY3QuYm90dG9tXV07XG4gICAgICAgICAgICAgIHJldHVybiBbY3Vyc29yUG9pbnRPbmUsIGN1cnNvclBvaW50VHdvLCAuLi5jb21tb25Qb2ludHNdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNQb2ludEluUG9seWdvbihbY2xpZW50WCwgY2xpZW50WV0sIHJlY3RQb2x5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGhhc0xhbmRlZCAmJiAhaXNPdmVyUmVmZXJlbmNlUmVjdCkge1xuICAgICAgICByZXR1cm4gY2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNMZWF2ZSAmJiByZXF1aXJlSW50ZW50KSB7XG4gICAgICAgIGNvbnN0IGN1cnNvclNwZWVkID0gZ2V0Q3Vyc29yU3BlZWQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICAgIGNvbnN0IGN1cnNvclNwZWVkVGhyZXNob2xkID0gMC4xO1xuICAgICAgICBpZiAoY3Vyc29yU3BlZWQgIT09IG51bGwgJiYgY3Vyc29yU3BlZWQgPCBjdXJzb3JTcGVlZFRocmVzaG9sZCkge1xuICAgICAgICAgIHJldHVybiBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzUG9pbnRJblBvbHlnb24oW2NsaWVudFgsIGNsaWVudFldLCBnZXRQb2x5Z29uKFt4LCB5XSkpKSB7XG4gICAgICAgIGNsb3NlKCk7XG4gICAgICB9IGVsc2UgaWYgKCFoYXNMYW5kZWQgJiYgcmVxdWlyZUludGVudCkge1xuICAgICAgICB0aW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dChjbG9zZSwgNDApO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGZuLl9fb3B0aW9ucyA9IHtcbiAgICBibG9ja1BvaW50ZXJFdmVudHNcbiAgfTtcbiAgcmV0dXJuIGZuO1xufVxuXG5leHBvcnQgeyBDb21wb3NpdGUsIENvbXBvc2l0ZUl0ZW0sIEZsb2F0aW5nQXJyb3csIEZsb2F0aW5nRGVsYXlHcm91cCwgRmxvYXRpbmdGb2N1c01hbmFnZXIsIEZsb2F0aW5nTGlzdCwgRmxvYXRpbmdOb2RlLCBGbG9hdGluZ092ZXJsYXksIEZsb2F0aW5nUG9ydGFsLCBGbG9hdGluZ1RyZWUsIGlubmVyLCBzYWZlUG9seWdvbiwgdXNlQ2xpY2ssIHVzZUNsaWVudFBvaW50LCB1c2VEZWxheUdyb3VwLCB1c2VEZWxheUdyb3VwQ29udGV4dCwgdXNlRGlzbWlzcywgdXNlRmxvYXRpbmcsIHVzZUZsb2F0aW5nTm9kZUlkLCB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCwgdXNlRmxvYXRpbmdQb3J0YWxOb2RlLCB1c2VGbG9hdGluZ1RyZWUsIHVzZUZvY3VzLCB1c2VIb3ZlciwgdXNlSWQsIHVzZUlubmVyT2Zmc2V0LCB1c2VJbnRlcmFjdGlvbnMsIHVzZUxpc3RJdGVtLCB1c2VMaXN0TmF2aWdhdGlvbiwgdXNlTWVyZ2VSZWZzLCB1c2VSb2xlLCB1c2VUcmFuc2l0aW9uU3RhdHVzLCB1c2VUcmFuc2l0aW9uU3R5bGVzLCB1c2VUeXBlYWhlYWQgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsInN0b3BFdmVudCIsImdldERvY3VtZW50IiwiaXNNb3VzZUxpa2VQb2ludGVyVHlwZSIsImNvbnRhaW5zIiwiYWN0aXZlRWxlbWVudCIsImlzU2FmYXJpIiwiaXNUeXBlYWJsZUNvbWJvYm94IiwiaXNWaXJ0dWFsQ2xpY2siLCJpc1ZpcnR1YWxQb2ludGVyRXZlbnQiLCJnZXRUYXJnZXQiLCJnZXRQbGF0Zm9ybSIsImlzVHlwZWFibGVFbGVtZW50IiwiaXNSZWFjdEV2ZW50IiwiaXNSb290RWxlbWVudCIsImlzRXZlbnRUYXJnZXRXaXRoaW4iLCJpc01hYyIsImdldFVzZXJBZ2VudCIsImZsb29yIiwicGxhdGZvcm0iLCJnZXRPdmVyZmxvd0FuY2VzdG9ycyIsInVzZUZsb2F0aW5nIiwidXNlRmxvYXRpbmckMSIsIm9mZnNldCIsImRldGVjdE92ZXJmbG93IiwiYXJyb3ciLCJhdXRvUGxhY2VtZW50IiwiYXV0b1VwZGF0ZSIsImNvbXB1dGVQb3NpdGlvbiIsImZsaXAiLCJoaWRlIiwiaW5saW5lIiwibGltaXRTaGlmdCIsInNoaWZ0Iiwic2l6ZSIsImlzRWxlbWVudCIsImlzSFRNTEVsZW1lbnQiLCJnZXROb2RlTmFtZSIsImdldFdpbmRvdyIsImlzTGFzdFRyYXZlcnNhYmxlTm9kZSIsImdldFBhcmVudE5vZGUiLCJnZXRDb21wdXRlZFN0eWxlIiwidGFiYmFibGUiLCJjcmVhdGVQb3J0YWwiLCJmbHVzaFN5bmMiLCJ1c2VNZXJnZVJlZnMiLCJyZWZzIiwidXNlTWVtbyIsImV2ZXJ5IiwicmVmIiwidmFsdWUiLCJmb3JFYWNoIiwiY3VycmVudCIsInVzZUluc2VydGlvbkVmZmVjdCIsInRvU3RyaW5nIiwidXNlU2FmZUluc2VydGlvbkVmZmVjdCIsImZuIiwidXNlRWZmZWN0RXZlbnQiLCJjYWxsYmFjayIsInByb2Nlc3MiLCJFcnJvciIsInVzZUNhbGxiYWNrIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJBUlJPV19VUCIsIkFSUk9XX0RPV04iLCJBUlJPV19MRUZUIiwiQVJST1dfUklHSFQiLCJpc0RpZmZlcmVudFJvdyIsImluZGV4IiwiY29scyIsInByZXZSb3ciLCJNYXRoIiwiaXNJbmRleE91dE9mQm91bmRzIiwibGlzdFJlZiIsImdldE1pbkluZGV4IiwiZGlzYWJsZWRJbmRpY2VzIiwiZmluZE5vbkRpc2FibGVkSW5kZXgiLCJnZXRNYXhJbmRleCIsImRlY3JlbWVudCIsInN0YXJ0aW5nSW5kZXgiLCJfdGVtcCIsImFtb3VudCIsImxpc3QiLCJpc0Rpc2FibGVkSW5kZXgiLCJpbmNsdWRlcyIsImVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJnZXRHcmlkTmF2aWdhdGVkSW5kZXgiLCJlbGVtZW50c1JlZiIsIl9yZWYiLCJldmVudCIsIm9yaWVudGF0aW9uIiwibG9vcCIsIm1pbkluZGV4IiwibWF4SW5kZXgiLCJwcmV2SW5kZXgiLCJzdG9wIiwibmV4dEluZGV4Iiwia2V5IiwiY29sIiwibWF4Q29sIiwibGFzdFJvdyIsInJhZklkIiwiZW5xdWV1ZUZvY3VzIiwiZWwiLCJvcHRpb25zIiwicHJldmVudFNjcm9sbCIsImNhbmNlbFByZXZpb3VzIiwic3luYyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiZXhlYyIsImZvY3VzIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZG9jdW1lbnQiLCJzb3J0QnlEb2N1bWVudFBvc2l0aW9uIiwiYSIsImIiLCJwb3NpdGlvbiIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiTm9kZSIsIkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyIsIkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSIsIkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyIsIkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5TIiwiYXJlTWFwc0VxdWFsIiwibWFwMSIsIm1hcDIiLCJlbnRyaWVzIiwiZ2V0IiwiRmxvYXRpbmdMaXN0Q29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJyZWdpc3RlciIsInVucmVnaXN0ZXIiLCJtYXAiLCJNYXAiLCJGbG9hdGluZ0xpc3QiLCJjaGlsZHJlbiIsImxhYmVsc1JlZiIsInNldE1hcCIsInVzZVN0YXRlIiwibm9kZSIsInByZXZNYXAiLCJzZXQiLCJkZWxldGUiLCJuZXdNYXAiLCJub2RlcyIsImZyb20iLCJrZXlzIiwic29ydCIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInVzZUxpc3RJdGVtIiwibGFiZWwiLCJpbmRleCQxIiwic2V0SW5kZXgiLCJjb21wb25lbnRSZWYiLCJ1c2VDb250ZXh0IiwiX25vZGUkdGV4dENvbnRlbnQiLCJpc0xhYmVsRGVmaW5lZCIsInVuZGVmaW5lZCIsInRleHRDb250ZW50IiwicmVuZGVySnN4IiwicmVuZGVyIiwiY29tcHV0ZWRQcm9wcyIsImNsb25lRWxlbWVudCIsIkNvbXBvc2l0ZUNvbnRleHQiLCJhY3RpdmVJbmRleCIsIm9uTmF2aWdhdGUiLCJob3Jpem9udGFsS2V5cyIsInZlcnRpY2FsS2V5cyIsImFsbEtleXMiLCJDb21wb3NpdGUiLCJmb3J3YXJkUmVmIiwiZm9yd2FyZGVkUmVmIiwiZXh0ZXJuYWxBY3RpdmVJbmRleCIsImV4dGVybmFsU2V0QWN0aXZlSW5kZXgiLCJwcm9wcyIsImludGVybmFsQWN0aXZlSW5kZXgiLCJpbnRlcm5hbFNldEFjdGl2ZUluZGV4IiwicmVuZGVyRWxlbWVudFByb3BzIiwiY29udGV4dFZhbHVlIiwiaXNHcmlkIiwiaGFuZGxlS2V5RG93biIsInRvRW5kS2V5cyIsImhvcml6b250YWwiLCJ2ZXJ0aWNhbCIsImJvdGgiLCJ0b1N0YXJ0S2V5cyIsInByZXZlbnRlZEtleXMiLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsInF1ZXVlTWljcm90YXNrIiwib25LZXlEb3duIiwiZSIsIkNvbXBvc2l0ZUl0ZW0iLCJfcmVmMiIsIm1lcmdlZFJlZiIsImlzQWN0aXZlIiwidGFiSW5kZXgiLCJvbkZvY3VzIiwiX2V4dGVuZHMiLCJPYmplY3QiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiaSIsInNvdXJjZSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5Iiwic2VydmVySGFuZG9mZkNvbXBsZXRlIiwiY291bnQiLCJnZW5JZCIsInVzZUZsb2F0aW5nSWQiLCJpZCIsInNldElkIiwidXNlUmVhY3RJZCIsInVzZUlkIiwiRmxvYXRpbmdBcnJvdyIsImNvbnRleHQiLCJwbGFjZW1lbnQiLCJlbGVtZW50cyIsImZsb2F0aW5nIiwibWlkZGxld2FyZURhdGEiLCJ3aWR0aCIsImhlaWdodCIsInRpcFJhZGl1cyIsInN0cm9rZVdpZHRoIiwic3RhdGljT2Zmc2V0Iiwic3Ryb2tlIiwiZCIsInN0eWxlIiwidHJhbnNmb3JtIiwicmVzdFN0eWxlIiwicmVzdCIsImNvbnNvbGUiLCJ3YXJuIiwiY2xpcFBhdGhJZCIsImhhbGZTdHJva2VXaWR0aCIsInN2Z1giLCJzdmdZIiwic2lkZSIsImFsaWdubWVudCIsInNwbGl0IiwiaXNSVEwiLCJpc0N1c3RvbVNoYXBlIiwiaXNWZXJ0aWNhbFNpZGUiLCJ5T2Zmc2V0UHJvcCIsInhPZmZzZXRQcm9wIiwiYXJyb3dYIiwieCIsImFycm93WSIsInkiLCJkVmFsdWUiLCJyb3RhdGlvbiIsInRvcCIsImxlZnQiLCJib3R0b20iLCJyaWdodCIsInZpZXdCb3giLCJwb2ludGVyRXZlbnRzIiwiY2xpcFBhdGgiLCJmaWxsIiwiY3JlYXRlUHViU3ViIiwiZW1pdCIsImRhdGEiLCJfbWFwJGdldCIsImhhbmRsZXIiLCJvbiIsImxpc3RlbmVyIiwib2ZmIiwiX21hcCRnZXQyIiwiZmlsdGVyIiwibCIsIkZsb2F0aW5nTm9kZUNvbnRleHQiLCJGbG9hdGluZ1RyZWVDb250ZXh0IiwidXNlRmxvYXRpbmdQYXJlbnROb2RlSWQiLCJfUmVhY3QkdXNlQ29udGV4dCIsInVzZUZsb2F0aW5nVHJlZSIsInVzZUZsb2F0aW5nTm9kZUlkIiwiY3VzdG9tUGFyZW50SWQiLCJ0cmVlIiwicmVhY3RQYXJlbnRJZCIsInBhcmVudElkIiwiYWRkTm9kZSIsInJlbW92ZU5vZGUiLCJGbG9hdGluZ05vZGUiLCJGbG9hdGluZ1RyZWUiLCJub2Rlc1JlZiIsIm4iLCJldmVudHMiLCJjcmVhdGVBdHRyaWJ1dGUiLCJuYW1lIiwidXNlTGF0ZXN0UmVmIiwic2FmZVBvbHlnb25JZGVudGlmaWVyIiwiZ2V0RGVsYXkiLCJwcm9wIiwicG9pbnRlclR5cGUiLCJ1c2VIb3ZlciIsIm9wZW4iLCJvbk9wZW5DaGFuZ2UiLCJkYXRhUmVmIiwiZG9tUmVmZXJlbmNlIiwiZW5hYmxlZCIsImRlbGF5IiwiaGFuZGxlQ2xvc2UiLCJtb3VzZU9ubHkiLCJyZXN0TXMiLCJtb3ZlIiwiaGFuZGxlQ2xvc2VSZWYiLCJkZWxheVJlZiIsInBvaW50ZXJUeXBlUmVmIiwidGltZW91dFJlZiIsImhhbmRsZXJSZWYiLCJyZXN0VGltZW91dFJlZiIsImJsb2NrTW91c2VNb3ZlUmVmIiwicGVyZm9ybWVkUG9pbnRlckV2ZW50c011dGF0aW9uUmVmIiwidW5iaW5kTW91c2VNb3ZlUmVmIiwiaXNIb3Zlck9wZW4iLCJfZGF0YVJlZiRjdXJyZW50JG9wZW4iLCJ0eXBlIiwib3BlbkV2ZW50IiwiY2xlYXJUaW1lb3V0Iiwib25MZWF2ZSIsImh0bWwiLCJkb2N1bWVudEVsZW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNsb3NlV2l0aERlbGF5IiwicnVuRWxzZUJyYW5jaCIsInJlYXNvbiIsImNsb3NlRGVsYXkiLCJzZXRUaW1lb3V0IiwiY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIiLCJjbGVhclBvaW50ZXJFdmVudHMiLCJib2R5IiwicmVtb3ZlQXR0cmlidXRlIiwiaXNDbGlja0xpa2VPcGVuRXZlbnQiLCJvbk1vdXNlRW50ZXIiLCJvcGVuRGVsYXkiLCJvbk1vdXNlTGVhdmUiLCJkb2MiLCJjbGllbnRYIiwiY2xpZW50WSIsIm9uQ2xvc2UiLCJzaG91bGRDbG9zZSIsInJlbGF0ZWRUYXJnZXQiLCJvblNjcm9sbE1vdXNlTGVhdmUiLCJvbmNlIiwiX2hhbmRsZUNsb3NlUmVmJGN1cnJlIiwiX19vcHRpb25zIiwiYmxvY2tQb2ludGVyRXZlbnRzIiwic2V0QXR0cmlidXRlIiwiX3RyZWUkbm9kZXNSZWYkY3VycmVuIiwicGFyZW50RmxvYXRpbmciLCJmaW5kIiwic2V0UG9pbnRlclJlZiIsInJlZmVyZW5jZSIsIm9uUG9pbnRlckRvd24iLCJvblBvaW50ZXJFbnRlciIsIm9uTW91c2VNb3ZlIiwibmF0aXZlRXZlbnQiLCJGbG9hdGluZ0RlbGF5R3JvdXBDb250ZXh0IiwiaW5pdGlhbERlbGF5IiwidGltZW91dE1zIiwiY3VycmVudElkIiwic2V0Q3VycmVudElkIiwic2V0U3RhdGUiLCJpc0luc3RhbnRQaGFzZSIsInVzZURlbGF5R3JvdXBDb250ZXh0IiwiRmxvYXRpbmdEZWxheUdyb3VwIiwic3RhdGUiLCJ1c2VSZWR1Y2VyIiwicHJldiIsIm5leHQiLCJpbml0aWFsQ3VycmVudElkUmVmIiwidXNlRGVsYXlHcm91cCIsIl9yZWYzIiwiY2xvc2UiLCJ1bnNldCIsInRpbWVvdXQiLCJ3aW5kb3ciLCJnZXRBbmNlc3RvcnMiLCJfbm9kZXMkZmluZCIsImFsbEFuY2VzdG9ycyIsImN1cnJlbnRQYXJlbnRJZCIsImN1cnJlbnROb2RlIiwiY29uY2F0IiwiZ2V0Q2hpbGRyZW4iLCJhbGxDaGlsZHJlbiIsIl9ub2RlJGNvbnRleHQiLCJjdXJyZW50Q2hpbGRyZW4iLCJfY3VycmVudENoaWxkcmVuIiwic29tZSIsIl9ub2RlJGNvbnRleHQyIiwiZ2V0RGVlcGVzdE5vZGUiLCJkZWVwZXN0Tm9kZUlkIiwibWF4RGVwdGgiLCJmaW5kRGVlcGVzdCIsIm5vZGVJZCIsImRlcHRoIiwiY2hpbGQiLCJjb3VudGVyTWFwIiwiV2Vha01hcCIsInVuY29udHJvbGxlZEVsZW1lbnRzU2V0IiwiV2Vha1NldCIsIm1hcmtlck1hcCIsImxvY2tDb3VudCIsInN1cHBvcnRzSW5lcnQiLCJIVE1MRWxlbWVudCIsInVud3JhcEhvc3QiLCJob3N0IiwicGFyZW50Tm9kZSIsImNvcnJlY3RFbGVtZW50cyIsInBhcmVudCIsInRhcmdldHMiLCJjb3JyZWN0ZWRUYXJnZXQiLCJhcHBseUF0dHJpYnV0ZVRvT3RoZXJzIiwidW5jb3JyZWN0ZWRBdm9pZEVsZW1lbnRzIiwiYXJpYUhpZGRlbiIsImluZXJ0IiwibWFya2VyTmFtZSIsImNvbnRyb2xBdHRyaWJ1dGUiLCJhdm9pZEVsZW1lbnRzIiwiZWxlbWVudHNUb0tlZXAiLCJTZXQiLCJlbGVtZW50c1RvU3RvcCIsImhpZGRlbkVsZW1lbnRzIiwibWFya2VyQ291bnRlciIsImtlZXAiLCJkZWVwIiwiY2xlYXIiLCJoYXMiLCJhZGQiLCJhdHRyIiwiYWxyZWFkeUhpZGRlbiIsImNvdW50ZXJWYWx1ZSIsIm1hcmtlclZhbHVlIiwicHVzaCIsIm1hcmtPdGhlcnMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZ2V0VGFiYmFibGVPcHRpb25zIiwiZ2V0U2hhZG93Um9vdCIsImRpc3BsYXlDaGVjayIsIlJlc2l6ZU9ic2VydmVyIiwiZ2V0VGFiYmFibGVJbiIsImNvbnRhaW5lciIsImRpcmVjdGlvbiIsImFsbFRhYmJhYmxlIiwicmV2ZXJzZSIsImluZGV4T2YiLCJuZXh0VGFiYmFibGVFbGVtZW50cyIsInNsaWNlIiwiZ2V0TmV4dFRhYmJhYmxlIiwiZ2V0UHJldmlvdXNUYWJiYWJsZSIsImlzT3V0c2lkZUV2ZW50IiwiY29udGFpbmVyRWxlbWVudCIsImN1cnJlbnRUYXJnZXQiLCJkaXNhYmxlRm9jdXNJbnNpZGUiLCJ0YWJiYWJsZUVsZW1lbnRzIiwiZGF0YXNldCIsInRhYmluZGV4IiwiZW5hYmxlRm9jdXNJbnNpZGUiLCJISURERU5fU1RZTEVTIiwiYm9yZGVyIiwiY2xpcCIsIm1hcmdpbiIsIm92ZXJmbG93IiwicGFkZGluZyIsIndoaXRlU3BhY2UiLCJ0aW1lb3V0SWQiLCJzZXRBY3RpdmVFbGVtZW50T25UYWIiLCJGb2N1c0d1YXJkIiwicm9sZSIsInNldFJvbGUiLCJyZXN0UHJvcHMiLCJQb3J0YWxDb250ZXh0IiwidXNlRmxvYXRpbmdQb3J0YWxOb2RlIiwicm9vdCIsInBvcnRhbE5vZGUiLCJzZXRQb3J0YWxOb2RlIiwidW5pcXVlSWQiLCJwb3J0YWxDb250ZXh0IiwidXNlUG9ydGFsQ29udGV4dCIsInJlbW92ZSIsImV4aXN0aW5nSWRSb290IiwiZ2V0RWxlbWVudEJ5SWQiLCJzdWJSb290IiwiYXBwZW5kQ2hpbGQiLCJpZFdyYXBwZXIiLCJGbG9hdGluZ1BvcnRhbCIsInByZXNlcnZlVGFiT3JkZXIiLCJmb2N1c01hbmFnZXJTdGF0ZSIsInNldEZvY3VzTWFuYWdlclN0YXRlIiwiYmVmb3JlT3V0c2lkZVJlZiIsImFmdGVyT3V0c2lkZVJlZiIsImJlZm9yZUluc2lkZVJlZiIsImFmdGVySW5zaWRlUmVmIiwic2hvdWxkUmVuZGVyR3VhcmRzIiwibW9kYWwiLCJmb2N1c2luZyIsIm1hbmFnZUZvY3VzIiwiX2JlZm9yZUluc2lkZVJlZiRjdXJyIiwicHJldlRhYmJhYmxlIiwiX2FmdGVySW5zaWRlUmVmJGN1cnJlIiwibmV4dFRhYmJhYmxlIiwiY2xvc2VPbkZvY3VzT3V0IiwiTElTVF9MSU1JVCIsInByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMiLCJhZGRQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQiLCJpc0Nvbm5lY3RlZCIsImdldFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCIsIlZpc3VhbGx5SGlkZGVuRGlzbWlzcyIsIkZsb2F0aW5nRm9jdXNNYW5hZ2VyIiwiZGlzYWJsZWQiLCJvcmRlciIsImd1YXJkcyIsIl9ndWFyZHMiLCJpbml0aWFsRm9jdXMiLCJyZXR1cm5Gb2N1cyIsInZpc3VhbGx5SGlkZGVuRGlzbWlzcyIsImlnbm9yZUluaXRpYWxGb2N1cyIsImlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCIsIm9yZGVyUmVmIiwiaW5pdGlhbEZvY3VzUmVmIiwicmV0dXJuRm9jdXNSZWYiLCJzdGFydERpc21pc3NCdXR0b25SZWYiLCJlbmREaXNtaXNzQnV0dG9uUmVmIiwicHJldmVudFJldHVybkZvY3VzUmVmIiwiaXNQb2ludGVyRG93blJlZiIsImlzSW5zaWRlUG9ydGFsIiwiZ2V0VGFiYmFibGVDb250ZW50IiwiZ2V0VGFiYmFibGVFbGVtZW50cyIsImNvbnRlbnQiLCJCb29sZWFuIiwiZmxhdCIsImVscyIsInNoaWZ0S2V5IiwiaGFuZGxlUG9pbnRlckRvd24iLCJoYW5kbGVGb2N1c091dHNpZGUiLCJtb3ZlZFRvVW5yZWxhdGVkTm9kZSIsIl9ub2RlJGNvbnRleHQzIiwiX25vZGUkY29udGV4dDQiLCJfcG9ydGFsQ29udGV4dCRwb3J0YWwiLCJwb3J0YWxOb2RlcyIsImluc2lkZUVsZW1lbnRzIiwiY2xlYW51cCIsInByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCIsImZvY3VzYWJsZUVsZW1lbnRzIiwiaW5pdGlhbEZvY3VzVmFsdWUiLCJlbFRvRm9jdXMiLCJmb2N1c0FscmVhZHlJbnNpZGVGbG9hdGluZ0VsIiwicHJldmVudFJldHVybkZvY3VzU2Nyb2xsIiwiY29udGV4dERhdGEiLCJuZXN0ZWQiLCJhY3RpdmVFbCIsImlzRm9jdXNJbnNpZGVGbG9hdGluZ1RyZWUiLCJfbm9kZSRjb250ZXh0NSIsInNob3VsZEZvY3VzUmVmZXJlbmNlIiwicmV0dXJuRWxlbWVudCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJoYW5kbGVNdXRhdGlvbiIsIm9ic2VydmVyIiwib2JzZXJ2ZSIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJhdHRyaWJ1dGVzIiwiZGlzY29ubmVjdCIsInJlbmRlckRpc21pc3NCdXR0b24iLCJsb2NhdGlvbiIsIm9uQ2xpY2siLCJGcmFnbWVudCIsIl9wb3J0YWxDb250ZXh0JGJlZm9yZSIsIl9wb3J0YWxDb250ZXh0JGFmdGVyTyIsImFjdGl2ZUxvY2tzIiwiRmxvYXRpbmdPdmVybGF5IiwibG9ja1Njcm9sbCIsImxvY2tJZCIsImlzSU9TIiwidGVzdCIsImJvZHlTdHlsZSIsInNjcm9sbGJhclgiLCJyb3VuZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNjcm9sbExlZnQiLCJwYWRkaW5nUHJvcCIsInNjcm9sbGJhcldpZHRoIiwiaW5uZXJXaWR0aCIsImNsaWVudFdpZHRoIiwic2Nyb2xsWCIsInBhcnNlRmxvYXQiLCJwYWdlWE9mZnNldCIsInNjcm9sbFkiLCJwYWdlWU9mZnNldCIsIl93aW5kb3ckdmlzdWFsVmlld3BvciIsIl93aW5kb3ckdmlzdWFsVmlld3BvcjIiLCJvZmZzZXRMZWZ0IiwidmlzdWFsVmlld3BvcnQiLCJvZmZzZXRUb3AiLCJzY3JvbGxUbyIsImlzQnV0dG9uVGFyZ2V0IiwidGFnTmFtZSIsImlzU3BhY2VJZ25vcmVkIiwidXNlQ2xpY2siLCJldmVudE9wdGlvbiIsInRvZ2dsZSIsImlnbm9yZU1vdXNlIiwia2V5Ym9hcmRIYW5kbGVycyIsImRpZEtleURvd25SZWYiLCJvbk1vdXNlRG93biIsImJ1dHRvbiIsImRlZmF1bHRQcmV2ZW50ZWQiLCJvbktleVVwIiwiY3JlYXRlVmlydHVhbEVsZW1lbnQiLCJkb21SZWYiLCJvZmZzZXRYIiwib2Zmc2V0WSIsImlzQXV0b1VwZGF0ZUV2ZW50IiwiY29udGV4dEVsZW1lbnQiLCJfZG9tUmVmJGN1cnJlbnQiLCJfZGF0YSRkYXRhUmVmJGN1cnJlbnQiLCJkb21SZWN0IiwiaXNYQXhpcyIsImF4aXMiLCJpc1lBeGlzIiwiY2FuVHJhY2tDdXJzb3JPbkF1dG9VcGRhdGUiLCJpc01vdXNlQmFzZWRFdmVudCIsInVzZUNsaWVudFBvaW50IiwiaW5pdGlhbFJlZiIsImNsZWFudXBMaXN0ZW5lclJlZiIsInNldFBvaW50ZXJUeXBlIiwicmVhY3RpdmUiLCJzZXRSZWFjdGl2ZSIsInNldFJlZmVyZW5jZSIsInNldFBvc2l0aW9uUmVmZXJlbmNlIiwiaGFuZGxlUmVmZXJlbmNlRW50ZXJPck1vdmUiLCJvcGVuQ2hlY2siLCJhZGRMaXN0ZW5lciIsIndpbiIsImhhbmRsZU1vdXNlTW92ZSIsInNldFBvaW50ZXJUeXBlUmVmIiwiYnViYmxlSGFuZGxlcktleXMiLCJwb2ludGVyZG93biIsIm1vdXNlZG93biIsImNsaWNrIiwiY2FwdHVyZUhhbmRsZXJLZXlzIiwibm9ybWFsaXplUHJvcCIsIm5vcm1hbGl6YWJsZSIsIl9ub3JtYWxpemFibGUkZXNjYXBlSyIsIl9ub3JtYWxpemFibGUkb3V0c2lkZSIsImVzY2FwZUtleSIsIm91dHNpZGVQcmVzcyIsInVzZURpc21pc3MiLCJ1bnN0YWJsZV9vdXRzaWRlUHJlc3MiLCJvdXRzaWRlUHJlc3NFdmVudCIsInJlZmVyZW5jZVByZXNzIiwicmVmZXJlbmNlUHJlc3NFdmVudCIsImFuY2VzdG9yU2Nyb2xsIiwiYnViYmxlcyIsImNhcHR1cmUiLCJvdXRzaWRlUHJlc3NGbiIsImluc2lkZVJlYWN0VHJlZVJlZiIsImVuZGVkT3JTdGFydGVkSW5zaWRlUmVmIiwiZXNjYXBlS2V5QnViYmxlcyIsIm91dHNpZGVQcmVzc0J1YmJsZXMiLCJlc2NhcGVLZXlDYXB0dXJlIiwib3V0c2lkZVByZXNzQ2FwdHVyZSIsImNsb3NlT25Fc2NhcGVLZXlEb3duIiwic2hvdWxkRGlzbWlzcyIsIl9jaGlsZCRjb250ZXh0IiwiX19lc2NhcGVLZXlCdWJibGVzIiwiY2xvc2VPbkVzY2FwZUtleURvd25DYXB0dXJlIiwiX2dldFRhcmdldDIiLCJfZ2V0VGFyZ2V0IiwiY2xvc2VPblByZXNzT3V0c2lkZSIsImluc2lkZVJlYWN0VHJlZSIsImVuZGVkT3JTdGFydGVkSW5zaWRlIiwiaW5lcnRTZWxlY3RvciIsIm1hcmtlcnMiLCJ0YXJnZXRSb290QW5jZXN0b3IiLCJuZXh0UGFyZW50IiwibWFya2VyIiwiY2FuU2Nyb2xsWCIsInNjcm9sbFdpZHRoIiwiY2FuU2Nyb2xsWSIsImNsaWVudEhlaWdodCIsInNjcm9sbEhlaWdodCIsInhDb25kIiwib2Zmc2V0V2lkdGgiLCJ0YXJnZXRJc0luc2lkZUNoaWxkcmVuIiwiX2NoaWxkJGNvbnRleHQyIiwiX19vdXRzaWRlUHJlc3NCdWJibGVzIiwiY2xvc2VPblByZXNzT3V0c2lkZUNhcHR1cmUiLCJfZ2V0VGFyZ2V0NCIsIl9nZXRUYXJnZXQzIiwib25TY3JvbGwiLCJhbmNlc3RvcnMiLCJhbmNlc3RvciIsIl9kb2MkZGVmYXVsdFZpZXciLCJkZWZhdWx0VmlldyIsInBhc3NpdmUiLCJvbk1vdXNlVXAiLCJkZXZNZXNzYWdlU2V0IiwiX29wdGlvbnMkZWxlbWVudHMyIiwidW5zdGFibGVfb25PcGVuQ2hhbmdlIiwiX29wdGlvbnMkZWxlbWVudHMiLCJlcnIiLCJfZGV2TWVzc2FnZVNldCIsIl9kZXZNZXNzYWdlU2V0MiIsImVycm9yIiwiX2RvbVJlZmVyZW5jZSIsInNldERvbVJlZmVyZW5jZSIsImRvbVJlZmVyZW5jZVJlZiIsImZsb2F0aW5nSWQiLCJwb3NpdGlvblJlZmVyZW5jZSIsInVzZUZvY3VzIiwidmlzaWJsZU9ubHkiLCJibG9ja0ZvY3VzUmVmIiwia2V5Ym9hcmRNb2RhbGl0eVJlZiIsIm9uQmx1ciIsIm1hdGNoZXMiLCJtb3ZlZFRvRm9jdXNHdWFyZCIsIm93bmVyRG9jdW1lbnQiLCJBQ1RJVkVfS0VZIiwiU0VMRUNURURfS0VZIiwibWVyZ2VQcm9wcyIsInVzZXJQcm9wcyIsInByb3BzTGlzdCIsImVsZW1lbnRLZXkiLCJpc0l0ZW0iLCJkb21Vc2VyUHJvcHMiLCJfIiwiX18iLCJ2YWxpZFByb3BzIiwicHJvcHNPckdldFByb3BzIiwicmVkdWNlIiwiYWNjIiwidmFsIiwidXNlSW50ZXJhY3Rpb25zIiwiZGVwcyIsImdldFJlZmVyZW5jZVByb3BzIiwiZ2V0RmxvYXRpbmdQcm9wcyIsImdldEl0ZW1Qcm9wcyIsIml0ZW0iLCJpc1ByZXZlbnRTY3JvbGxTdXBwb3J0ZWQiLCJkb1N3aXRjaCIsImlzTWFpbk9yaWVudGF0aW9uS2V5IiwiaXNNYWluT3JpZW50YXRpb25Ub0VuZEtleSIsInJ0bCIsImlzQ3Jvc3NPcmllbnRhdGlvbk9wZW5LZXkiLCJpc0Nyb3NzT3JpZW50YXRpb25DbG9zZUtleSIsInVzZUxpc3ROYXZpZ2F0aW9uIiwidW5zdGFibGVfb25OYXZpZ2F0ZSIsInNlbGVjdGVkSW5kZXgiLCJhbGxvd0VzY2FwZSIsInZpcnR1YWwiLCJmb2N1c0l0ZW1Pbk9wZW4iLCJmb2N1c0l0ZW1PbkhvdmVyIiwib3Blbk9uQXJyb3dLZXlEb3duIiwic2Nyb2xsSXRlbUludG9WaWV3IiwidmlydHVhbEl0ZW1SZWYiLCJqb2luIiwiZm9jdXNJdGVtT25PcGVuUmVmIiwiaW5kZXhSZWYiLCJrZXlSZWYiLCJpc1BvaW50ZXJNb2RhbGl0eVJlZiIsInByZXZpb3VzT25OYXZpZ2F0ZVJlZiIsInByZXZpb3VzTW91bnRlZFJlZiIsImZvcmNlU3luY0ZvY3VzIiwiZm9yY2VTY3JvbGxJbnRvVmlld1JlZiIsImRpc2FibGVkSW5kaWNlc1JlZiIsImxhdGVzdE9wZW5SZWYiLCJzY3JvbGxJdGVtSW50b1ZpZXdSZWYiLCJhY3RpdmVJZCIsInNldEFjdGl2ZUlkIiwidmlydHVhbElkIiwic2V0VmlydHVhbElkIiwiZm9jdXNJdGVtIiwiZm9yY2VTY3JvbGxJbnRvVmlldyIsInNjcm9sbEludG9WaWV3T3B0aW9ucyIsInNob3VsZFNjcm9sbEludG9WaWV3Iiwic2Nyb2xsSW50b1ZpZXciLCJibG9jayIsInJ1bnMiLCJ3YWl0Rm9yTGlzdFBvcHVsYXRlZCIsInNjaGVkdWxlciIsInRyZWVDb250YWluc0FjdGl2ZUVsIiwiaGFuZGxlVmlydHVhbEZvY3VzIiwiaGFzQWN0aXZlSW5kZXgiLCJzeW5jQ3VycmVudFRhcmdldCIsIm9uUG9pbnRlckxlYXZlIiwiX3JlZjQiLCJjdXJyZW50SW5kZXgiLCJtaW4iLCJtYXgiLCJjaGVja1ZpcnR1YWxNb3VzZSIsImNoZWNrVmlydHVhbFBvaW50ZXIiLCJhcmlhQWN0aXZlRGVzY2VuZGFudFByb3AiLCJhY3RpdmVJdGVtIiwiaXNBcnJvd0tleSIsImlzQ3Jvc3NPcGVuS2V5IiwiaXNDcm9zc0Nsb3NlS2V5IiwiaXNNYWluS2V5IiwiaXNOYXZpZ2F0aW9uS2V5IiwidHJpbSIsInJvb3ROb2RlIiwiZGVlcGVzdE5vZGUiLCJldmVudE9iamVjdCIsIktleWJvYXJkRXZlbnQiLCJfZGVlcGVzdE5vZGUkY29udGV4dCIsIl9kZWVwZXN0Tm9kZSRjb250ZXh0MiIsImlzQ3VycmVudFRhcmdldCIsImRpc3BhdGNoSXRlbSIsImRpc3BhdGNoRXZlbnQiLCJfZGVlcGVzdE5vZGUkY29udGV4dCQiLCJvblBvaW50ZXJNb3ZlIiwiY29tcG9uZW50Um9sZVRvQXJpYVJvbGVNYXAiLCJ1c2VSb2xlIiwiX2NvbXBvbmVudFJvbGVUb0FyaWFSIiwiYXJpYVJvbGUiLCJyZWZlcmVuY2VJZCIsImlzTmVzdGVkIiwiZmxvYXRpbmdQcm9wcyIsImFjdGl2ZSIsInNlbGVjdGVkIiwiY29tbW9uUHJvcHMiLCJjYW1lbENhc2VUb0tlYmFiQ2FzZSIsInN0ciIsInJlcGxhY2UiLCIkIiwib2ZzIiwidG9Mb3dlckNhc2UiLCJleGVjV2l0aEFyZ3NPclJldHVybiIsInZhbHVlT3JGbiIsInVzZURlbGF5VW5tb3VudCIsImR1cmF0aW9uTXMiLCJpc01vdW50ZWQiLCJzZXRJc01vdW50ZWQiLCJ1c2VUcmFuc2l0aW9uU3RhdHVzIiwiZHVyYXRpb24iLCJpc051bWJlckR1cmF0aW9uIiwiY2xvc2VEdXJhdGlvbiIsImluaXRpYXRlZCIsInNldEluaXRpYXRlZCIsInN0YXR1cyIsInNldFN0YXR1cyIsImZyYW1lIiwidXNlVHJhbnNpdGlvblN0eWxlcyIsImluaXRpYWwiLCJ1bnN0YWJsZV9pbml0aWFsIiwib3BhY2l0eSIsInVuc3RhYmxlX29wZW4iLCJ1bnN0YWJsZV9jbG9zZSIsImNvbW1vbiIsInVuc3RhYmxlX2NvbW1vbiIsImZuQXJncyIsIm9wZW5EdXJhdGlvbiIsInN0eWxlcyIsInNldFN0eWxlcyIsIm9wZW5SZWYiLCJjbG9zZVJlZiIsImNvbW1vblJlZiIsImluaXRpYWxTdHlsZXMiLCJjbG9zZVN0eWxlcyIsImNvbW1vblN0eWxlcyIsIm9wZW5TdHlsZXMiLCJ0cmFuc2l0aW9uUHJvcGVydHkiLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJ1c2VUeXBlYWhlYWQiLCJvbk1hdGNoIiwidW5zdGFibGVfb25NYXRjaCIsIm9uVHlwaW5nQ2hhbmdlIiwidW5zdGFibGVfb25UeXBpbmdDaGFuZ2UiLCJmaW5kTWF0Y2giLCJyZXNldE1zIiwiaWdub3JlS2V5cyIsInRpbWVvdXRJZFJlZiIsInN0cmluZ1JlZiIsInByZXZJbmRleFJlZiIsIm1hdGNoSW5kZXhSZWYiLCJmaW5kTWF0Y2hSZWYiLCJpZ25vcmVLZXlzUmVmIiwic2V0VHlwaW5nQ2hhbmdlIiwidHlwaW5nIiwiZ2V0TWF0Y2hpbmdJbmRleCIsIm9yZGVyZWRMaXN0Iiwic3RyaW5nIiwidGV4dCIsInRvTG9jYWxlTG93ZXJDYXNlIiwibGlzdENvbnRlbnQiLCJjdHJsS2V5IiwibWV0YUtleSIsImFsdEtleSIsImFsbG93UmFwaWRTdWNjZXNzaW9uT2ZGaXJzdExldHRlciIsIl90ZXh0JCIsIl90ZXh0JDIiLCJnZXRBcmdzV2l0aEN1c3RvbUZsb2F0aW5nSGVpZ2h0IiwicmVjdHMiLCJpbm5lciIsIm92ZXJmbG93UmVmIiwib25GYWxsYmFja0NoYW5nZSIsImlubmVyT2Zmc2V0IiwibWluSXRlbXNWaXNpYmxlIiwicmVmZXJlbmNlT3ZlcmZsb3dUaHJlc2hvbGQiLCJzY3JvbGxSZWYiLCJkZXRlY3RPdmVyZmxvd09wdGlvbnMiLCJzdGFydHNXaXRoIiwibmV4dEFyZ3MiLCJjbGllbnRUb3AiLCJvZmZzZXRIZWlnaHQiLCJyZWZPdmVyZmxvdyIsImVsZW1lbnRDb250ZXh0IiwiZGlmZlkiLCJuZXh0WSIsIm1heEhlaWdodCIsInNjcm9sbFRvcCIsInVzZUlubmVyT2Zmc2V0Iiwib25DaGFuZ2UiLCJ1bnN0YWJsZV9vbkNoYW5nZSIsImNvbnRyb2xsZWRTY3JvbGxpbmdSZWYiLCJwcmV2U2Nyb2xsVG9wUmVmIiwiaW5pdGlhbE92ZXJmbG93UmVmIiwib25XaGVlbCIsImRZIiwiZGVsdGFZIiwiaXNBdFRvcCIsImlzQXRCb3R0b20iLCJyZW1haW5pbmdTY3JvbGwiLCJzaWduIiwibWV0aG9kIiwic2Nyb2xsRGlmZiIsImlzUG9pbnRJblBvbHlnb24iLCJwb2ludCIsInBvbHlnb24iLCJpc0luc2lkZSIsImoiLCJ4aSIsInlpIiwieGoiLCJ5aiIsImludGVyc2VjdCIsInJlY3QiLCJzYWZlUG9seWdvbiIsImJ1ZmZlciIsInJlcXVpcmVJbnRlbnQiLCJoYXNMYW5kZWQiLCJsYXN0WCIsImxhc3RZIiwibGFzdEN1cnNvclRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImdldEN1cnNvclNwZWVkIiwiY3VycmVudFRpbWUiLCJlbGFwc2VkVGltZSIsImRlbHRhWCIsImRpc3RhbmNlIiwic3FydCIsInNwZWVkIiwiY2xpZW50UG9pbnQiLCJpc0xlYXZlIiwiaXNPdmVyRmxvYXRpbmdFbCIsImlzT3ZlclJlZmVyZW5jZUVsIiwicmVmUmVjdCIsImN1cnNvckxlYXZlRnJvbVJpZ2h0IiwiY3Vyc29yTGVhdmVGcm9tQm90dG9tIiwiaXNPdmVyUmVmZXJlbmNlUmVjdCIsImlzRmxvYXRpbmdXaWRlciIsImlzRmxvYXRpbmdUYWxsZXIiLCJyZWN0UG9seSIsImdldFBvbHlnb24iLCJjdXJzb3JQb2ludE9uZSIsImN1cnNvclBvaW50VHdvIiwiY29tbW9uUG9pbnRzIiwiY3Vyc29yU3BlZWQiLCJjdXJzb3JTcGVlZFRocmVzaG9sZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react/utils/dist/floating-ui.react.utils.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@floating-ui/react/utils/dist/floating-ui.react.utils.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TYPEABLE_SELECTOR: () => (/* binding */ TYPEABLE_SELECTOR),\n/* harmony export */   activeElement: () => (/* binding */ activeElement),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   getDocument: () => (/* binding */ getDocument),\n/* harmony export */   getPlatform: () => (/* binding */ getPlatform),\n/* harmony export */   getTarget: () => (/* binding */ getTarget),\n/* harmony export */   getUserAgent: () => (/* binding */ getUserAgent),\n/* harmony export */   isAndroid: () => (/* binding */ isAndroid),\n/* harmony export */   isEventTargetWithin: () => (/* binding */ isEventTargetWithin),\n/* harmony export */   isMac: () => (/* binding */ isMac),\n/* harmony export */   isMouseLikePointerType: () => (/* binding */ isMouseLikePointerType),\n/* harmony export */   isReactEvent: () => (/* binding */ isReactEvent),\n/* harmony export */   isRootElement: () => (/* binding */ isRootElement),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isTypeableCombobox: () => (/* binding */ isTypeableCombobox),\n/* harmony export */   isTypeableElement: () => (/* binding */ isTypeableElement),\n/* harmony export */   isVirtualClick: () => (/* binding */ isVirtualClick),\n/* harmony export */   isVirtualPointerEvent: () => (/* binding */ isVirtualPointerEvent),\n/* harmony export */   stopEvent: () => (/* binding */ stopEvent)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs\");\n\nfunction activeElement(doc) {\n    let activeElement = doc.activeElement;\n    while(((_activeElement = activeElement) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null){\n        var _activeElement;\n        activeElement = activeElement.shadowRoot.activeElement;\n    }\n    return activeElement;\n}\nfunction contains(parent, child) {\n    if (!parent || !child) {\n        return false;\n    }\n    const rootNode = child.getRootNode && child.getRootNode();\n    // First, attempt with faster native method\n    if (parent.contains(child)) {\n        return true;\n    }\n    // then fallback to custom implementation with Shadow DOM support\n    if (rootNode && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(rootNode)) {\n        let next = child;\n        while(next){\n            if (parent === next) {\n                return true;\n            }\n            // @ts-ignore\n            next = next.parentNode || next.host;\n        }\n    }\n    // Give up, the result is false\n    return false;\n}\n// Avoid Chrome DevTools blue warning.\nfunction getPlatform() {\n    const uaData = navigator.userAgentData;\n    if (uaData != null && uaData.platform) {\n        return uaData.platform;\n    }\n    return navigator.platform;\n}\nfunction getUserAgent() {\n    const uaData = navigator.userAgentData;\n    if (uaData && Array.isArray(uaData.brands)) {\n        return uaData.brands.map((_ref)=>{\n            let { brand, version } = _ref;\n            return brand + \"/\" + version;\n        }).join(\" \");\n    }\n    return navigator.userAgent;\n}\n// License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\nfunction isVirtualClick(event) {\n    // FIXME: Firefox is now emitting a deprecation warning for `mozInputSource`.\n    // Try to find a workaround for this. `react-aria` source still has the check.\n    if (event.mozInputSource === 0 && event.isTrusted) {\n        return true;\n    }\n    if (isAndroid() && event.pointerType) {\n        return event.type === \"click\" && event.buttons === 1;\n    }\n    return event.detail === 0 && !event.pointerType;\n}\nfunction isVirtualPointerEvent(event) {\n    return !isAndroid() && event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === \"mouse\" || // iOS VoiceOver returns 0.333â€¢ for width/height.\n    event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0;\n}\nfunction isSafari() {\n    // Chrome DevTools does not complain about navigator.vendor\n    return /apple/i.test(navigator.vendor);\n}\nfunction isAndroid() {\n    const re = /android/i;\n    return re.test(getPlatform()) || re.test(getUserAgent());\n}\nfunction isMac() {\n    return getPlatform().toLowerCase().startsWith(\"mac\") && !navigator.maxTouchPoints;\n}\nfunction isMouseLikePointerType(pointerType, strict) {\n    // On some Linux machines with Chromium, mouse inputs return a `pointerType`\n    // of \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\n    const values = [\n        \"mouse\",\n        \"pen\"\n    ];\n    if (!strict) {\n        values.push(\"\", undefined);\n    }\n    return values.includes(pointerType);\n}\nfunction isReactEvent(event) {\n    return \"nativeEvent\" in event;\n}\nfunction isRootElement(element) {\n    return element.matches(\"html,body\");\n}\nfunction getDocument(node) {\n    return (node == null ? void 0 : node.ownerDocument) || document;\n}\nfunction isEventTargetWithin(event, node) {\n    if (node == null) {\n        return false;\n    }\n    if (\"composedPath\" in event) {\n        return event.composedPath().includes(node);\n    }\n    // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n    const e = event;\n    return e.target != null && node.contains(e.target);\n}\nfunction getTarget(event) {\n    if (\"composedPath\" in event) {\n        return event.composedPath()[0];\n    }\n    // TS thinks `event` is of type never as it assumes all browsers support\n    // `composedPath()`, but browsers without shadow DOM don't.\n    return event.target;\n}\nconst TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nfunction isTypeableElement(element) {\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) && element.matches(TYPEABLE_SELECTOR);\n}\nfunction stopEvent(event) {\n    event.preventDefault();\n    event.stopPropagation();\n}\nfunction isTypeableCombobox(element) {\n    if (!element) return false;\n    return element.getAttribute(\"role\") === \"combobox\" && isTypeableElement(element);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkucmVhY3QudXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFFO0FBRXJFLFNBQVNFLGNBQWNDLEdBQUc7SUFDeEIsSUFBSUQsZ0JBQWdCQyxJQUFJRCxhQUFhO0lBQ3JDLE1BQU8sQ0FBQyxDQUFDRSxpQkFBaUJGLGFBQVksS0FBTSxRQUFRLENBQUNFLGlCQUFpQkEsZUFBZUMsVUFBVSxLQUFLLE9BQU8sS0FBSyxJQUFJRCxlQUFlRixhQUFhLEtBQUssS0FBTTtRQUN6SixJQUFJRTtRQUNKRixnQkFBZ0JBLGNBQWNHLFVBQVUsQ0FBQ0gsYUFBYTtJQUN4RDtJQUNBLE9BQU9BO0FBQ1Q7QUFDQSxTQUFTSSxTQUFTQyxNQUFNLEVBQUVDLEtBQUs7SUFDN0IsSUFBSSxDQUFDRCxVQUFVLENBQUNDLE9BQU87UUFDckIsT0FBTztJQUNUO0lBQ0EsTUFBTUMsV0FBV0QsTUFBTUUsV0FBVyxJQUFJRixNQUFNRSxXQUFXO0lBRXZELDJDQUEyQztJQUMzQyxJQUFJSCxPQUFPRCxRQUFRLENBQUNFLFFBQVE7UUFDMUIsT0FBTztJQUNUO0lBRUEsaUVBQWlFO0lBQ2pFLElBQUlDLFlBQVlULG9FQUFZQSxDQUFDUyxXQUFXO1FBQ3RDLElBQUlFLE9BQU9IO1FBQ1gsTUFBT0csS0FBTTtZQUNYLElBQUlKLFdBQVdJLE1BQU07Z0JBQ25CLE9BQU87WUFDVDtZQUNBLGFBQWE7WUFDYkEsT0FBT0EsS0FBS0MsVUFBVSxJQUFJRCxLQUFLRSxJQUFJO1FBQ3JDO0lBQ0Y7SUFFQSwrQkFBK0I7SUFDL0IsT0FBTztBQUNUO0FBQ0Esc0NBQXNDO0FBQ3RDLFNBQVNDO0lBQ1AsTUFBTUMsU0FBU0MsVUFBVUMsYUFBYTtJQUN0QyxJQUFJRixVQUFVLFFBQVFBLE9BQU9HLFFBQVEsRUFBRTtRQUNyQyxPQUFPSCxPQUFPRyxRQUFRO0lBQ3hCO0lB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LEVBQUU7SUFDaEM7SUFFQSx3RUFBd0U7SUFDeEUsMkRBQTJEO0lBQzNELE9BQU9uQyxNQUFNcUMsTUFBTTtBQUNyQjtBQUNBLE1BQU1FLG9CQUFvQixnREFBZ0Q7QUFDMUUsU0FBU0Msa0JBQWtCWixPQUFPO0lBQ2hDLE9BQU96RCxxRUFBYUEsQ0FBQ3lELFlBQVlBLFFBQVFDLE9BQU8sQ0FBQ1U7QUFDbkQ7QUFDQSxTQUFTRSxVQUFVekMsS0FBSztJQUN0QkEsTUFBTTBDLGNBQWM7SUFDcEIxQyxNQUFNMkMsZUFBZTtBQUN2QjtBQUNBLFNBQVNDLG1CQUFtQmhCLE9BQU87SUFDakMsSUFBSSxDQUFDQSxTQUFTLE9BQU87SUFDckIsT0FBT0EsUUFBUWlCLFlBQVksQ0FBQyxZQUFZLGNBQWNMLGtCQUFrQlo7QUFDMUU7QUFFd1MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iZW5nZ3JpLmdpdGh1Yi5pby8uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvcmVhY3QvdXRpbHMvZGlzdC9mbG9hdGluZy11aS5yZWFjdC51dGlscy5tanM/NTM1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1NoYWRvd1Jvb3QsIGlzSFRNTEVsZW1lbnQgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcblxuZnVuY3Rpb24gYWN0aXZlRWxlbWVudChkb2MpIHtcbiAgbGV0IGFjdGl2ZUVsZW1lbnQgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgd2hpbGUgKCgoX2FjdGl2ZUVsZW1lbnQgPSBhY3RpdmVFbGVtZW50KSA9PSBudWxsIHx8IChfYWN0aXZlRWxlbWVudCA9IF9hY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QpID09IG51bGwgPyB2b2lkIDAgOiBfYWN0aXZlRWxlbWVudC5hY3RpdmVFbGVtZW50KSAhPSBudWxsKSB7XG4gICAgdmFyIF9hY3RpdmVFbGVtZW50O1xuICAgIGFjdGl2ZUVsZW1lbnQgPSBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcbiAgfVxuICByZXR1cm4gYWN0aXZlRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgaWYgKCFwYXJlbnQgfHwgIWNoaWxkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKTtcblxuICAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG4gIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBpZiAocm9vdE5vZGUgJiYgaXNTaGFkb3dSb290KHJvb3ROb2RlKSkge1xuICAgIGxldCBuZXh0ID0gY2hpbGQ7XG4gICAgd2hpbGUgKG5leHQpIHtcbiAgICAgIGlmIChwYXJlbnQgPT09IG5leHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBuZXh0ID0gbmV4dC5wYXJlbnROb2RlIHx8IG5leHQuaG9zdDtcbiAgICB9XG4gIH1cblxuICAvLyBHaXZlIHVwLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIEF2b2lkIENocm9tZSBEZXZUb29scyBibHVlIHdhcm5pbmcuXG5mdW5jdGlvbiBnZXRQbGF0Zm9ybSgpIHtcbiAgY29uc3QgdWFEYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG4gIGlmICh1YURhdGEgIT0gbnVsbCAmJiB1YURhdGEucGxhdGZvcm0pIHtcbiAgICByZXR1cm4gdWFEYXRhLnBsYXRmb3JtO1xuICB9XG4gIHJldHVybiBuYXZpZ2F0b3IucGxhdGZvcm07XG59XG5mdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gIGNvbnN0IHVhRGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuICBpZiAodWFEYXRhICYmIEFycmF5LmlzQXJyYXkodWFEYXRhLmJyYW5kcykpIHtcbiAgICByZXR1cm4gdWFEYXRhLmJyYW5kcy5tYXAoX3JlZiA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBicmFuZCxcbiAgICAgICAgdmVyc2lvblxuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4gYnJhbmQgKyBcIi9cIiArIHZlcnNpb247XG4gICAgfSkuam9pbignICcpO1xuICB9XG4gIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xufVxuXG4vLyBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vYWRvYmUvcmVhY3Qtc3BlY3RydW0vYmxvYi9iMzVkNWMwMmZlOTAwYmFkY2NkMGNmMWE4ZjIzYmI1OTM0MTlmMjM4L3BhY2thZ2VzL0ByZWFjdC1hcmlhL3V0aWxzL3NyYy9pc1ZpcnR1YWxFdmVudC50c1xuZnVuY3Rpb24gaXNWaXJ0dWFsQ2xpY2soZXZlbnQpIHtcbiAgLy8gRklYTUU6IEZpcmVmb3ggaXMgbm93IGVtaXR0aW5nIGEgZGVwcmVjYXRpb24gd2FybmluZyBmb3IgYG1veklucHV0U291cmNlYC5cbiAgLy8gVHJ5IHRvIGZpbmQgYSB3b3JrYXJvdW5kIGZvciB0aGlzLiBgcmVhY3QtYXJpYWAgc291cmNlIHN0aWxsIGhhcyB0aGUgY2hlY2suXG4gIGlmIChldmVudC5tb3pJbnB1dFNvdXJjZSA9PT0gMCAmJiBldmVudC5pc1RydXN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNBbmRyb2lkKCkgJiYgZXZlbnQucG9pbnRlclR5cGUpIHtcbiAgICByZXR1cm4gZXZlbnQudHlwZSA9PT0gJ2NsaWNrJyAmJiBldmVudC5idXR0b25zID09PSAxO1xuICB9XG4gIHJldHVybiBldmVudC5kZXRhaWwgPT09IDAgJiYgIWV2ZW50LnBvaW50ZXJUeXBlO1xufVxuZnVuY3Rpb24gaXNWaXJ0dWFsUG9pbnRlckV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAhaXNBbmRyb2lkKCkgJiYgZXZlbnQud2lkdGggPT09IDAgJiYgZXZlbnQuaGVpZ2h0ID09PSAwIHx8IGV2ZW50LndpZHRoID09PSAxICYmIGV2ZW50LmhlaWdodCA9PT0gMSAmJiBldmVudC5wcmVzc3VyZSA9PT0gMCAmJiBldmVudC5kZXRhaWwgPT09IDAgJiYgZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHxcbiAgLy8gaU9TIFZvaWNlT3ZlciByZXR1cm5zIDAuMzMz4oCiIGZvciB3aWR0aC9oZWlnaHQuXG4gIGV2ZW50LndpZHRoIDwgMSAmJiBldmVudC5oZWlnaHQgPCAxICYmIGV2ZW50LnByZXNzdXJlID09PSAwICYmIGV2ZW50LmRldGFpbCA9PT0gMDtcbn1cbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICAvLyBDaHJvbWUgRGV2VG9vbHMgZG9lcyBub3QgY29tcGxhaW4gYWJvdXQgbmF2aWdhdG9yLnZlbmRvclxuICByZXR1cm4gL2FwcGxlL2kudGVzdChuYXZpZ2F0b3IudmVuZG9yKTtcbn1cbmZ1bmN0aW9uIGlzQW5kcm9pZCgpIHtcbiAgY29uc3QgcmUgPSAvYW5kcm9pZC9pO1xuICByZXR1cm4gcmUudGVzdChnZXRQbGF0Zm9ybSgpKSB8fCByZS50ZXN0KGdldFVzZXJBZ2VudCgpKTtcbn1cbmZ1bmN0aW9uIGlzTWFjKCkge1xuICByZXR1cm4gZ2V0UGxhdGZvcm0oKS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ21hYycpICYmICFuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHM7XG59XG5mdW5jdGlvbiBpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlLCBzdHJpY3QpIHtcbiAgLy8gT24gc29tZSBMaW51eCBtYWNoaW5lcyB3aXRoIENocm9taXVtLCBtb3VzZSBpbnB1dHMgcmV0dXJuIGEgYHBvaW50ZXJUeXBlYFxuICAvLyBvZiBcInBlblwiOiBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzIwMTVcbiAgY29uc3QgdmFsdWVzID0gWydtb3VzZScsICdwZW4nXTtcbiAgaWYgKCFzdHJpY3QpIHtcbiAgICB2YWx1ZXMucHVzaCgnJywgdW5kZWZpbmVkKTtcbiAgfVxuICByZXR1cm4gdmFsdWVzLmluY2x1ZGVzKHBvaW50ZXJUeXBlKTtcbn1cbmZ1bmN0aW9uIGlzUmVhY3RFdmVudChldmVudCkge1xuICByZXR1cm4gJ25hdGl2ZUV2ZW50JyBpbiBldmVudDtcbn1cbmZ1bmN0aW9uIGlzUm9vdEVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKCdodG1sLGJvZHknKTtcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIChub2RlID09IG51bGwgPyB2b2lkIDAgOiBub2RlLm93bmVyRG9jdW1lbnQpIHx8IGRvY3VtZW50O1xufVxuZnVuY3Rpb24gaXNFdmVudFRhcmdldFdpdGhpbihldmVudCwgbm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgnY29tcG9zZWRQYXRoJyBpbiBldmVudCkge1xuICAgIHJldHVybiBldmVudC5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhub2RlKTtcbiAgfVxuXG4gIC8vIFRTIHRoaW5rcyBgZXZlbnRgIGlzIG9mIHR5cGUgbmV2ZXIgYXMgaXQgYXNzdW1lcyBhbGwgYnJvd3NlcnMgc3VwcG9ydCBjb21wb3NlZFBhdGgsIGJ1dCBicm93c2VycyB3aXRob3V0IHNoYWRvdyBkb20gZG9uJ3RcbiAgY29uc3QgZSA9IGV2ZW50O1xuICByZXR1cm4gZS50YXJnZXQgIT0gbnVsbCAmJiBub2RlLmNvbnRhaW5zKGUudGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGdldFRhcmdldChldmVudCkge1xuICBpZiAoJ2NvbXBvc2VkUGF0aCcgaW4gZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuY29tcG9zZWRQYXRoKClbMF07XG4gIH1cblxuICAvLyBUUyB0aGlua3MgYGV2ZW50YCBpcyBvZiB0eXBlIG5ldmVyIGFzIGl0IGFzc3VtZXMgYWxsIGJyb3dzZXJzIHN1cHBvcnRcbiAgLy8gYGNvbXBvc2VkUGF0aCgpYCwgYnV0IGJyb3dzZXJzIHdpdGhvdXQgc2hhZG93IERPTSBkb24ndC5cbiAgcmV0dXJuIGV2ZW50LnRhcmdldDtcbn1cbmNvbnN0IFRZUEVBQkxFX1NFTEVDVE9SID0gXCJpbnB1dDpub3QoW3R5cGU9J2hpZGRlbiddKTpub3QoW2Rpc2FibGVkXSksXCIgKyBcIltjb250ZW50ZWRpdGFibGVdOm5vdChbY29udGVudGVkaXRhYmxlPSdmYWxzZSddKSx0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSlcIjtcbmZ1bmN0aW9uIGlzVHlwZWFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgJiYgZWxlbWVudC5tYXRjaGVzKFRZUEVBQkxFX1NFTEVDVE9SKTtcbn1cbmZ1bmN0aW9uIHN0b3BFdmVudChldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cbmZ1bmN0aW9uIGlzVHlwZWFibGVDb21ib2JveChlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSA9PT0gJ2NvbWJvYm94JyAmJiBpc1R5cGVhYmxlRWxlbWVudChlbGVtZW50KTtcbn1cblxuZXhwb3J0IHsgVFlQRUFCTEVfU0VMRUNUT1IsIGFjdGl2ZUVsZW1lbnQsIGNvbnRhaW5zLCBnZXREb2N1bWVudCwgZ2V0UGxhdGZvcm0sIGdldFRhcmdldCwgZ2V0VXNlckFnZW50LCBpc0FuZHJvaWQsIGlzRXZlbnRUYXJnZXRXaXRoaW4sIGlzTWFjLCBpc01vdXNlTGlrZVBvaW50ZXJUeXBlLCBpc1JlYWN0RXZlbnQsIGlzUm9vdEVsZW1lbnQsIGlzU2FmYXJpLCBpc1R5cGVhYmxlQ29tYm9ib3gsIGlzVHlwZWFibGVFbGVtZW50LCBpc1ZpcnR1YWxDbGljaywgaXNWaXJ0dWFsUG9pbnRlckV2ZW50LCBzdG9wRXZlbnQgfTtcbiJdLCJuYW1lcyI6WyJpc1NoYWRvd1Jvb3QiLCJpc0hUTUxFbGVtZW50IiwiYWN0aXZlRWxlbWVudCIsImRvYyIsIl9hY3RpdmVFbGVtZW50Iiwic2hhZG93Um9vdCIsImNvbnRhaW5zIiwicGFyZW50IiwiY2hpbGQiLCJyb290Tm9kZSIsImdldFJvb3ROb2RlIiwibmV4dCIsInBhcmVudE5vZGUiLCJob3N0IiwiZ2V0UGxhdGZvcm0iLCJ1YURhdGEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnREYXRhIiwicGxhdGZvcm0iLCJnZXRVc2VyQWdlbnQiLCJBcnJheSIsImlzQXJyYXkiLCJicmFuZHMiLCJtYXAiLCJfcmVmIiwiYnJhbmQiLCJ2ZXJzaW9uIiwiam9pbiIsInVzZXJBZ2VudCIsImlzVmlydHVhbENsaWNrIiwiZXZlbnQiLCJtb3pJbnB1dFNvdXJjZSIsImlzVHJ1c3RlZCIsImlzQW5kcm9pZCIsInBvaW50ZXJUeXBlIiwidHlwZSIsImJ1dHRvbnMiLCJkZXRhaWwiLCJpc1ZpcnR1YWxQb2ludGVyRXZlbnQiLCJ3aWR0aCIsImhlaWdodCIsInByZXNzdXJlIiwiaXNTYWZhcmkiLCJ0ZXN0IiwidmVuZG9yIiwicmUiLCJpc01hYyIsInRvTG93ZXJDYXNlIiwic3RhcnRzV2l0aCIsIm1heFRvdWNoUG9pbnRzIiwiaXNNb3VzZUxpa2VQb2ludGVyVHlwZSIsInN0cmljdCIsInZhbHVlcyIsInB1c2giLCJ1bmRlZmluZWQiLCJpbmNsdWRlcyIsImlzUmVhY3RFdmVudCIsImlzUm9vdEVsZW1lbnQiLCJlbGVtZW50IiwibWF0Y2hlcyIsImdldERvY3VtZW50Iiwibm9kZSIsIm93bmVyRG9jdW1lbnQiLCJkb2N1bWVudCIsImlzRXZlbnRUYXJnZXRXaXRoaW4iLCJjb21wb3NlZFBhdGgiLCJlIiwidGFyZ2V0IiwiZ2V0VGFyZ2V0IiwiVFlQRUFCTEVfU0VMRUNUT1IiLCJpc1R5cGVhYmxlRWxlbWVudCIsInN0b3BFdmVudCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiaXNUeXBlYWJsZUNvbWJvYm94IiwiZ2V0QXR0cmlidXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react/utils/dist/floating-ui.react.utils.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   alignments: () => (/* binding */ alignments),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   createCoords: () => (/* binding */ createCoords),\n/* harmony export */   evaluate: () => (/* binding */ evaluate),\n/* harmony export */   expandPaddingObject: () => (/* binding */ expandPaddingObject),\n/* harmony export */   floor: () => (/* binding */ floor),\n/* harmony export */   getAlignment: () => (/* binding */ getAlignment),\n/* harmony export */   getAlignmentAxis: () => (/* binding */ getAlignmentAxis),\n/* harmony export */   getAlignmentSides: () => (/* binding */ getAlignmentSides),\n/* harmony export */   getAxisLength: () => (/* binding */ getAxisLength),\n/* harmony export */   getExpandedPlacements: () => (/* binding */ getExpandedPlacements),\n/* harmony export */   getOppositeAlignmentPlacement: () => (/* binding */ getOppositeAlignmentPlacement),\n/* harmony export */   getOppositeAxis: () => (/* binding */ getOppositeAxis),\n/* harmony export */   getOppositeAxisPlacements: () => (/* binding */ getOppositeAxisPlacements),\n/* harmony export */   getOppositePlacement: () => (/* binding */ getOppositePlacement),\n/* harmony export */   getPaddingObject: () => (/* binding */ getPaddingObject),\n/* harmony export */   getSide: () => (/* binding */ getSide),\n/* harmony export */   getSideAxis: () => (/* binding */ getSideAxis),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   placements: () => (/* binding */ placements),\n/* harmony export */   rectToClientRect: () => (/* binding */ rectToClientRect),\n/* harmony export */   round: () => (/* binding */ round),\n/* harmony export */   sides: () => (/* binding */ sides)\n/* harmony export */ });\nconst sides = [\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\"\n];\nconst alignments = [\n    \"start\",\n    \"end\"\n];\nconst placements = /*#__PURE__*/ sides.reduce((acc, side)=>acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = (v)=>({\n        x: v,\n        y: v\n    });\nconst oppositeSideMap = {\n    left: \"right\",\n    right: \"left\",\n    bottom: \"top\",\n    top: \"bottom\"\n};\nconst oppositeAlignmentMap = {\n    start: \"end\",\n    end: \"start\"\n};\nfunction clamp(start, value, end) {\n    return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n    return typeof value === \"function\" ? value(param) : value;\n}\nfunction getSide(placement) {\n    return placement.split(\"-\")[0];\n}\nfunction getAlignment(placement) {\n    return placement.split(\"-\")[1];\n}\nfunction getOppositeAxis(axis) {\n    return axis === \"x\" ? \"y\" : \"x\";\n}\nfunction getAxisLength(axis) {\n    return axis === \"y\" ? \"height\" : \"width\";\n}\nfunction getSideAxis(placement) {\n    return [\n        \"top\",\n        \"bottom\"\n    ].includes(getSide(placement)) ? \"y\" : \"x\";\n}\nfunction getAlignmentAxis(placement) {\n    return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n    if (rtl === void 0) {\n        rtl = false;\n    }\n    const alignment = getAlignment(placement);\n    const alignmentAxis = getAlignmentAxis(placement);\n    const length = getAxisLength(alignmentAxis);\n    let mainAlignmentSide = alignmentAxis === \"x\" ? alignment === (rtl ? \"end\" : \"start\") ? \"right\" : \"left\" : alignment === \"start\" ? \"bottom\" : \"top\";\n    if (rects.reference[length] > rects.floating[length]) {\n        mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n    }\n    return [\n        mainAlignmentSide,\n        getOppositePlacement(mainAlignmentSide)\n    ];\n}\nfunction getExpandedPlacements(placement) {\n    const oppositePlacement = getOppositePlacement(placement);\n    return [\n        getOppositeAlignmentPlacement(placement),\n        oppositePlacement,\n        getOppositeAlignmentPlacement(oppositePlacement)\n    ];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n    return placement.replace(/start|end/g, (alignment)=>oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n    const lr = [\n        \"left\",\n        \"right\"\n    ];\n    const rl = [\n        \"right\",\n        \"left\"\n    ];\n    const tb = [\n        \"top\",\n        \"bottom\"\n    ];\n    const bt = [\n        \"bottom\",\n        \"top\"\n    ];\n    switch(side){\n        case \"top\":\n        case \"bottom\":\n            if (rtl) return isStart ? rl : lr;\n            return isStart ? lr : rl;\n        case \"left\":\n        case \"right\":\n            return isStart ? tb : bt;\n        default:\n            return [];\n    }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n    const alignment = getAlignment(placement);\n    let list = getSideList(getSide(placement), direction === \"start\", rtl);\n    if (alignment) {\n        list = list.map((side)=>side + \"-\" + alignment);\n        if (flipAlignment) {\n            list = list.concat(list.map(getOppositeAlignmentPlacement));\n        }\n    }\n    return list;\n}\nfunction getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, (side)=>oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n    return {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0,\n        ...padding\n    };\n}\nfunction getPaddingObject(padding) {\n    return typeof padding !== \"number\" ? expandPaddingObject(padding) : {\n        top: padding,\n        right: padding,\n        bottom: padding,\n        left: padding\n    };\n}\nfunction rectToClientRect(rect) {\n    return {\n        ...rect,\n        top: rect.y,\n        left: rect.x,\n        right: rect.x + rect.width,\n        bottom: rect.y + rect.height\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQU1BLFFBQVE7SUFBQztJQUFPO0lBQVM7SUFBVTtDQUFPO0FBQ2hELE1BQU1DLGFBQWE7SUFBQztJQUFTO0NBQU07QUFDbkMsTUFBTUMsYUFBYSxXQUFXLEdBQUVGLE1BQU1HLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxPQUFTRCxJQUFJRSxNQUFNLENBQUNELE1BQU1BLE9BQU8sTUFBTUosVUFBVSxDQUFDLEVBQUUsRUFBRUksT0FBTyxNQUFNSixVQUFVLENBQUMsRUFBRSxHQUFHLEVBQUU7QUFDeEksTUFBTU0sTUFBTUMsS0FBS0QsR0FBRztBQUNwQixNQUFNRSxNQUFNRCxLQUFLQyxHQUFHO0FBQ3BCLE1BQU1DLFFBQVFGLEtBQUtFLEtBQUs7QUFDeEIsTUFBTUMsUUFBUUgsS0FBS0csS0FBSztBQUN4QixNQUFNQyxlQUFlQyxDQUFBQSxJQUFNO1FBQ3pCQyxHQUFHRDtRQUNIRSxHQUFHRjtJQUNMO0FBQ0EsTUFBTUcsa0JBQWtCO0lBQ3RCQyxNQUFNO0lBQ05DLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxLQUFLO0FBQ1A7QUFDQSxNQUFNQyx1QkFBdUI7SUFDM0JDLE9BQU87SUFDUEMsS0FBSztBQUNQO0FBQ0EsU0FBU0MsTUFBTUYsS0FBSyxFQUFFRyxLQUFLLEVBQUVGLEdBQUc7SUFDOUIsT0FBT2QsSUFBSWEsT0FBT2YsSUFBSWtCLE9BQU9GO0FBQy9CO0FBQ0EsU0FBU0csU0FBU0QsS0FBSyxFQUFFRSxLQUFLO0lBQzVCLE9BQU8sT0FBT0YsVUFBVSxhQUFhQSxNQUFNRSxTQUFTRjtBQUN0RDtBQUNBLFNBQVNHLFFBQVFDLFNBQVM7SUFDeEIsT0FBT0EsVUFBVUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ2hDO0FBQ0EsU0FBU0MsYUFBYUYsU0FB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T0EsWUFBWSxXQUFXRCxvQkFBb0JDLFdBQVc7UUFDbEU1QyxLQUFLNEM7UUFDTDlDLE9BQU84QztRQUNQN0MsUUFBUTZDO1FBQ1IvQyxNQUFNK0M7SUFDUjtBQUNGO0FBQ0EsU0FBU0UsaUJBQWlCQyxJQUFJO0lBQzVCLE9BQU87UUFDTCxHQUFHQSxJQUFJO1FBQ1AvQyxLQUFLK0MsS0FBS3BELENBQUM7UUFDWEUsTUFBTWtELEtBQUtyRCxDQUFDO1FBQ1pJLE9BQU9pRCxLQUFLckQsQ0FBQyxHQUFHcUQsS0FBS0MsS0FBSztRQUMxQmpELFFBQVFnRCxLQUFLcEQsQ0FBQyxHQUFHb0QsS0FBS0UsTUFBTTtJQUM5QjtBQUNGO0FBRXlXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmVuZ2dyaS5naXRodWIuaW8vLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMubWpzPzVhZWEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgc2lkZXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuY29uc3QgYWxpZ25tZW50cyA9IFsnc3RhcnQnLCAnZW5kJ107XG5jb25zdCBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL3NpZGVzLnJlZHVjZSgoYWNjLCBzaWRlKSA9PiBhY2MuY29uY2F0KHNpZGUsIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMF0sIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMV0pLCBbXSk7XG5jb25zdCBtaW4gPSBNYXRoLm1pbjtcbmNvbnN0IG1heCA9IE1hdGgubWF4O1xuY29uc3Qgcm91bmQgPSBNYXRoLnJvdW5kO1xuY29uc3QgZmxvb3IgPSBNYXRoLmZsb29yO1xuY29uc3QgY3JlYXRlQ29vcmRzID0gdiA9PiAoe1xuICB4OiB2LFxuICB5OiB2XG59KTtcbmNvbnN0IG9wcG9zaXRlU2lkZU1hcCA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmNvbnN0IG9wcG9zaXRlQWxpZ25tZW50TWFwID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmZ1bmN0aW9uIGNsYW1wKHN0YXJ0LCB2YWx1ZSwgZW5kKSB7XG4gIHJldHVybiBtYXgoc3RhcnQsIG1pbih2YWx1ZSwgZW5kKSk7XG59XG5mdW5jdGlvbiBldmFsdWF0ZSh2YWx1ZSwgcGFyYW0pIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKHBhcmFtKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0U2lkZShwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0xlbmd0aChheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG59XG5mdW5jdGlvbiBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluY2x1ZGVzKGdldFNpZGUocGxhY2VtZW50KSkgPyAneScgOiAneCc7XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCkge1xuICByZXR1cm4gZ2V0T3Bwb3NpdGVBeGlzKGdldFNpZGVBeGlzKHBsYWNlbWVudCkpO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKSB7XG4gIGlmIChydGwgPT09IHZvaWQgMCkge1xuICAgIHJ0bCA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnRBeGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICBjb25zdCBsZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBsZXQgbWFpbkFsaWdubWVudFNpZGUgPSBhbGlnbm1lbnRBeGlzID09PSAneCcgPyBhbGlnbm1lbnQgPT09IChydGwgPyAnZW5kJyA6ICdzdGFydCcpID8gJ3JpZ2h0JyA6ICdsZWZ0JyA6IGFsaWdubWVudCA9PT0gJ3N0YXJ0JyA/ICdib3R0b20nIDogJ3RvcCc7XG4gIGlmIChyZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSA+IHJlY3RzLmZsb2F0aW5nW2xlbmd0aF0pIHtcbiAgICBtYWluQWxpZ25tZW50U2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5BbGlnbm1lbnRTaWRlKTtcbiAgfVxuICByZXR1cm4gW21haW5BbGlnbm1lbnRTaWRlLCBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluQWxpZ25tZW50U2lkZSldO1xufVxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBjb25zdCBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgYWxpZ25tZW50ID0+IG9wcG9zaXRlQWxpZ25tZW50TWFwW2FsaWdubWVudF0pO1xufVxuZnVuY3Rpb24gZ2V0U2lkZUxpc3Qoc2lkZSwgaXNTdGFydCwgcnRsKSB7XG4gIGNvbnN0IGxyID0gWydsZWZ0JywgJ3JpZ2h0J107XG4gIGNvbnN0IHJsID0gWydyaWdodCcsICdsZWZ0J107XG4gIGNvbnN0IHRiID0gWyd0b3AnLCAnYm90dG9tJ107XG4gIGNvbnN0IGJ0ID0gWydib3R0b20nLCAndG9wJ107XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIGlmIChydGwpIHJldHVybiBpc1N0YXJ0ID8gcmwgOiBscjtcbiAgICAgIHJldHVybiBpc1N0YXJ0ID8gbHIgOiBybDtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICByZXR1cm4gaXNTdGFydCA/IHRiIDogYnQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBbXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyhwbGFjZW1lbnQsIGZsaXBBbGlnbm1lbnQsIGRpcmVjdGlvbiwgcnRsKSB7XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBsZXQgbGlzdCA9IGdldFNpZGVMaXN0KGdldFNpZGUocGxhY2VtZW50KSwgZGlyZWN0aW9uID09PSAnc3RhcnQnLCBydGwpO1xuICBpZiAoYWxpZ25tZW50KSB7XG4gICAgbGlzdCA9IGxpc3QubWFwKHNpZGUgPT4gc2lkZSArIFwiLVwiICsgYWxpZ25tZW50KTtcbiAgICBpZiAoZmxpcEFsaWdubWVudCkge1xuICAgICAgbGlzdCA9IGxpc3QuY29uY2F0KGxpc3QubWFwKGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsaXN0O1xufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIHNpZGUgPT4gb3Bwb3NpdGVTaWRlTWFwW3NpZGVdKTtcbn1cbmZ1bmN0aW9uIGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICAuLi5wYWRkaW5nXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykgOiB7XG4gICAgdG9wOiBwYWRkaW5nLFxuICAgIHJpZ2h0OiBwYWRkaW5nLFxuICAgIGJvdHRvbTogcGFkZGluZyxcbiAgICBsZWZ0OiBwYWRkaW5nXG4gIH07XG59XG5mdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5yZWN0LFxuICAgIHRvcDogcmVjdC55LFxuICAgIGxlZnQ6IHJlY3QueCxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbmV4cG9ydCB7IGFsaWdubWVudHMsIGNsYW1wLCBjcmVhdGVDb29yZHMsIGV2YWx1YXRlLCBleHBhbmRQYWRkaW5nT2JqZWN0LCBmbG9vciwgZ2V0QWxpZ25tZW50LCBnZXRBbGlnbm1lbnRBeGlzLCBnZXRBbGlnbm1lbnRTaWRlcywgZ2V0QXhpc0xlbmd0aCwgZ2V0RXhwYW5kZWRQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVBeGlzLCBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZVBsYWNlbWVudCwgZ2V0UGFkZGluZ09iamVjdCwgZ2V0U2lkZSwgZ2V0U2lkZUF4aXMsIG1heCwgbWluLCBwbGFjZW1lbnRzLCByZWN0VG9DbGllbnRSZWN0LCByb3VuZCwgc2lkZXMgfTtcbiJdLCJuYW1lcyI6WyJzaWRlcyIsImFsaWdubWVudHMiLCJwbGFjZW1lbnRzIiwicmVkdWNlIiwiYWNjIiwic2lkZSIsImNvbmNhdCIsIm1pbiIsIk1hdGgiLCJtYXgiLCJyb3VuZCIsImZsb29yIiwiY3JlYXRlQ29vcmRzIiwidiIsIngiLCJ5Iiwib3Bwb3NpdGVTaWRlTWFwIiwibGVmdCIsInJpZ2h0IiwiYm90dG9tIiwidG9wIiwib3Bwb3NpdGVBbGlnbm1lbnRNYXAiLCJzdGFydCIsImVuZCIsImNsYW1wIiwidmFsdWUiLCJldmFsdWF0ZSIsInBhcmFtIiwiZ2V0U2lkZSIsInBsYWNlbWVudCIsInNwbGl0IiwiZ2V0QWxpZ25tZW50IiwiZ2V0T3Bwb3NpdGVBeGlzIiwiYXhpcyIsImdldEF4aXNMZW5ndGgiLCJnZXRTaWRlQXhpcyIsImluY2x1ZGVzIiwiZ2V0QWxpZ25tZW50QXhpcyIsImdldEFsaWdubWVudFNpZGVzIiwicmVjdHMiLCJydGwiLCJhbGlnbm1lbnQiLCJhbGlnbm1lbnRBeGlzIiwibGVuZ3RoIiwibWFpbkFsaWdubWVudFNpZGUiLCJyZWZlcmVuY2UiLCJmbG9hdGluZyIsImdldE9wcG9zaXRlUGxhY2VtZW50IiwiZ2V0RXhwYW5kZWRQbGFjZW1lbnRzIiwib3Bwb3NpdGVQbGFjZW1lbnQiLCJnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCIsInJlcGxhY2UiLCJnZXRTaWRlTGlzdCIsImlzU3RhcnQiLCJsciIsInJsIiwidGIiLCJidCIsImdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMiLCJmbGlwQWxpZ25tZW50IiwiZGlyZWN0aW9uIiwibGlzdCIsIm1hcCIsImV4cGFuZFBhZGRpbmdPYmplY3QiLCJwYWRkaW5nIiwiZ2V0UGFkZGluZ09iamVjdCIsInJlY3RUb0NsaWVudFJlY3QiLCJyZWN0Iiwid2lkdGgiLCJoZWlnaHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getComputedStyle: () => (/* binding */ getComputedStyle),\n/* harmony export */   getContainingBlock: () => (/* binding */ getContainingBlock),\n/* harmony export */   getDocumentElement: () => (/* binding */ getDocumentElement),\n/* harmony export */   getNearestOverflowAncestor: () => (/* binding */ getNearestOverflowAncestor),\n/* harmony export */   getNodeName: () => (/* binding */ getNodeName),\n/* harmony export */   getNodeScroll: () => (/* binding */ getNodeScroll),\n/* harmony export */   getOverflowAncestors: () => (/* binding */ getOverflowAncestors),\n/* harmony export */   getParentNode: () => (/* binding */ getParentNode),\n/* harmony export */   getWindow: () => (/* binding */ getWindow),\n/* harmony export */   isContainingBlock: () => (/* binding */ isContainingBlock),\n/* harmony export */   isElement: () => (/* binding */ isElement),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isLastTraversableNode: () => (/* binding */ isLastTraversableNode),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isOverflowElement: () => (/* binding */ isOverflowElement),\n/* harmony export */   isShadowRoot: () => (/* binding */ isShadowRoot),\n/* harmony export */   isTableElement: () => (/* binding */ isTableElement),\n/* harmony export */   isWebKit: () => (/* binding */ isWebKit)\n/* harmony export */ });\nfunction getNodeName(node) {\n    if (isNode(node)) {\n        return (node.nodeName || \"\").toLowerCase();\n    }\n    // Mocked nodes in testing environments may not be instances of Node. By\n    // returning `#document` an infinite loop won't occur.\n    // https://github.com/floating-ui/floating-ui/issues/2317\n    return \"#document\";\n}\nfunction getWindow(node) {\n    var _node$ownerDocument;\n    return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n    var _ref;\n    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n    return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n    return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n    // Browsers without `ShadowRoot` support.\n    if (typeof ShadowRoot === \"undefined\") {\n        return false;\n    }\n    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n    const { overflow, overflowX, overflowY, display } = getComputedStyle(element);\n    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && ![\n        \"inline\",\n        \"contents\"\n    ].includes(display);\n}\nfunction isTableElement(element) {\n    return [\n        \"table\",\n        \"td\",\n        \"th\"\n    ].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n    const webkit = isWebKit();\n    const css = getComputedStyle(element);\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    return css.transform !== \"none\" || css.perspective !== \"none\" || (css.containerType ? css.containerType !== \"normal\" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== \"none\" : false) || !webkit && (css.filter ? css.filter !== \"none\" : false) || [\n        \"transform\",\n        \"perspective\",\n        \"filter\"\n    ].some((value)=>(css.willChange || \"\").includes(value)) || [\n        \"paint\",\n        \"layout\",\n        \"strict\",\n        \"content\"\n    ].some((value)=>(css.contain || \"\").includes(value));\n}\nfunction getContainingBlock(element) {\n    let currentNode = getParentNode(element);\n    while(isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)){\n        if (isContainingBlock(currentNode)) {\n            return currentNode;\n        } else {\n            currentNode = getParentNode(currentNode);\n        }\n    }\n    return null;\n}\nfunction isWebKit() {\n    if (typeof CSS === \"undefined\" || !CSS.supports) return false;\n    return CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nfunction isLastTraversableNode(node) {\n    return [\n        \"html\",\n        \"body\",\n        \"#document\"\n    ].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n    return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n    if (isElement(element)) {\n        return {\n            scrollLeft: element.scrollLeft,\n            scrollTop: element.scrollTop\n        };\n    }\n    return {\n        scrollLeft: element.pageXOffset,\n        scrollTop: element.pageYOffset\n    };\n}\nfunction getParentNode(node) {\n    if (getNodeName(node) === \"html\") {\n        return node;\n    }\n    const result = // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot || // DOM Element detected.\n    node.parentNode || // ShadowRoot detected.\n    isShadowRoot(node) && node.host || // Fallback.\n    getDocumentElement(node);\n    return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n    const parentNode = getParentNode(node);\n    if (isLastTraversableNode(parentNode)) {\n        return node.ownerDocument ? node.ownerDocument.body : node.body;\n    }\n    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n        return parentNode;\n    }\n    return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n    var _node$ownerDocument2;\n    if (list === void 0) {\n        list = [];\n    }\n    if (traverseIframes === void 0) {\n        traverseIframes = true;\n    }\n    const scrollableAncestor = getNearestOverflowAncestor(node);\n    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n    const win = getWindow(scrollableAncestor);\n    if (isBody) {\n        return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n    }\n    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLnV0aWxzLmRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsU0FBU0EsWUFBWUMsSUFBSTtJQUN2QixJQUFJQyxPQUFPRCxPQUFPO1FBQ2hCLE9BQU8sQ0FBQ0EsS0FBS0UsUUFBUSxJQUFJLEVBQUMsRUFBR0MsV0FBVztJQUMxQztJQUNBLHdFQUF3RTtJQUN4RSxzREFBc0Q7SUFDdEQseURBQXlEO0lBQ3pELE9BQU87QUFDVDtBQUNBLFNBQVNDLFVBQVVKLElBQUk7SUFDckIsSUFBSUs7SUFDSixPQUFPLENBQUNMLFFBQVEsT0FBTyxLQUFLLElBQUksQ0FBQ0ssc0JBQXNCTCxLQUFLTSxhQUFhLEtBQUssT0FBTyxLQUFLLElBQUlELG9CQUFvQkUsV0FBVyxLQUFLQztBQUNwSTtBQUNBLFNBQVNDLG1CQUFtQlQsSUFBSTtJQUM5QixJQUFJVTtJQUNKLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDVCxPQUFPRCxRQUFRQSxLQUFLTSxhQUFhLEdBQUdOLEtBQUtXLFFBQVEsS0FBS0gsT0FBT0csUUFBUSxLQUFLLE9BQU8sS0FBSyxJQUFJRCxLQUFLRSxlQUFlO0FBQ2hJO0FBQ0EsU0FBU1gsT0FBT1ksS0FBSztJQUNuQixPQUFPQSxpQkFBaUJDLFFBQVFELGlCQUFpQlQsVUFBVVMsT0FBT0MsSUFBSTtBQUN4RTtBQUNBLFNBQVNDLFVBQVVGLEtBQUs7SUFDdEIsT0FBT0EsaUJBQWlCRyxXQUFXSCxpQkFBaUJULFVBQVVTLE9BQU9HLE9BQU87QUFDOUU7QUFDQSxTQUFTQyxjQUFjSixLQUFLO0lBQzFCLE9BQU9BLGlCQUFpQkssZUFBZUwsaUJBQWlCVCxVQUFVUyxPQUFPSyxXQUFXO0FBQ3RGO0FBQ0EsU0FBU0MsYUFBYU4sS0FBSztJQUN6Qix5Q0FBeUM7SUFDekMsSUFBSSxPQUFPTyxlQUFlLGFBQWE7UUFDckMsT0FBTztJQUNUO0lB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LGFBQWFYLGNBQWM3QztJQUNqQyxJQUFJOEMsc0JBQXNCVSxhQUFhO1FBQ3JDLE9BQU94RCxLQUFLTSxhQUFhLEdBQUdOLEtBQUtNLGFBQWEsQ0FBQ3FELElBQUksR0FBRzNELEtBQUsyRCxJQUFJO0lBQ2pFO0lBQ0EsSUFBSTFDLGNBQWN1QyxlQUFlbkMsa0JBQWtCbUMsYUFBYTtRQUM5RCxPQUFPQTtJQUNUO0lBQ0EsT0FBT0UsMkJBQTJCRjtBQUNwQztBQUNBLFNBQVNJLHFCQUFxQjVELElBQUksRUFBRTZELElBQUksRUFBRUMsZUFBZTtJQUN2RCxJQUFJQztJQUNKLElBQUlGLFNBQVMsS0FBSyxHQUFHO1FBQ25CQSxPQUFPLEVBQUU7SUFDWDtJQUNBLElBQUlDLG9CQUFvQixLQUFLLEdBQUc7UUFDOUJBLGtCQUFrQjtJQUNwQjtJQUNBLE1BQU1FLHFCQUFxQk4sMkJBQTJCMUQ7SUFDdEQsTUFBTWlFLFNBQVNELHVCQUF3QixFQUFDRCx1QkFBdUIvRCxLQUFLTSxhQUFhLEtBQUssT0FBTyxLQUFLLElBQUl5RCxxQkFBcUJKLElBQUk7SUFDL0gsTUFBTU8sTUFBTTlELFVBQVU0RDtJQUN0QixJQUFJQyxRQUFRO1FBQ1YsT0FBT0osS0FBS00sTUFBTSxDQUFDRCxLQUFLQSxJQUFJRSxjQUFjLElBQUksRUFBRSxFQUFFL0Msa0JBQWtCMkMsc0JBQXNCQSxxQkFBcUIsRUFBRSxFQUFFRSxJQUFJRyxZQUFZLElBQUlQLGtCQUFrQkYscUJBQXFCTSxJQUFJRyxZQUFZLElBQUksRUFBRTtJQUN0TTtJQUNBLE9BQU9SLEtBQUtNLE1BQU0sQ0FBQ0gsb0JBQW9CSixxQkFBcUJJLG9CQUFvQixFQUFFLEVBQUVGO0FBQ3RGO0FBRW1UIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmVuZ2dyaS5naXRodWIuaW8vLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLnV0aWxzLmRvbS5tanM/YTVhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBnZXROb2RlTmFtZShub2RlKSB7XG4gIGlmIChpc05vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gKG5vZGUubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgLy8gTW9ja2VkIG5vZGVzIGluIHRlc3RpbmcgZW52aXJvbm1lbnRzIG1heSBub3QgYmUgaW5zdGFuY2VzIG9mIE5vZGUuIEJ5XG4gIC8vIHJldHVybmluZyBgI2RvY3VtZW50YCBhbiBpbmZpbml0ZSBsb29wIHdvbid0IG9jY3VyLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzIzMTdcbiAgcmV0dXJuICcjZG9jdW1lbnQnO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgdmFyIF9ub2RlJG93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiAobm9kZSA9PSBudWxsID8gdm9pZCAwIDogKF9ub2RlJG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSB8fCB3aW5kb3c7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQobm9kZSkge1xuICB2YXIgX3JlZjtcbiAgcmV0dXJuIChfcmVmID0gKGlzTm9kZShub2RlKSA/IG5vZGUub3duZXJEb2N1bWVudCA6IG5vZGUuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZWYuZG9jdW1lbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNOb2RlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE5vZGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLk5vZGU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkhUTUxFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNTaGFkb3dSb290KHZhbHVlKSB7XG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgYFNoYWRvd1Jvb3RgIHN1cHBvcnQuXG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2hhZG93Um9vdCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuU2hhZG93Um9vdDtcbn1cbmZ1bmN0aW9uIGlzT3ZlcmZsb3dFbGVtZW50KGVsZW1lbnQpIHtcbiAgY29uc3Qge1xuICAgIG92ZXJmbG93LFxuICAgIG92ZXJmbG93WCxcbiAgICBvdmVyZmxvd1ksXG4gICAgZGlzcGxheVxuICB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbnxjbGlwLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKSAmJiAhWydpbmxpbmUnLCAnY29udGVudHMnXS5pbmNsdWRlcyhkaXNwbGF5KTtcbn1cbmZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmNsdWRlcyhnZXROb2RlTmFtZShlbGVtZW50KSk7XG59XG5mdW5jdGlvbiBpc0NvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIGNvbnN0IHdlYmtpdCA9IGlzV2ViS2l0KCk7XG4gIGNvbnN0IGNzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcbiAgcmV0dXJuIGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCAoY3NzLmNvbnRhaW5lclR5cGUgPyBjc3MuY29udGFpbmVyVHlwZSAhPT0gJ25vcm1hbCcgOiBmYWxzZSkgfHwgIXdlYmtpdCAmJiAoY3NzLmJhY2tkcm9wRmlsdGVyID8gY3NzLmJhY2tkcm9wRmlsdGVyICE9PSAnbm9uZScgOiBmYWxzZSkgfHwgIXdlYmtpdCAmJiAoY3NzLmZpbHRlciA/IGNzcy5maWx0ZXIgIT09ICdub25lJyA6IGZhbHNlKSB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZScsICdmaWx0ZXInXS5zb21lKHZhbHVlID0+IChjc3Mud2lsbENoYW5nZSB8fCAnJykuaW5jbHVkZXModmFsdWUpKSB8fCBbJ3BhaW50JywgJ2xheW91dCcsICdzdHJpY3QnLCAnY29udGVudCddLnNvbWUodmFsdWUgPT4gKGNzcy5jb250YWluIHx8ICcnKS5pbmNsdWRlcyh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgbGV0IGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgaWYgKGlzQ29udGFpbmluZ0Jsb2NrKGN1cnJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzV2ViS2l0KCkge1xuICBpZiAodHlwZW9mIENTUyA9PT0gJ3VuZGVmaW5lZCcgfHwgIUNTUy5zdXBwb3J0cykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gQ1NTLnN1cHBvcnRzKCctd2Via2l0LWJhY2tkcm9wLWZpbHRlcicsICdub25lJyk7XG59XG5mdW5jdGlvbiBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUobm9kZSkge1xuICByZXR1cm4gWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5jbHVkZXMoZ2V0Tm9kZU5hbWUobm9kZSkpO1xufVxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVTY3JvbGwoZWxlbWVudCkge1xuICBpZiAoaXNFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5wYWdlWE9mZnNldCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQucGFnZVlPZmZzZXRcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUobm9kZSkge1xuICBpZiAoZ2V0Tm9kZU5hbWUobm9kZSkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9XG4gIC8vIFN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlLlxuICBub2RlLmFzc2lnbmVkU2xvdCB8fFxuICAvLyBET00gRWxlbWVudCBkZXRlY3RlZC5cbiAgbm9kZS5wYXJlbnROb2RlIHx8XG4gIC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWQuXG4gIGlzU2hhZG93Um9vdChub2RlKSAmJiBub2RlLmhvc3QgfHxcbiAgLy8gRmFsbGJhY2suXG4gIGdldERvY3VtZW50RWxlbWVudChub2RlKTtcbiAgcmV0dXJuIGlzU2hhZG93Um9vdChyZXN1bHQpID8gcmVzdWx0Lmhvc3QgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKG5vZGUpO1xuICBpZiAoaXNMYXN0VHJhdmVyc2FibGVOb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudCA/IG5vZGUub3duZXJEb2N1bWVudC5ib2R5IDogbm9kZS5ib2R5O1xuICB9XG4gIGlmIChpc0hUTUxFbGVtZW50KHBhcmVudE5vZGUpICYmIGlzT3ZlcmZsb3dFbGVtZW50KHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKHBhcmVudE5vZGUpO1xufVxuZnVuY3Rpb24gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMobm9kZSwgbGlzdCwgdHJhdmVyc2VJZnJhbWVzKSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50MjtcbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuICBpZiAodHJhdmVyc2VJZnJhbWVzID09PSB2b2lkIDApIHtcbiAgICB0cmF2ZXJzZUlmcmFtZXMgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvciA9IGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKG5vZGUpO1xuICBjb25zdCBpc0JvZHkgPSBzY3JvbGxhYmxlQW5jZXN0b3IgPT09ICgoX25vZGUkb3duZXJEb2N1bWVudDIgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50Mi5ib2R5KTtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KHNjcm9sbGFibGVBbmNlc3Rvcik7XG4gIGlmIChpc0JvZHkpIHtcbiAgICByZXR1cm4gbGlzdC5jb25jYXQod2luLCB3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzT3ZlcmZsb3dFbGVtZW50KHNjcm9sbGFibGVBbmNlc3RvcikgPyBzY3JvbGxhYmxlQW5jZXN0b3IgOiBbXSwgd2luLmZyYW1lRWxlbWVudCAmJiB0cmF2ZXJzZUlmcmFtZXMgPyBnZXRPdmVyZmxvd0FuY2VzdG9ycyh3aW4uZnJhbWVFbGVtZW50KSA6IFtdKTtcbiAgfVxuICByZXR1cm4gbGlzdC5jb25jYXQoc2Nyb2xsYWJsZUFuY2VzdG9yLCBnZXRPdmVyZmxvd0FuY2VzdG9ycyhzY3JvbGxhYmxlQW5jZXN0b3IsIFtdLCB0cmF2ZXJzZUlmcmFtZXMpKTtcbn1cblxuZXhwb3J0IHsgZ2V0Q29tcHV0ZWRTdHlsZSwgZ2V0Q29udGFpbmluZ0Jsb2NrLCBnZXREb2N1bWVudEVsZW1lbnQsIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yLCBnZXROb2RlTmFtZSwgZ2V0Tm9kZVNjcm9sbCwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIGdldFBhcmVudE5vZGUsIGdldFdpbmRvdywgaXNDb250YWluaW5nQmxvY2ssIGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgaXNMYXN0VHJhdmVyc2FibGVOb2RlLCBpc05vZGUsIGlzT3ZlcmZsb3dFbGVtZW50LCBpc1NoYWRvd1Jvb3QsIGlzVGFibGVFbGVtZW50LCBpc1dlYktpdCB9O1xuIl0sIm5hbWVzIjpbImdldE5vZGVOYW1lIiwibm9kZSIsImlzTm9kZSIsIm5vZGVOYW1lIiwidG9Mb3dlckNhc2UiLCJnZXRXaW5kb3ciLCJfbm9kZSRvd25lckRvY3VtZW50Iiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3Iiwid2luZG93IiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiX3JlZiIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwidmFsdWUiLCJOb2RlIiwiaXNFbGVtZW50IiwiRWxlbWVudCIsImlzSFRNTEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzU2hhZG93Um9vdCIsIlNoYWRvd1Jvb3QiLCJpc092ZXJmbG93RWxlbWVudCIsImVsZW1lbnQiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImRpc3BsYXkiLCJnZXRDb21wdXRlZFN0eWxlIiwidGVzdCIsImluY2x1ZGVzIiwiaXNUYWJsZUVsZW1lbnQiLCJpc0NvbnRhaW5pbmdCbG9jayIsIndlYmtpdCIsImlzV2ViS2l0IiwiY3NzIiwidHJhbnNmb3JtIiwicGVyc3BlY3RpdmUiLCJjb250YWluZXJUeXBlIiwiYmFja2Ryb3BGaWx0ZXIiLCJmaWx0ZXIiLCJzb21lIiwid2lsbENoYW5nZSIsImNvbnRhaW4iLCJnZXRDb250YWluaW5nQmxvY2siLCJjdXJyZW50Tm9kZSIsImdldFBhcmVudE5vZGUiLCJpc0xhc3RUcmF2ZXJzYWJsZU5vZGUiLCJDU1MiLCJzdXBwb3J0cyIsImdldE5vZGVTY3JvbGwiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsInJlc3VsdCIsImFzc2lnbmVkU2xvdCIsInBhcmVudE5vZGUiLCJob3N0IiwiZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3IiLCJib2R5IiwiZ2V0T3ZlcmZsb3dBbmNlc3RvcnMiLCJsaXN0IiwidHJhdmVyc2VJZnJhbWVzIiwiX25vZGUkb3duZXJEb2N1bWVudDIiLCJzY3JvbGxhYmxlQW5jZXN0b3IiLCJpc0JvZHkiLCJ3aW4iLCJjb25jYXQiLCJ2aXN1YWxWaWV3cG9ydCIsImZyYW1lRWxlbWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs\n");

/***/ })

};
;